{"./":{"url":"./","title":"介绍","keywords":"","body":" Chameleon Chameleon/kəˈmiːlɪən/，简写CML，中文名卡梅龙；中文意思变色龙，意味着就像变色龙一样能适应不同环境的跨端整体解决方案。 文档 主站: CMLJS.org 安装 快速上手 API文档 组件文档 后续规划 背景 研发同学在端内既追求h5的灵活性，也要追求性能趋近于原生。 面对入口扩张，主端、独立端、微信小程序、支付宝小程序、百度小程序、Android厂商联盟快应用，单一功能在各平台都要重复实现，开发和维护成本成倍增加。迫切需要维护一套代码可以构建多入口的解决方案，历经近20个月打磨，滴滴跨端解决方案Chameleon终于发布。真正专注于让一套代码运行多端。 设计理念 软件架构设计里面最基础的概念“拆分”和“合并”，拆分的意义是“分而治之”，将复杂问题拆分成单一问题解决，比如后端业务系统的”微服务化“设计；“合并”的意义是将同样的业务需求抽象收敛到一块，达成高效率高质量的目的，例如后端业务系统中的“中台服务”设计。 而 Chameleon 属于后者，通过定义统一的语言框架 + 多态协议，从多端（对应多个独立服务）业务中抽离出自成体系、连续性强、可维护强的“前端中台服务”。 跨端目标 不同各端环境千变万化，万变不离其宗的是 MVVM 架构思想，Chameleon 目标是让MVVM跨端环境大统一。 学习全景图 开发语言 \b从事过网页编程的人知道，网页编程采用的是HTML + CSS + JS这样的组合，同样道理，chameleon中采用的是 \bCML + CMSS + JS。 JS语法用于处理页面的逻辑层，与普通网页编程相比，本项目目标定义标准MVVM框架，拥有完整的生命周期，watch，\bcomputed，数据双向绑定等优秀的特性，能够快速提高开发速度、降低维护成本。 CML（Chameleon Markup Language）用于描述页面的结构，我们知道HTML是有一套标准的语义化标签，例如\b文本是 \b按钮是。CML同样具有一套标准的标签，我们将标签定义为组件，CML为用户提供了一系列组件。同时CML中还支持模板语法，例如条件渲染、列表渲染，数据绑定等等。同时，CML支持使用类VUE语法，让你更快入手。 CMSS(Chameleon Style Sheets)用于描述CML\b页面结构的样式语言，其具有大部分CSS的特性，并且还可以支持各种c\bss的预处语言less stylus。 \b通过以上对于开发语言的介绍，相信你看到只要是有过网页编程知识的人都可以快速的上手chameleon的开发。 丰富的组件 在用CML写页面时，chameleon提供了丰富的组件供开发者使用，内置的有button switch radio checkbox等组件，扩展的有c-picker c-dialog c-loading等等,\b覆盖了开发工作中常用的组件。 丰富的API 为了方便开发者的高效开发，chameleon提供了丰富的API库,发布为npm包chameleon-api，里面包括了网络请求、数据存储、地理位置、系统信息、动画等方法。 自由定制API和组件 基于强大的多态协议，可自由扩展任意API和组件，不强依赖框架的更新。各端原始项目中已积累大量组件，也能直接引入到跨端项目中使用。 智能规范校验 代码规范校验，当出现不符合规范要求的代码时，编辑器会展示智能提示，不用挨个调试各端代码，同时命令行启动窗口也会提示代码的\b\b\b错误位置。 渐进式跨端 既想一套代码运行多端，又不用大刀阔斧的重构项目，可以将多端重用组件用Chameleon开发，直接在原有项目里面调用。 先进前端开发体验 Chameleon 不仅仅是跨端解决方案。基于优秀的前端打包工具Webpack，吸收了业内多年来积累的最有用的工程化设计，提供了前端基础开发脚手架命令工具，帮助端开发者从开发、联调、测试、上线等全流程高效的完成业务开发。 联系我们 ChameleonCore@didiglobal.com 微信 & QQ交流群 微信 QQ "},"quick_start/quick_start.html":{"url":"quick_start/quick_start.html","title":"快速上手","keywords":"","body":"快速上手 1 安装启动 [success] 运行环境 node >= 8.10.0 npm >= 5.6.0 建议安装使用nvm管理node版本 1.1 全局安装chameleon-tool构建工具 npm i -g chameleon-tool 安装成功后，执行 cml -v 即可查看当前版本， cml -h查看命令行帮助文档。 [success] 尝鲜版 尝鲜版提供了百度小程序和支付宝小程序的支持如果想提前使用可移步这里查看使用 1.2 创建项目与启动 执行 cml init project 输入项目名称 等待自动执行npm install依赖 切换到项目根目录执行cml dev 会自动打开预览界面 预览界面如下： web端可以点击模拟器内页面右上角打开\b新的浏览器窗口。 native端的效果请\b下载chameleon playground(目前可下载Android端，IOS端即将发布)或者下载weex playground扫码预览 小程序端请下载微信开发者工具，打开项目根目录下的 /dist/wx 目录预览。 支付宝、百度小程序、快应用正在努力测试中，尽请期待。 2 目录与文件结构 生成的目录结构如下，详细介绍参见目录结构： ├── chameleon.config.js // 项目的配置文件 ├── dist // 打包产出目录 ├── mock // 模拟数据目录 ├── node_modules // npm包依赖 ├── package.json └── src // 项目源代码 ├── app // app启动入口 ├── components // 组件文件夹 ├── pages // 页面文件夹 ├── router.config.json // 路由配置 └── store // 全局状态管理 \b编辑器中语法高亮，暂时使用.vue的插件，参见编辑器插件，后续会推出更强大的插件。 4 语法体验 替换src/pages/index/index.cml文件，删除src/pages/index/index.cml文件中的所有代码，然后替换为下面的代码，体验chameleon语法。 数据绑定 {{ message }} {{ message2 }} {{idx}}: {{itemName.city}} 切换展示 class Index { data = { message: 'Hello Chameleon!', array: [ { city: '北京' }, { city: '上海' }, { city: '广州' } ], showlist: true } computed = { message2: function() { return 'computed' + this.message; } } watch = { showlist(newVal, oldVal) { console.log(`showlist changed:`+ newVal) } } methods = { changeShow() { this.showlist = !this.showlist; } } created() { console.log('生命周期') } } export default new Index(); .class1 { color: #f00; } {} 5 创建新页面 项目根目录下\b执行\bcml init page, 输入页面名称page2 $ cml init page ? Please input page name: 回车，即可生成页面\b组件src/pages/page2/page2.cml。 6 创建及引用组件 项目根目录下\b执行\bcml init component，选择普通组件,输入com2，\b回车，即可生成文件components/com2/com2.cml。 组件也是cml文件\b结构上与页面相同。 拷贝如下代码到com2.cml 我是组件com2 class Com2 { } export default new Com2(); .com2-text { color: #0f0; } {} 然后在刚才的src/pages/index/index.cml中引用com2 { \"base\": { \"usingComponents\": { \"com2\": \"components/com2/com2\" } } } template中使用com2组件。 经过以上操作，你已经学会了组件的引用，丰富的组件等待着你去学习! 进阶\b体验 7 项目配置 chameleon.config.js为项目的配置文件，以后定制化构建会\b使用到，比如是否带hash，是否\b压缩等等,可以在项目根目录下执行cml build \b，\b执行完成后\b，项目根目录的dist文件夹下生成build模式的文件。 8 模拟\b数据 mock/api/index.js文件内容如下，可以本地模拟api请求。访问localhost:8000/api/getMessage\b即可看到模拟的api返回。端口以实际启动为准，默认8000. module.exports = [ { method: ['get', 'post'], path: '/api/getMessage', controller: function (req, res, next) { res.json({ total: 0, message: [{ name: 'Hello chameleon!' }] }); } } ]; 9 \b示例demo学习 \bchameleon-tool中内置了todolist的项目模板，\b通过命令cml init project --demo todo 即可生成该模板，按照1.2节中的说明启动项目，即可看到如下页面 经过以上的介绍和实践操作，相信你已经了解了chameleon的基本使用，本文档其余部分将涵盖剩余功能和其他高级功能的详尽细节，所以请务必完整阅读整个文档！ 10 FAQ 我想使用chameleon，是否需要大刀阔斧的重构项目？ 不需要，可以使用chameleon开发公用组件，导出到各端原有项目中使用。 用CML标准编写代码，是否增加调试成本？ 我们实现了全面的语法检查功能，且在持续加强。理论上框架是降低调试成本，就像从原生js开发到vuejs、reactjs是否认为也增加了调试成本，见仁见智。 各端包括小程序的接口更新频繁，如何保证框架编译的抽象度和稳定性？ 1、自建输入语法标准 cml，编译输出结果自定的格式语法。 2、框架的runtime层实现匹配接收的编译输出代码，runtime跟随小程序更新。 3、框架整体方向一致：mvvm底层设计模式为标准设计接口。 基于以上三条，你可以理解为：我们设计了一个框架统一标准协议，再在各个端runtime分别实现这个框架，宏观的角度就像nodejs同时运行在window和macOS系统，就像flutter运行在Android和iOS一个道理。各端小程序接口更新除非遇到不向下兼容情况，否则不影响框架，如果真遇到不向下兼容更新，这种情况下是否用框架都需要改。 框架有多大，性能是否有影响？ 1、小程序的主要运行性能瓶颈是webview和js虚拟机的传输性能，我们在这里会做优化，尽可能diff出修改的部分进行传输，性能会更好。 2、包大小，小程序有包大小限制，web端包大小也是工程师关心的点。首先基于多态协议，产出包纯净保留单端代码；其次框架的api和组件会按需打包。包大小是我们重点发力点，会持续优化到极致。目前build模式包大小测试结果如下: minimize | minimize + gzip 平台js总体积外部框架chameleon运行时代码其他代码 web 141.87kb | 43.72kb vue+vuex+vue-router 99.26kb | 33.89kb 35.96kb | 8.85kb 业务代码 weex 135kb | 32.43kb vuex+vue-router 33.49kb | 17.96kb 25.23kb | 5.94kb 业务代码 wx 101.66kb | 28.12kb mobx算在chameleon运行时中 98.75kb | 26.53kb 业务代码 baidu 101.72kb | 28.13kb mobx算在chameleon运行时中 98.78kb | 26.61kb 业务代码 alipay 102kb | 28.12kb mobx算在chameleon运行时中 99.15kb | 26.34kb 业务代码 我只想跨web和各类小程序，是否可以不使用 Flexbox 布局模型？ 可以，如果你的项目不在 快应用、react-native、weex等平台运行，可以更便捷开发项目，特别是CSS的限制更少： 只跨web和小程序的应用 "},"framework/framework.html":{"url":"framework/framework.html","title":"框架","keywords":"","body":"框架 Chameleon 不仅仅是跨端解决方案，让开发者\b高效、低成本开发多端原生应用。基于优秀的前端打包工具Webpack，吸收了业内多年来积累的最有用的工程化设计，提供了前端基础开发脚手架命令工具，帮助端开发者从开发、联调、测试、上线等全流程高效的完成业务开发。 框架提供了自己的视图层描述语言 \bCML 和 CMSS，以及基于 JavaScript 的逻辑层框架，并在视图层与逻辑层间提供了数据传输和事件系统，让开发者能够专注于数据与逻辑。 脚手架工具 基于node开发的脚手架工具，提供简洁的命令，进行初始化与构建项目。 目录结构 \b提供规范化的项目结构，适合于企业级大型应用的开发，CML单文件组件的开发模式更有利于提高开发效率与优化文件组织结构。 视图层与\b逻辑层 视图层由 CML 与 CMSS 编写，逻辑层由JS编写，chameleon的核心是一个标准\b响应式数据驱动视图更新的MVVM框架。 多态协议 提供了跨端时各端底层组件与接口统一的解决方案，使开发者可以自由扩展原生api与组件\b。 规范校验 为了提高开发的效率与代码的可维护性，chameleon提供了全面的代码规范与校验，\b帮助开发者能够得到更好的开发体验。 "},"quick_start/cml_cmd.html":{"url":"quick_start/cml_cmd.html","title":"脚手架工具","keywords":"","body":"脚手架工具 chameleon-tool是chameleon的脚手架工具，请按照【快速上手】一节进行安装，该脚手架工具命令详细如下。 获取工具信息 cml -h 或cml --help 查看帮助信息 cml -v 或cml --version 查看chameleon-cli版本信息 初始化项目、页面、组件 cml init -h 查看init命令的帮助信息 cml init project 创建项目 cml init page 创建页面 cml init component 创建组件 cml init project 命令有如下参数 参数名可选值默认值功能 langcml|vuecml设置项目默认模板语法 tplhtml|smartyhtml设置chameleon.config.js中的templateType字段 demoblank|todoblank设置要初始化的项目模板 使用方式: cml init project --参数名 参数值 例如cml init project --lang vue --tpl html 开发/生产模式 cml dev 启动开发模式，默认启动所有\b端的构建，如果不启动某一端可以通过devOffPlatform配置 cml build 启动生产模式打包，默认启动所有\b端的构建，如果不启动某一端可以通过buildOffPlatform配置 web环境 cml web -h 查看web命令的帮助信息 cml web dev 执行web端开发模式构建 cml web build 执行web端打包模式构建 微信小程序环境 cml wx -h 查看wx命令的帮助信息 cml wx dev 执行微信端开发模式构建 也会构建web端，使api mock生效 cml wx build 执行微信端打包模式构建 weex环境 cml weex -h 查看weex命令的帮助信息 cml weex dev 执行weex端开发模式构建，也会构建web端，进行预览调试 cml weex build 执行weex端打包模式构建 在执行web、wx和weex构建命令时，会读取chameleon.config.js中的配置信息，具体配置参见【项目配置】一节。 "},"framework/structure.html":{"url":"framework/structure.html","title":"目录结构","keywords":"","body":"目录结构 项目结构 使用cml init project 生成的项目结构如下： ├── chameleon.config.js // 项目的配置文件 ├── dist // 打包产出目录 ├── mock // 模拟数据目录 ├── node_modules // npm包依赖 ├── package.json └── src // 项目源代码 ├── app // app启动入口 ├── components // 组件文件夹 ├── pages // 页面文件夹 ├── router.config.json // 路由配置文件 └── store // 全局状态管理 文件夹和文件 文件 必须 作用 chameleon.config.js 必须 项目配置文件 dist 必须 自动生成，用户无需关注。项目编译目标目录 mock 必须 数据mock编写文件夹 node_modules 必须 自动生成，用户无需关注。npm包安装文件夹 package.json 必须 npm包配置文件 app 必须 应用启动入口根文件夹 components 必须 用户组件根文件夹 pages 必须 页面根文件夹 router.config.json 必须 路由配置文件 store 必须 数据管理文件夹 CML 文件 一个CML文件开发的组件由四块内容组成，分别是： 标签 必须 属性 作用 template 必须 lang:cml|vue 提供组件结构、事件绑定、数据绑定、样式绑定 script 必须 暂无 组件逻辑 style 必须 lang:less|stylus 组件样式表 json(使用script标签设置cml-type属性) 必须 cml-type:json 组件配置 "},"view/view.html":{"url":"view/view.html","title":"视图层","keywords":"","body":"视图层 视图层由 CML 与 CMSS 编写，提供了“结构”（元素的组织构成）、“外观”（CSS）、“逻辑层的关联”（事件绑定）。 也就是将逻辑层的数据反应成视图，同时将视图层的事件发送给逻辑层。 如果说逻辑层是终端开发的“灵魂”，那么视图层是终端开发的“肉体”。 CMSS CMSS(Chameleon Style Sheet) 用于描述页面的样式。 CML-标准语法 CML(Chameleon Markup language) 用于描述页面的结构。 CML-类vue语法 为了降低学习成本，独立支持了vue的指令子集 "},"view/cmss.html":{"url":"view/cmss.html","title":"CMSS","keywords":"","body":"CMSS CMSS(Chameleon Style Sheets)是一套样式语言，用于描述 CML 的组件样式。 尺寸单位 为了统一多端尺寸单位，呈现效果一致，同时页面响应式，项目中统一采用cpx作为尺寸单位，规定以屏幕750px视觉稿作为标准。 禁止.cml中使用px，若要使用请使用多态协议。 布局 采用 FlexBox 布局模型，请勿使用float方式布局。 普通写法 具体实现写在.cml的标签内。 目前支持有如下两种关联到元素上： 静态class 动态class 目前 class 不支持传入对象的形式； 简单数据绑定 {{}}之内的会被当做一个表达式去处理； class数据绑定 class Index { data () { return { prefix: 'cls' } } } export default new Index(); 三元运算符 或者将其放入计算属性 class Index { computed = { itemClass() { return open ? 'cls1 cls2' : 'cls3 cls4'; } } } export default new Index(); 数组语法： dataClassArr class Index { computed = { computedClassArr() { return ['cls-a', 'cls-b']; } } } export default new Index(); 内联写法 模版中写内联样式，分为静态和动态两种，静态样式指纯字符串，动态样式是有数据绑定。style也不支持对象语法和数组语法； 目前可以使用的方式如下： 静态样式： 动态样式： class Index { data = { inlineStyle: 'border: 1px solid red;' } } export default new Index(); 只跨web和小程序的应用 受限于客户端的 CMSS 渲染能力，开发会有诸多限制。如果您只需要跨H5和小程序应用时，开发会变得很轻便。 "},"view/cmss/layout.html":{"url":"view/cmss/layout.html","title":"布局","keywords":"","body":"布局 Flexbox chameleon 布局模型基于 CSS Flexbox，以便所有页面元素的排版能够一致可预测，同时页面布局能适应各种设备或者屏幕尺寸。 Flexbox 包含 flex 容器和 flex 成员项。如果一个 chameleon 元素可以容纳其他元素，那么它就成为 flex 容器。需要注意的是，flexbox 的老版规范相较新版有些出入，比如是否能支持 wrapping。这些都描述在 W3C 的工作草案中了，你需要注意下新老版本之间的不同。 Flex 容器 在 chameleon 中，Flexbox 是默认且唯一的布局模型，所以你不需要手动为元素添加 display: flex; 属性。 flex-direction： 定义了 flex 容器中 flex 成员项的排列方向。可选值为 row | column，默认值为 column column：从上到下排列。 row：从左到右排列。 justify-content： 定义了 flex 容器中 flex 成员项在主轴方向上如何排列以处理空白部分。可选值为 flex-start | flex-end | center | space-between，默认值为 flex-start。 flex-start：是默认值，所有的 flex 成员项都排列在容器的前部； flex-end：则意味着成员项排列在容器的后部； center：即中间对齐，成员项排列在容器中间、两边留白； space-between：表示两端对齐，空白均匀地填充到 flex 成员项之间。 space-around：每个项目两侧的间隔相等。所以，项目之间的间隔比项目与边框的间隔大一倍。 align-items： 定义了 flex 容器中 flex 成员项在纵轴方向上如何排列以处理空白部分。可选值为 stretch | flex-start | center | flex-end，默认值为 stretch。 stretch： 是默认值，即拉伸高度至 flex 容器的大小； flex-start： 则是上对齐，所有的成员项排列在容器顶部； flex-end： 是下对齐，所有的成员项排列在容器底部； center： 是中间对齐，所有成员项都垂直地居中显示。 baseline： 项目的第一行文字的基线对齐。 flex-flow 说明: flex-flow 属性是 flex-direction 和 flex-wrap 属性的复合属性, 用于设置或检索弹性盒模型对象的子元素排列方式。 flex-direction 属性规定灵活项目的方向。 flex-wrap 属性规定灵活项目是否拆行或拆列。 语法: flex-flow: flex-direction flex-wrap; Flex 成员项 flex 属性定义了 flex 成员项可以占用容器中剩余空间的大小。如果所有的成员项设置相同的值 flex: 1，它们将平均分配剩余空间. 如果一个成员项设置的值为 flex: 2，其它的成员项设置的值为 flex: 1，那么这个成员项所占用的剩余空间是其它成员项的2倍。 flex {number}：值为 number 类型。 示例 一个简单的网格布局。 {{text}} class Index { data = { list: [ ['A', 'B', 'C'], ['D', 'E', 'F'], ['G', 'H', 'I'] ] } } export default new Index(); .item{ flex:1; justify-content: center; align-items:center; border-width:1; } .row{ flex-direction: row; height:80cpx; } { \"base\": {} } 定位 chameleon 支持 position 定位，用法与 CSS position 类似。为元素设置 position 后，可通过 top、right、bottom、left 四个属性设置元素坐标。 position {string}： 设置定位类型。可选值为 relative | absolute | fixed | sticky，默认值为 relative。 relative 是默认值，指的是相对定位； absolute 是绝对定位，以元素的容器作为参考系； fixed 保证元素在页面窗口中的对应位置显示； sticky 指的是仅当元素滚动到页面之外时，元素会固定在页面窗口的顶部。 top {number}：距离上方的偏移量，默认为 0。 bottom {number}：距离下方的偏移量，默认为 0。 left {number}：距离左方的偏移量，默认为 0。 right {number}：距离右方的偏移量，默认为 0。 示例 class Index { } export default new Index(); .wrapper { position: absolute; top: 0; right: 0; bottom: 0; left: 0; background-color: #cccccc; } .box { width: 400cpx; height: 400cpx; position: absolute; } .box1 { top: 0; left: 0; background-color: #ff0000; } .box2 { top: 150cpx; left: 150cpx; background-color: #0055dd; } .box3 { top: 300cpx; left: 300cpx; background-color: #00ff49; } { \"base\": {} } "},"view/cmss/box.html":{"url":"view/cmss/box.html","title":"盒模型","keywords":"","body":"盒模型 chameleon 盒模型基于 CSS 盒模型，每个 chameleon 元素都可视作一个盒子。我们一般在讨论设计或布局时，会提到「盒模型」这个概念。 盒模型描述了一个元素所占用的空间。每一个盒子有四条边界：外边距边界 margin edge, 边框边界 border edge, 内边距边界 padding edge 与内容边界 content edge。这四层边界，形成一层层的盒子包裹起来，这就是盒模型大体上的含义。 width {length}：，默认值 0 height {length}：，默认值 0 padding {length}：内边距，内容和边框之间的距离。默认值 0 可有以下写法: - `padding-left {length}`：，默认值 0 - `padding-right {length}`：，默认值 0 - `padding-top {length}`：，默认值 0 - `padding-bottom {length}`：，默认值 0 支持简写模式：padding：{length length length length} margin： 外边距，元素和元素之间的空白距离。值类型为 length，默认值 0 可有如下写法： - `margin-left {length}`：，默认值 0 - `margin-right {length}`：，默认值 0 - `margin-top {length}`：，默认值 0 - `margin-bottom {length}`：，默认值 0 支持简写模式：margin:{length length length length} border： 设定边框，简写方式：border：1px solid #ff0000; 可有如下写法： - border-style： 设定边框样式，值类型为 string，可选值为 `solid | dashed | dotted`，默认值 solid 可有如下写法： - `border-left-style {string}`：可选值为 `solid | dashed | dotted`，默认值 solid - `border-top-style {string}`：可选值为 `solid | dashed | dotted`，默认值 solid - `border-right-style {string}`：可选值为 `solid | dashed | dotted`，默认值 solid - `border-bottom-style {string}`：可选值为 `solid | dashed | dotted`，默认值 solid - border-width {length}： 设定边框宽度，非负值, 默认值 0 可有如下写法： - `border-left-width {length}`：，非负值, 默认值 0 - `border-top-width {length}`：，非负值, 默认值 0 - `border-right-width {length}`：，非负值, 默认值 0 - `border-bottom-width {length}`：，非负值, 默认值 0 - border-color {color}： 设定边框颜色，默认值 `#000000` 可有如下写法： - `border-left-color {color}`：，默认值 #000000 - `border-top-color {color}`：，默认值 #000000 - `border-right-color {color}`：，默认值 #000000 - `border-bottom-color {color}`：，默认值 #000000 - border-radius {length}： 设定圆角，默认值 0 可有如下写法： - `border-bottom-left-radius {length}`：，非负值, 默认值 0 - `border-bottom-right-radius {length}`：，非负值, 默认值 0 - `border-top-left-radius {length}`：，非负值, 默认值 0 - `border-top-right-radius {length}`：，非负值, 默认值 0 注意 chameleon 盒模型的 box-sizing 默认为 border-box，即盒子的宽高包含内容、内边距和边框的宽度，不包含外边距的宽度。 目前在 组件上尚无法只定义一个或几个角的 border-radius。比如你无法在这两个组件上使用 border-top-left-radius。该约束只对 iOS 生效，Android 并不受此限制。 尽管 overflow:hidden 在 Android 上是默认行为，但只有下列条件都满足时，一个父 view 才会去 clip 它的子 view。这个限制只对 Android 生效，iOS 不受影响。 父view是div, a, cell, refresh 或 loading。 系统版本是 Android 4.3 或更高。 系统版本不是 Andorid 7.0。 父 view 没有 background-image 属性或系统版本是 Android 5.0 或更高。 示例： "},"view/cmss/text.html":{"url":"view/cmss/text.html","title":"文本","keywords":"","body":"文本样式 文本类组件共享一些通用样式, 这类组件目前包括 和。 属性 color {color}：文字颜色。 可选值为色值，支持 RGB（ rgb(255, 0, 0) ）；RGBA（ rgba(255, 0, 0, 0.5) ）；十六进制（ #ff0000 ）；精简写法的十六进制（ #f00 ）；色值关键字（red）。 lines {number}: 指定文本行数。仅在 组件中支持。默认值是 0 代表不限制行数。 font-size {number}：文字大小。 font-style {string}：字体类别。可选值 normal | italic，默认为 normal。 font-weight {string}：字体粗细程度 可选值: normal, bold, 100, 200, 300, 400, 500, 600, 700, 800, 900 normal 等同于 400, bold 等同于 700； 默认值: normal； iOS 支持 9 种 font-weight值；Android 仅支持 400 和 700, 其他值会设为 400 或 700 类似 lighter, bolder 这样的值暂时不支持 text-decoration {string}：字体装饰，可选值 none | underline | line-through，默认值为 none。 text-align {string}：对齐方式。可选值 left | center | right，默认值为 left。目前暂不支持 justify, justify-all。 font-family {string}：设置字体。 这个设置 不保证 在不同平台，设备间的一致性。如所选设置在平台上不可用，将会降级到平台默认字体。 text-overflow {string}：设置内容超长时的省略样式。可选值 clip | ellipsis 其他参考 颜色关键字列表 "},"view/cmss/unit.html":{"url":"view/cmss/unit.html","title":"单位","keywords":"","body":"单位 在chameleon项目中，我们使用cpx作为统一的长度单位。\bcpx可以根据\b\b屏幕宽度自适应，我们规定屏幕宽度为750cpx。你也可以在\b\b\b多态组件灰度层使用某一端的长度单位。 使用cpx设置元素宽度高度 使用cpx设置\b字体大小 Chameleon 使用cpx设置行高 Chameleon CSS color 单位 支持以下写法： .classA { /* 3-chars hex */ color: #0f0; /* 6-chars hex */ color: #00ff00; /* rgba */ color: rgb(255, 0, 0); /* rgba */ color: rgba(255, 0, 0, 0.5); /* transparent */ color: transparent; /* Basic color keywords */ color: orange; /* Extended color keywords */ color: darkgray; } 注意 不支持 hsl(), hsla(), currentColor, 8个字符的十六进制颜色。 rgb(a,b,c) 或 rgba(a,b,c,d) 的性能比其他颜色格式差很多，请选择合适的颜色格式。 颜色名称可查看:颜色名称列表. CSS number 单位 仅仅一个数字。用于 opacity，lines等。 有时值必须是整数，例如：lines。 CSS percentage 单位 (暂不支持) 表示百分比值，如“50％”，“66.7％”等。 它是 CSS 标准的一部分，但 chameleon 暂不支持。 "},"view/cmss/color.html":{"url":"view/cmss/color.html","title":"颜色","keywords":"","body":"支持的颜色名称列表 基础颜色关键词： 颜色名 十六进制RGB值 black(黑) #000000 silver(银) #C0C0C0 gray(灰) #808080 white(白) #FFFFFF maroon(褐紫红) #800000 red(红) #FF0000 purple(紫) #800080 fuchsia(晚樱) #FF00FF green(绿) #008000 lime(石灰) #00FF00 olive(橄榄) #808000 yellow(黄) #FFFF00 navy(海军蓝) #000080 blue(蓝) #0000FF teal(水鸭) #008080 aqua(水蓝) #00FFFF 扩展颜色关键词： 颜色名 十六进制RGB值 aliceblue #F0F8FF antiquewhite #FAEBD7 aqua #00FFFF aquamarine #7FFFD4 azure #F0FFFF beige #F5F5DC bisque #FFE4C4 black #000000 blanchedalmond #FFEBCD blue #0000FF blueviolet #8A2BE2 brown #A52A2A burlywood #DEB887 cadetblue #5F9EA0 chartreuse #7FFF00 chocolate #D2691E coral #FF7F50 cornflowerblue #6495ED cornsilk #FFF8DC crimson #DC143C cyan #00FFFF darkblue #00008B darkcyan #008B8B darkgoldenrod #B8860B darkgray #A9A9A9 darkgreen #006400 darkgrey #A9A9A9 darkkhaki #BDB76B darkmagenta #8B008B darkolivegreen #556B2F darkorange #FF8C00 darkorchid #9932CC darkred #8B0000 darksalmon #E9967A darkseagreen #8FBC8F darkslateblue #483D8B darkslategray #2F4F4F darkslategrey #2F4F4F darkturquoise #00CED1 darkviolet #9400D3 deeppink #FF1493 deepskyblue #00BFFF dimgray #696969 dimgrey #696969 dodgerblue #1E90FF firebrick #B22222 floralwhite #FFFAF0 forestgreen #228B22 fuchsia #FF00FF gainsboro #DCDCDC ghostwhite #F8F8FF gold #FFD700 goldenrod #DAA520 gray #808080 green #008000 greenyellow #ADFF2F grey #808080 honeydew #F0FFF0 hotpink #FF69B4 indianred #CD5C5C indigo #4B0082 ivory #FFFFF0 khaki #F0E68C lavender #E6E6FA lavenderblush #FFF0F5 lawngreen #7CFC00 lemonchiffon #FFFACD lightblue #ADD8E6 lightcoral #F08080 lightcyan #E0FFFF lightgoldenrodyellow #FAFAD2 lightgray #D3D3D3 lightgreen #90EE90 lightgrey #D3D3D3 lightpink #FFB6C1 lightsalmon #FFA07A lightseagreen #20B2AA lightskyblue #87CEFA lightslategray #778899 lightslategrey #778899 lightsteelblue #B0C4DE lightyellow #FFFFE0 lime #00FF00 limegreen #32CD32 linen #FAF0E6 magenta #FF00FF maroon #800000 mediumaquamarine #66CDAA mediumblue #0000CD mediumorchid #BA55D3 mediumpurple #9370DB mediumseagreen #3CB371 mediumslateblue #7B68EE mediumspringgreen #00FA9A mediumturquoise #48D1CC mediumvioletred #C71585 midnightblue #191970 mintcream #F5FFFA mistyrose #FFE4E1 moccasin #FFE4B5 navajowhite #FFDEAD navy #000080 oldlace #FDF5E6 olive #808000 olivedrab #6B8E23 orange #FFA500 orangered #FF4500 orchid #DA70D6 palegoldenrod #EEE8AA palegreen #98FB98 paleturquoise #AFEEEE palevioletred #DB7093 papayawhip #FFEFD5 peachpuff #FFDAB9 peru #CD853F pink #FFC0CB plum #DDA0DD powderblue #B0E0E6 purple #800080 red #FF0000 rosybrown #BC8F8F royalblue #4169E1 saddlebrown #8B4513 salmon #FA8072 sandybrown #F4A460 seagreen #2E8B57 seashell #FFF5EE sienna #A0522D silver #C0C0C0 skyblue #87CEEB slateblue #6A5ACD slategray #708090 slategrey #708090 snow #FFFAFA springgreen #00FF7F steelblue #4682B4 tan #D2B48C teal #008080 thistle #D8BFD8 tomato #FF6347 turquoise #40E0D0 violet #EE82EE wheat #F5DEB3 white #FFFFFF whitesmoke #F5F5F5 yellow #FFFF00 yellowgreen #9ACD32 "},"view/cmss/css_diff.html":{"url":"view/cmss/css_diff.html","title":"样式多态","keywords":"","body":"样式多态 cml文件中的style标签支持样式的多态，即可以针对不同的平台写不同的样式，格式如下： @media cml-type (支持的平台) { } .common { /**/ } 其中支持的平台为可以用逗号分隔多个平台，可选平台\b为web,weex,wx,alipay,baidu。\b demo示例，\bclass1在各端的差异实现。 chameleon class DemoPage { } export default new DemoPage(); @media cml-type (web) { .class1 { color: red; } } @media cml-type (weex) { .class1 { color: green; } } @media cml-type (wx,alipay,baidu) { .class1 { color: blue; } } {} 注意： 多态差异\b语法只能在cml文件中使用，不能在.css,.less等其他样式文件中使用，如果需要分文件实现，可以在多态内部分别引入文件。例如： @media cml-type (web) { @import \"./style1.less\"; } @media cml-type (weex) { @import \"./style2.less\"; } @media cml-type (wx,alipay,baidu) { @import \"./style3.less\"; } "},"view/cmss/base_style.html":{"url":"view/cmss/base_style.html","title":"一致性基础样式","keywords":"","body":"一致性基础样式 通常情况下，H5、小程序、客户端拥有各自的默认样式，各端呈现效果不一。所以，cml框架会给各端添加一致性基础样式。 基础样式包括以下方面： 类型 默认值 布局 display: flex; flex-direction: column; 盒模型 box-sizing: border-box; 定位 position: relative; 文本 display: block; font-size: 16px; white-space: pre-wrap; 针对H5端添加的基础样式如下 .cml-root { width: 100%; overflow-x: hidden; -webkit-tap-highlight-color: transparent; font-family: BlinkMacSystemFont, 'Source Sans Pro', 'Helvetica Neue', Helvetica, Arial, sans-serif; } .cml-base { text-align: left; font-size: 0.4rem; /*15px*/ letter-spacing: 0.02rem; } .cml-base, .cml-base::before, .cml-base::after { box-sizing: border-box; text-size-adjust: none; } .cml-view { display: flex; box-sizing: border-box; position: relative; flex-direction: column; flex-shrink: 0; flex-grow: 0; flex-basis: auto; align-items: stretch; align-content: flex-start; border: 0 solid black; margin: 0; padding: 0; min-width: 0; } .cml-text { display: block; box-sizing: border-box; position: relative; white-space: pre-wrap; /* not using 'pre': support auto line feed. */ word-wrap: break-word; overflow: hidden; /* it'll be clipped if the height is not high enough. */ flex-shrink: 0; flex-grow: 0; flex-basis: auto; border: 0 solid black; margin: 0; padding: 0; min-width: 0; } 针对小程序添加的基础样式如下： .cml-base { text-align: left; font-size: 32rpx; letter-spacing: 1rpx; font-family: BlinkMacSystemFont, 'Source Sans Pro', 'Helvetica Neue', Helvetica, Arial, sans-serif; } .cml-base, .cml-base::before, .cml-base::after { box-sizing: border-box; text-size-adjust: none; } .cml-view { display: flex; box-sizing: border-box; position: relative; flex-direction: column; flex-shrink: 0; flex-grow: 0; flex-basis: auto; align-items: stretch; align-content: flex-start; border: 0 solid black; margin: 0; padding: 0; min-width: 0; } .cml-text { display: block; box-sizing: border-box; position: relative; white-space: pre-wrap; /* not using 'pre': support auto line feed. 保留空白符序列，但是正常地进行换行 */ word-wrap: break-word; /* 在长单词或 URL 地址内部进行换行。 */ overflow: hidden; /* it'll be clipped if the height is not high enough. */ flex-shrink: 0; flex-grow: 0; flex-basis: auto; border: 0 solid black; margin: 0; padding: 0; min-width: 0; } 说明如下： class名 代表含义 .cml-root H5端 app 根节点 .cml-base 任一节点 .cml-view view元素 .cml-text text元素 "},"view/cml.html":{"url":"view/cml.html","title":"CML-标准语法","keywords":"","body":"CML-标准语法 CML（Chameleon Markup Language）用于描述页面的结构，我们知道HTML是有一套标准的语义化标签，例如\b文本是 \b按钮是。CML同样具有一套标准的标签，我们将标签定义为组件，CML为用户提供了一系列基础组件。同时CML中还支持模板语法，例如条件渲染、列表渲染，数据绑定等等。 基础组件 数据绑定 条件渲染 列表渲染 事件 指令 "},"view/databind.html":{"url":"view/databind.html","title":"数据绑定","keywords":"","body":"数据绑定 模板中绑定的数据来均来自于data、computed属性。 简单绑定 数据绑定使用 Mustache 语法（双大括号）, {{}}之内的可以是一些变量或者简单的表达式。 内容 {{ message }} 组件属性 运算 Hidden {{a + b}} + {{c}} + d 5}}\"> class Index { data = { a: 1, b: 2, c: 3, } } export default new Index(); view中的内容为 3 + 3 + d component 动态渲染组件 component接受两个属性 属性名 说明 is 接受一个计算属性作为动态渲染的标签名 shrinkComponents 接受 usingComponents 中的key值组成的字符串作为动态组件选择的范围 注意，为了提高微信端的渲染效率，强烈建议加上shrinkComponents = \"comp1,comp2,...\",缩小动态渲染的查找范围，减少不必要的渲染开销 组件改变 class Index { data = { dataComp: 'comp', } computed ={ currentComp(){ return this.dataComp === 'comp' ? 'comp1' : 'comp'; } } methods = { handleElementClick (a,b) { console.log('handleElementClick',arguments,a,b) this.dataComp = (this.dataComp === 'comp') ? 'comp1' : 'comp'; }, } } export default new Index(); { \"base\": { \"usingComponents\": { \"comp\":\"./comp\", \"comp1\":\"./comp1\", \"comp2\":\"./comp2\", \"comp3\":\"./comp3\", } }, \"wx\": { \"navigationBarTitleText\": \"index\", \"backgroundTextStyle\": \"dark\", \"backgroundColor\": \"#E2E2E2\" } } c-model 应用于表单元素 message:{{message}} class Comp { data = { message:'default-value' } } export default new Comp(); { \"base\": {} } 应用于父子组件之间 父组件 c-model的在组件上的使用 组件使其改变{{modelValueTest2}} class Index { data = { currentComp:'comp1', modelValueTest2:'sss' } methods = { handleClick(){ this.currentComp = (this.currentComp === 'comp1' ) ? 'comp1':'comp2' } } } export default new Index(); .scroller-wrap { display: flex; flex-direction: column; align-items: center; } { \"base\": { \"usingComponents\": { \"comp1\":\"/components/comp1\", \"comp2\":\"/components/comp2\" } }, \"wx\": { \"navigationBarTitleText\": \"index\", \"backgroundTextStyle\": \"dark\", \"backgroundColor\": \"#E2E2E2\" } } 子组件 class Comp { props = { value:{ type:String, default:'default-value' } } methods = { handleInput(e){ console.log('input',e); this.$cmlEmit('input', { value:e.detail.value }) } } } export default new Comp(); { \"base\": {} } "},"view/condition.html":{"url":"view/condition.html","title":"条件渲染","keywords":"","body":"条件渲染 c-if 在框架中，使用 c-if=\"{{condition}}\" 来判断是否需要渲染该代码块： True 也可以用 c-else-if 和 c-else 来添加一个 else 块： 5}}\"> 1 2}}\"> 2 3 block c-if 因为 c-if 是一个控制属性，需要将它添加到一个标签上。如果要一次性判断多个组件标签，可以使用一个 标签将多个组件包装起来，并在上边使用 c-if 控制属性。 view1 view2 注意： 并不是一个组件，它仅仅是一个包装元素，不会在页面中做任何渲染，只接受控制属性。 "},"view/iterator.html":{"url":"view/iterator.html","title":"列表渲染","keywords":"","body":"列表渲染 c-for 在组件上使用 c-for 控制属性绑定一个数组，即可使用数组中各项的数据重复渲染该组件。 默认数组的当前项的下标变量名默认为 index，数组当前项的变量名默认为 item {{index}}: {{item.message}} 使用 c-for-item 可以指定数组当前元素的变量名， 使用 c-for-index 可以指定数组当前下标的变量名： {{idx}}: {{itemName.message}} c-for 也可以嵌套，下边是一个九九乘法表 {{i}} * {{j}} = {{i * j}} block c-for 类似 block c-if，也可以将 c-for 用在标签上，以渲染一个包含多节点的结构块。例如： {{index}}: {{item}} c-key 如果列表中项目的位置会动态改变或者有新的项目添加到列表中，并且希望列表中的项目保持自己的特征和状态（如 中的输入内容，的选中状态），需要使用 c-key 来指定列表中项目的唯一的标识符。 c-key 的值以两种形式提供 1.字符串，代表在 for 循环的 array 中 item 的某个 property，该 property 的值需要是列表中唯一的字符串或数字，且不能动态改变。 2.保留关键字 *this 代表在 for 循环中的 item 本身，这种表示需要 item 本身是一个唯一的字符串或者数字，如： 当数据改变触发渲染层重新渲染的时候，会校正带有 key 的组件，框架会确保他们被重新排序，而不是重新创建，以确保使组件保持自身的状态，并且提高列表渲染时的效率。 "},"view/event.html":{"url":"view/event.html","title":"事件","keywords":"","body":"事件 Chameleon 支持一些基础的事件，保障各端效果一致运行。如果你想要使用某个端特定的事件，请从业务出发使用 组件多态或者接口多态差异化实现功能。 什么是事件 事件是视图层到逻辑层的通讯方式。 事件可以将用户的行为反馈到逻辑层进行处理。 事件可以绑定在组件上，当达到触发事件，就会执行逻辑层中对应的事件处理函数。 事件绑定 当用户点击该组件的时候会在该组件逻辑对象的methods中寻找相应的处理函数 Click me! class Index { methods = { tapName(e) { // 打印事件对象 console.log('事件对象:', e); } } } export default new Index(); 事件类型 chameleon所有元素都支持基础事件类型如下： 类型 触发条件 tap 手指触摸后马上离开 touchstart 手指触摸动作开始 touchmove 手指触摸后移动 touchend 手指触摸动作结束 事件对象 当触发事件时，逻辑层绑定该事件的处理函数会收到一个事件对象。它有以下属性： 名称 类型 说明 type String 事件类型 timeStamp Number 页面打开到触发事件所经过的毫秒数 target Object 触发事件的目标元素 且 target = { id, dataset } currentTarget Object 绑定事件的目标元素 且 currentTarget = { id, dataset } touches Array 触摸事件中的属性，当前停留在屏幕中的触摸点信息的数组 且 touches = [{ identifier, pageX, pageY, clientX, clientY }] changedTouches Array 触摸事件中的属性，当前变化的触摸点信息的数组 且 changedTouches = [{ identifier, pageX, pageY, clientX, clientY }] detail Object 自定义事件所携带的数据。 通过`$cmlEmit`方法触发自定义事件，可以传递自定义数据即detail。具体下面`自定义事件`。 _originEvent Object chameleon对各平台的事件对象进行统一，会把原始的事件对象放到_originEvent属性中，当需要特殊处理的可以进行访问。 target && currentTarget 事件属性 属性类型说明 idString事件源组件的id datasetObject事件源组件上由`data-`开头的自定义属性组成的集合 offsetLeftNumber事件源组件相对于窗口左侧的距离 offsetTopNumber事事件源组件相对于窗口上侧的距离 --> dataset 在组件中可以定义数据，这些数据将会通过事件传递给 SERVICE。 书写方式： 以data-开头，多个单词由连字符-链接，不能有大写(大写会自动转成小写)如data-element-type，最终在 event.currentTarget.dataset 中会将连字符转成驼峰elementType。 示例： DataSet Test class Index { methods = { bindViewTap:function(event){ event.currentTarget.dataset.alphaBeta === 1 // - 会转为驼峰写法 event.currentTarget.dataset.alphabeta === 2 // 大写会转为小写 } } } export default new Index(); touches && changedTouches 事件属性 数组中的对象具有如下属性： 属性类型说明 identifierNumber触摸点的标识符 pageX, pageYNumber距离文档左上角的距离，文档的左上角为原点 ，横向为X轴，纵向为Y轴 clientX, clientYNumber距离页面可显示区域（屏幕除去导航条）左上角距离，横向为X轴，纵向为Y轴 自定义事件 自定义事件用于父子组件之间的通信，父组件给子组件绑定自定义事件，子组件内部触发该事件。绑定事件的方法是以bind+事件名称=\"事件处理函数的形式给组件添加属性，规定事件名称不能存在大写字母触发事件的方法是调用this.$cmlEmit(事件名称,detail对象)。 注意：自定义事件名称不支持click、scroll 例如： 子组件 child 触发自定义事件 class Index { data: {} method: { triggerCustomEvent(e) { this.$cmlEmit('customevent', { company: 'didi', age: 18 }) } } } export default new Index(); 父组件 class Index { data = {} method = { customEventHandler(e) { console.log(e) } } } export default new Index(); 当点击child组件的按钮时，父组件中的customEventHandler方法中打印的e对象如下： { type: \"customevent\", detail: { company: \"didi\", age: 18 } } 支持的语法 事件绑定支持以下几种形式（在内联语句中，$event代表事件对象） 触发元素点击事件 触发元素点击事件（1,2,3） 触发元素点击事件（） 针对以上写法返回的事件对象如下： 写法(1)调用事件函数输出如下 'handleElementTap' [e] 写法(2)调用事件函数输出如下 'handleElementTap' [1,2,3,'messagetestEvent',e] 写法(3)调用事件函数输出如下 'handleElementTap' [] 其他事件说明 事件绑定的写法同组件的属性，以 key、value 的形式。 key 以c-bind，然后跟上事件的类型，如c-bind:tap、c-bind:touchstart。 value 是一个字符串，需要在对应的逻辑对象中声明的methods中声明该方法。 Bug & Tips 不支持的语法 注意，事件绑定不支持直接传入一个表达式，和绑定多个内联执行函数比如 "},"view/directive.html":{"url":"view/directive.html","title":"指令","keywords":"","body":"指令 c-if 根据表达式的真假值条件渲染元素 根据c-if的真假结果决定是否渲染 c-else 不需要表达式; 限制：前一个兄弟元素必须有 c-if 或者 c-else-if 用法 0.5}}\"> Now you see me Now you don't c-else-if 限制：前一个兄弟元素必须有 c-if 或者 c-else-if A B C Not A/B/C c-for {{idx}}: {{itemName.message}} c-model 父组件 c-model的使用 {{modelValueTest}} 组件使其改变{{modelValueTest2}} 子组件 methods = { handleInput(e){ console.log('input',e); this.$cmlEmit('input', { value: Date.now() }) } } } $cmlEmit的事件名必须是 'input',\b传入的参数需要有一个更新的value作为key,\b其属性值作为新值进行更新； c-text 不支持组件的c-text c-show 测试元素c-show 组件v-show 使用c-show的元素不支持\b同时有 style 属性 elementShow是来自data或者computed中的key值,或者true/false c-animation 传入的值必须由createAnimation返回 hello world import cml from 'cml目录'; const animation = cml.createAnimation(); class Index { data = { animationData: {} } methods = { click: function() { this.animationData = animation.opacity(0.1).step({}).export(); } } }; export default new Index(); "},"view/vue.html":{"url":"view/vue.html","title":"CML-类vue语法","keywords":"","body":"CML-类VUE语法 为了降低学习成本，独立支持了vue的指令子集，你可以在模板添加一个lang属性即可使用。 注意必须在组件根元素上 template上加 lang='vue' 数据绑定 条件渲染 列表渲染 事件 指令 "},"view/databind-vue.html":{"url":"view/databind-vue.html","title":"数据绑定","keywords":"","body":"数据绑定 模板中绑定的数据来均来自于data、computed属性。 模板语法 数据绑定使用 Mustache 语法（双大括号）将变量包起来，可以作用于： 内容 {{ message }} 组件属性 或者 v-bind view v-bind:id=\"dynamicId\" component 动态渲染组件 component接受两个属性 属性名 说明 is 接受一个计算属性作为动态渲染的标签名 shrinkComponents 接受 usingComponents 中的key值组成的字符串作为动态组件选择的范围 组件改变 class Index { data = { dataComp:'comp', } computed ={ currentComp(){ return this.dataComp === 'comp' ? 'comp1' : 'comp'; } } methods = { handleElementClick (a,b) { console.log('handleElementClick',arguments,a,b) this.dataComp = (this.dataComp === 'comp' ? 'comp1' : 'comp') } } } export default new Index(); { \"base\": { \"usingComponents\": { \"comp\":\"./comp\", \"comp1\":\"./comp1\", \"comp2\":\"./comp2\", \"comp3\":\"./comp3\", } }, \"wx\": { \"navigationBarTitleText\": \"index\", \"backgroundTextStyle\": \"dark\", \"backgroundColor\": \"#E2E2E2\" } } v-model 应用于表单元素 message:{{message}} class Comp { data = { message:'default-value' } } export default new Comp(); { \"base\": {} } 应用于父子组件之间 父组件 c-model的在组件上的使用 组件使其改变{{modelValueTest2}} class Index { data = { currentComp:'comp1', modelValueTest2:'sss' } methods = { handleClick(){ this.currentComp = (this.currentComp === 'comp1' ) ? 'comp1':'comp2' } } } export default new Index(); .scroller-wrap { display: flex; flex-direction: column; align-items: center; } { \"base\": { \"usingComponents\": { \"comp1\":\"/components/comp1\", \"comp2\":\"/components/comp2\" } }, \"wx\": { \"navigationBarTitleText\": \"index\", \"backgroundTextStyle\": \"dark\", \"backgroundColor\": \"#E2E2E2\" } } 子组件 class Comp { props = { value:{ type:String, default:'default-value' } } methods = { handleInput(e){ console.log('input',e); debugger; this.$cmlEmit('input', { value:e.detail.value }) } } } export default new Comp(); { \"base\": {} } Javascript表达式 在模板内容中 {{ number + 1 }} {{ ok ? 'YES' : 'NO' }} {{ message.split('').reverse().join('') }} 算数运算 {{a + b}} + {{c}} + d class Index { data = { a: 1, b: 2, c: 3 } } export default new Index(); view中的内容为 3 + 3 + d。 字符串运算 {{\"hello\" + name}} 特别注意：模板中的字符串都要使用双引号，不能使用单引号。 数据路径运算 {{object.key}} {{array[0]}} class Index { data = { object: { key: 'Hello ' }, array: ['MINA'] } } export default new Index(); Bug & Tip 使用component语法的时候，为了提高微信端的渲染效率，建议加上shrinkComponents = \"comp1,comp2,...\",缩小动态渲染的查找范围，减少不必要的渲染开销； "},"view/condition-vue.html":{"url":"view/condition-vue.html","title":"条件渲染","keywords":"","body":"条件渲染 v-if 在框架中，使用 v-if=\"condition\" 来判断是否需要渲染该代码块： True 也可以用 v-else-if 和 v-else 来添加一个 else 块： 5\"> 1 2\"> 2 3 block v-if 因为 v-if 是一个控制属性，需要将它添加到一个标签上。如果要一次性判断多个组件标签，可以使用一个 标签将多个组件包装起来，并在上边使用 v-if 控制属性。 view1 view2 注意：: 并不是一个组件，它仅仅是一个包装元素，不会在页面中做任何渲染，只接受控制属性。 Bug & Tip 不要与 c-if c-else-if c-else混用 "},"view/iterator-vue.html":{"url":"view/iterator-vue.html","title":"列表渲染","keywords":"","body":"列表渲染 v-for 在组件上使用 v-for 控制属性绑定一个数组，即可使用数组中各项的数据重复渲染该组件。 {{index}}: {{item.message}} {{index}}: {{item.message}} {{index}}: {{item.message}} block v-for 类似 block v-if，也可以将 v-for 用在标签上，以渲染一个包含多节点的结构块。例如： {{index}}: {{item}} :key 1.如果 :key=\"item.id\"，那么就是vue中正常的语法。 2.如果 :key=\"item\",那么在微信端会被渲染成 wx:key=\"this\"; 保留关键字 this 代表在 for 循环中的 item 本身，这种表示需要 item 本身是一个唯一的字符串或者数字，如： 当数据改变触发渲染层重新渲染的时候，会校正带有 key 的组件，框架会确保他们被重新排序，而不是重新创建，以确保使组件保持自身的状态，并且提高列表渲染时的效率。 Bug & Tip 不要与c-for c-for-index c-for-item c-key这些语法混用 vue的v-for相关语法都可以使用，但是需要注意一点就是只支持数组形式的被遍历值 "},"view/event-vue.html":{"url":"view/event-vue.html","title":"事件","keywords":"","body":"事件 Chameleon 支持一些基础的事件，保障各端效果一致运行。如果你想要使用某个端特定的事件，请从业务出发使用 组件多态或者接口多态差异化实现功能。 主要扩展了事件的绑定：加强了符合vue语法的事件绑定； 事件绑定 主要增强了可以通过 v-on @这种形式去绑定事件； Click me! class Index { data = {} methods = { tapName() { console.log(e); } } } export default new Index(); 事件类型 事件类型列表： 类型 触发条件 touchstart 手指触摸动作开始 touchmove 手指触摸后移动 touchend 手指触摸动作结束 tap 手指触摸后马上离开 事件对象 当组件触发事件时，逻辑层绑定该事件的处理函数会收到一个事件对象。chameleon将事件绑定做了一层代理，将各平台的事件对象做统一，统一后的事件对象有如下属性： 名称 类型 说明 type String 事件类型 timeStamp Number 页面打开到触发事件所经过的毫秒数 target Object 触发事件的目标元素 且 target = {id,dateset} currentTarget Object 绑定事件的目标元素 且 currentTarget = {id,dataset} changedTouches Array 触摸事件中的属性，当前变化的触摸点信息的数组 且 changedTouches = [{ identifier, pageX, pageY, clientX, clientY }] detail Object 自定义事件所携带的数据。 通过$cmlEmit方法触发自定义事件，可以传递自定义数据即detail。具体下面自定义事件 _originEvent Object chameleon对各平台的事件对象进行统一，会把原始的事件对象放到_originEvent属性中，当需要特殊处理的可以进行访问。 target && currentTarget 属性 类型 说明 id String 事件源组件的id dataset Object 事件源组件上由data-开头的自定义属性的集合 dataset 在组件中可以定义数据，这些数据将会通过事件传递给 SERVICE。 书写方式： 以data-开头，多个单词由连字符-链接，不能有大写(大写会自动转成小写)如data-element-type，最终在 event.currentTarget.dataset 中会将连字符转成驼峰elementType。 DataSet Test class Index { methods = { bindViewTap:function(event){ event.currentTarget.dataset.alphaBeta === 1 // - 会转为驼峰写法 event.currentTarget.dataset.alphabeta === 2 // 大写会转为小写 } } } export default new Index(); changedTouches 事件属性 数组中的对象有如下属性： 属性 类型 说明 identifier Number 触摸点的标识符 pageXpageY Number 距离文档左上角的距离，文档的左上角为原点，横向为X轴，纵向为Y轴 clientXclientY Number 距离页面可显示区域（屏幕除去导航条）左上角距离，横向为X轴，纵向为Y轴 自定义事件 自定义事件用于父子组件之间的通信，父组件给子组件绑定自定义事件，子组件内部触发该事件。规定事件名称不能存在大写字母触发事件的方法是调用this.$cmlEmit(事件名称,detail对象)。 注意：自定义事件名称不支持click、scroll 例如： 子组件 yyl-com 触发自定义事件 class Index { data = {} method = { triggerCustomEvent(e) { this.$cmlEmit('customevent', { company: 'didi', age: 18 }) } } } export default new Index(); 父组件 class Index { data = {} method = { customEventHandler(e) { console.log(e) } } } export default new Index(); 当点击yyl-com组件的按钮时，父组件中的customEventHandler方法中打印的e对象如下： { type: \"customevent\", detail: { company: \"didi\", age: 18 } } 支持的语法 事件绑定支持以下几种形式（在内联语句中，$event代表事件对象） 触发元素点击事件 触发元素点击事件（1,2,3） 触发元素点击事件（） 针对以上写法返回的事件对象如下： 写法(1)调用事件函数输出如下 'handleElementTap' [e] 写法(2)调用事件函数输出如下 'handleElementTap' [1,2,3,'messagetestEvent',e] 写法(3)调用事件函数输出如下 'handleElementTap' [] Bug & Tips 不支持的语法 注意，事件绑定不支持直接传入一个表达式，和绑定多个内联执行函数比如 "},"view/directive-vue.html":{"url":"view/directive-vue.html","title":"指令","keywords":"","body":"指令 v-if 根据表达式的真假值条件渲染元素 根据v-if的真假结果决定是否渲染 v-else 不需要表达式 限制：前一个兄弟元素必须有 v-if 或者 v-else-if 用法 0.5\"> Now you see me Now you don't v-else-if 限制：前一个兄弟元素必须有 v-if 或者 v-else-if A B C Not A/B/C v-for {{idx}}: {{itemName.message}} v-model 父组件 v-model的使用 {{modelValueTest}} 组件使其改变{{modelValueTest2}} 子组件 methods = { handleInput(e){ console.log('input',e); this.$cmlEmit('input', { value: Date.now() }) } } } v-text 不支持组件的v-text v-show 测试元素c-show 组件v-show 使用v-show的元素不支持\b同时有 style 属性 elementShow是来自data或者computed中的key值，或者 true/false "},"view/css-vue.html":{"url":"view/css-vue.html","title":"样式语法规范","keywords":"","body":"样式语法 class属性 如果使用class语法，支持如下写法 fafafa fafafa 简单数据绑定 class数据绑定 class Index { data() { return { prefix: 'cls' } } } export default new Index(); 三元运算符 或者将其放入计算属性 class Index { computed = { itemClass() { return open ? 'cls1 cls2' : 'cls3 cls4'; } } } export default new Index(); 数组语法： dataClassArr class Index { computed = { computedClassArr() { return ['cls-a', 'cls-b']; } } } export default new Index(); style语法 如果使用style语法支持如下写法，style不支持多个style,即style :style同时写 fafafa fafafa class Index { data = { inlineStyle: 'border: 1px solid red;' } computed = { computedString() { return this.$cmlStyle(inlineStyle) } } } export default new Index(); "},"view/base_component.html":{"url":"view/base_component.html","title":"基础组件","keywords":"","body":"基础组件 框架为开发者提供了一系列基础组件，开发者可以通过组合这些基础组件进行快速开发。详细介绍请参考组件文档。 什么是组件： 组件是视图层的基本组成单元。 组件自带一些功能与微信风格一致的样式。 一个组件通常包括 开始标签 和 结束标签，属性 用来修饰这个组件，内容 在两个标签之内。Content goes here ... 注意：所有组件属性都是小写，以连字符-连接。 属性类型 类型 描述 注解 String 字符串 `\"string\"` Number 数字 `1, 1.5` Boolean 布尔值 `true，false` Array 数组 `[1, 'string']` Object 对象 `{key: value}` EventHandler 事件处理函数名 `handlerName`是组件中定义的事件处理函数名 公共属性 所有组件都有以下属性 属性名 类型 描述 注解 id String 组件唯一标示 保证整个页面唯一 class String 组件样式类名 在cmss中定义的样式类 style String 组件内联样式 可动态设置内联样式 c-bind EventHandler 组件事件 特殊属性 chameleon提供了内置组件及扩展组件，根据组件特殊性几乎每个组件都有自己的特殊属性，详细属性请查看组件文档。 "},"logic/logic.html":{"url":"logic/logic.html","title":"逻辑层","keywords":"","body":"逻辑层 逻辑层负责反馈用户对界面操作的处理中心。 逻辑层是终端开发的“灵魂”。 响应式数据绑定系统 当做数据修改的时候，只需要在逻辑层修改数据，视图层就会做相应的更新。 通过这个简单的例子来看： Hello {{name}}! Click me! class Index { data = { name: 'Chameleon' } methods = { changeName: function(e) { // sent data change to view this.name = 'CML'; } } }; export default new Index(); 框架首先将逻辑层数据中的 name 与视图层的 name 进行了绑定，所以打开页面的时候会显示 Hello Chameleon!； 当点击按钮的时候，视图层会发送 changeName 的事件给逻辑层，逻辑层找到并执行对应的事件处理函数； 回调函数触发后，逻辑层执行数据赋值的操作，将 data 中的 name 从 Chameleon 变为 CML，因为该数据和视图层已经绑定了，从而视图层会自动改变为 Hello CML!。 生命周期 每个 Chameleon 实例在被创建时都要经过一系列的初始化过程——例如，需要设置数据监听、编译模板、将实例挂载到 \b节点 并在数据变化时更新 \b节点 等。同时在这个过程中也会运行一些叫做生命周期钩子的函数，这给开发者在不同阶段添加自己的代码的机会。 计算属性 computed 对于模板内任何复杂逻辑，你都应当使用计算属性 侦听属性 watch 提供了一种更通用的方式来观察和响应实例上的数据变动 \b数据管理 \b利用这种数据管理模式在组件外部集中管理状态，可方便构建一个中大型单页应用 "},"logic/lifecycle.html":{"url":"logic/lifecycle.html","title":"生命周期","keywords":"","body":"生命周期 chameleon 为组件和 页面 提供了一系列生命周期事件，保障应用有序执行。 如果你想使用某个端特定的生命周期，请从业务出发使用 接口多态 接收特定的生命周期事件回调。 钩子 执行时机 详细 beforeCreate 实例初始化之后，数据和方法挂在到实例之前 一个页面只会返回一次 在该生命周期回调函数中会返回传入当前页面的参数对象 created 数据及方法挂载完成 beforeMount 开始挂载已经编译完成的cml到对应的节点时 mounted cml模板编译完成,且渲染到dom中完成 beforeDestroy 实例销毁之前 destroyed 实例销毁后 生命周期回调函数 beforeCreate(Object res) 参数说明 名称 类型 说明 res Object 在该生命周期回调函数中会 返回对象res: res = { query } query 是打开当前页面路径中的参数 钩子示例 class Index { beforeCreate(res) { // data数据挂载到this根节点上之前，以及methods所有方法挂载到实例根节点之前 console.log('App beforeCreate: 打开当前页面路径中的参数是 ', res.query) } created() { // data,methods里面的这些events挂载完成 console.log('App created') } beforeMount() { // 开始挂载已经编译完成的cml到对应的节点时 console.log('App beforeMount') } mounted() { // cml模板编译完成,且渲染到dom中完成,在整个生命周期中只执行一次 console.log('App mounted') } beforeDestroy() { // 实例销毁前 console.log('App beforeDestroy') } destroyed() { // 实例销毁后 console.log('App destroyed') } }; export default new Index(); "},"logic/computed.html":{"url":"logic/computed.html","title":"计算属性 computed","keywords":"","body":"计算属性 computed 示例 Original message: \"{{ message }}\" Computed reversed message: \"{{ reversedMessage }}\" class Index { data = { message: 'Hello' } computed = { // 计算属性的 getter reversedMessage: function () { return this.message.split('').reverse().join('') } } }; export default new Index(); 结果： Original message: \"Hello\" Computed reversed message: \"olleH\" 这里我们声明了一个计算属性 reversedMessage。 我们提供的函数将用作属性 reversedMessage 的 getter 函数，当 message 发生改变时，reversedMessage 也会更新 "},"logic/watch.html":{"url":"logic/watch.html","title":"侦听属性 watch","keywords":"","body":"侦听属性 watch 示例 fullName is : \"{{ fullName }}\" class Index { data = { firstName: 'Foo', lastName: 'Bar', fullName: 'Foo Bar' } watch = { firstName: function (newV, oldV) { this.fullName = newV + ' ' + this.lastName }, lastName: function (newV, oldV) { this.fullName = this.firstName + ' ' + newV } } }; export default new Index(); 除了 watch 选项之外，您还可以使用命令式的 this.$watch API。 但是，上面代码是命令式且重复的。将它与计算属性的版本进行比较： class Index { data = { firstName: 'Foo', lastName: 'Bar' } computed = { fullName: function () { return this.firstName + ' ' + this.lastName } } } 所以，不要滥用 watch ~ "},"logic/API.html":{"url":"logic/API.html","title":"API","keywords":"","body":"API chameleon 框架提供了丰富的多态接口，可以调起各端提供的原生能力，如系统信息、元素节点信息、动画效果、本地存储、网络请求、地理位置等。请参考 API 文档。 代码示例 import cml from 'chameleon-api' cml.showToast({ message: 'Hello world!', duration: 1000 }) 通常，在 chameleon API 有以下几种类型： 通用 API 大多数 API 都是异步 API，如 cml.get 等。这类 API 接口通常都接受一个 Object 类型的参数，返回 Promise ，对应请求成功和失败回调，支持 then 链式调用。 代码示例 cml.get({ url: 'https://cml.com/api/user/1' }).then(res => { cml.showToast({ message: JSON.stringify(res), duration: 2000 }) }, err => { cml.showToast({ message: JSON.stringify(err), duration: 2000 }) }) 运行时相关 API 提供模块 导入\\导出 能力，详细介绍 代码示例 import a from 'a.js' export {a} 数据管理store API 提供多端应用集中式管理状态数据的能力 详细介绍 代码示例 // store.js import createStore from 'chameleon-store' const store = createStore({ state, mutations, actions, getters, modules }) export default store "},"logic/store.html":{"url":"logic/store.html","title":"数据管理","keywords":"","body":"数据管理 chameleon-store 提供集中管理数据的能力。 这是一个简单的例子： 目录结构 简单介绍 类似 Vuex 数据理念和语法规范，chameleon-store 主要有以下核心概念： state getters mutation action 子模块 通过 chameleon-store 创建的Store实例,有以下方法： ChameleonStore.createStore(options: Object): Object Store构造器。详细介绍 ChameleonStore.Store 实例方法 Store.commit(type: string, payload?: any) 提交 mutation。详细介绍 Store.dispatch(type: string, payload?: any) 分发 action。详细介绍 Store.mapState(map: Array | Object): Object 为组件创建计算属性以返回 store 中的状态。详细介绍 Store.mapGetters(map: Array | Object): Object 为组件创建计算属性以返回 getter 的返回值。详细介绍 Store.mapMutations(map: Array | Object): Object 创建组件方法提交 mutation。详细介绍 Store.mapActions(map: Array | Object): Object 创建组件方法分发 action。详细介绍 Store.registerModule(path: String, module: Module) 注册一个动态模块。详细介绍 "},"logic/store/start.html":{"url":"logic/store/start.html","title":"开始","keywords":"","body":"开始 “store”基本上就是一个容器，它包含着你的应用中大部分的状态 (state)。store 和单纯的全局对象有以下两点不同： store 的状态存储是响应式的。当 chameleon 组件从 store 中读取状态的时候，若 store 中的状态发生变化，那么相应的组件也会相应地得到高效更新。 你不能直接改变 store 中的状态。改变 store 中的状态的唯一途径就是显式地提交 (commit) mutation。 最简单的store 创建 store，并且提供一个初始 state 对象和一些 mutation： import createStore from 'chameleon-store' const store = createStore({ state: { count: 0 }, mutations: { increment (state) { state.count++ } } }) export default store 通过 store.state 来获取状态对象，以及通过 store.commit 方法触发状态变更： store.commit('increment') console.log(store.state.count) // -> 1 再次强调，我们通过提交 mutation 的方式，而非直接改变 store.state.count，是因为我们想要更明确地追踪到状态的变化。这个简单的约定能够让你的意图更加明显，这样你在阅读代码的时候能更容易地解读应用内部的状态改变。此外，这样也让我们有机会去实现一些能记录每次状态改变，保存状态快照的调试工具。有了它，我们甚至可以实现如时间穿梭般的调试体验。 由于 store 中的状态是响应式的，在组件中调用 store 中的状态简单到仅需要在计算属性中返回即可。触发变化也仅仅是在组件的 methods 中提交 mutation。 接下来，我们将会更深入地探讨一些核心概念。让我们先从 State 概念开始。 "},"logic/store/state.html":{"url":"logic/store/state.html","title":"state","keywords":"","body":"State 单一状态树 chameleon-store 用一个对象就包含了全部的应用层级状态。单一状态树让我们能够直接地定位任一特定的状态片段，在调试的过程中也能轻易地取得整个当前应用状态的快照。 单状态树和模块化并不冲突——在后面的章节里我们会讨论如何将状态和状态变更事件分布到各个子模块中。 在 chameleon 组件中获得 store 状态 那么我们如何在 chameleon 组件中展示状态呢？由于 chameleon内置的store 的状态存储是响应式的，从 store 实例中读取状态最简单的方法就是在计算属性中返回某个状态： import store from '../store' // 创建一个 Counter 组件 const Counter = { computed: { count () { return store.state.count } } } 每当 store.state.count 变化的时候, 都会重新求取计算属性，并且触发更新相关联的 DOM。 mapState辅助函数 当一个组件需要获取多个状态时候，将这些状态都声明为计算属性会有些重复和冗余。为了解决这个问题，我们可以使用 mapState 辅助函数帮助我们生成计算属性，让你少按几次键： // 在单独构建的版本中辅助函数为 chameleon内置的store.mapState import store from '../store' class Index { // ... computed = store.mapState({ // 箭头函数可使代码更简练 count: state => state.count, // 传字符串参数 'count' 等同于 `state => state.count` countAlias: 'count', // 为了能够使用 `this` 获取局部状态，必须使用常规函数 countPlusLocalState (state) { return state.count + this.localCount } }) } export default new Index(); 当映射的计算属性的名称与 state 的子节点名称相同时，我们也可以给 mapState 传一个字符串数组。 import store from '../store'; class Index { computed = store.mapState([ // 映射 this.count 为 store.state.count 'count' ]) } export default new Index(); 对象展开运算符 mapState 函数返回的是一个对象。我们如何将它与局部计算属性混合使用呢？通常，我们需要使用一个工具函数将多个对象合并为一个，以使我们可以将最终对象传给 computed 属性。但是自从有了对象展开运算符（现处于 ECMASCript 提案 stage-3 阶段），我们可以极大地简化写法： import store from '../store' class Index { computed = { localComputed() { /* ... */ }, // 使用对象展开运算符将此对象混入到外部对象中 ...store.mapState({ // ... }) } } export default new Index(); 组件仍然保有局部状态 使用 chameleon内置的store 并不意味着你需要将所有的状态放入store。虽然将所有的状态放到 chameleon内置的store 会使状态变化更显式和易调试，但也会使代码变得冗长和不直观。如果有些状态严格属于单个组件，最好还是作为组件的局部状态。你应该根据你的应用开发需要进行权衡和确定。 "},"logic/store/getters.html":{"url":"logic/store/getters.html","title":"getters","keywords":"","body":"Getter 有时候我们需要从 store 中的 state 中派生出一些状态，例如对列表进行过滤并计数： computed: { doneTodosCount () { return store.state.todos.filter(todo => todo.done).length } } 如果有多个组件需要用到此属性，我们要么复制这个函数，或者抽取到一个共享函数然后在多处导入它——无论哪种方式都不是很理想。 chameleon内置store 允许我们在 store 中定义“getter”（可以认为是 store 的计算属性）。就像计算属性一样，getter 的返回值会根据它的依赖被缓存起来，且只有当它的依赖值发生了改变才会被重新计算。 Getter 接受 state 作为其第一个参数： import createStore from 'chameleon-store' const store = createStore({ state: { todos: [ { id: 1, text: '...', done: true }, { id: 2, text: '...', done: false } ] }, getters: { doneTodos: state => { return state.todos.filter(todo => todo.done) } } }) export default store Getter 会暴露为 store.getters 对象： store.getters.doneTodos // -> [{ id: 1, text: '...', done: true }] Getter 也可以接受其他 getter 作为第二个参数, rootState作为第三个参数： getters: { // ... doneTodosCount: (state, getters, rootState) => { return getters.doneTodos.length } } store.getters.doneTodosCount // -> 1 我们可以很容易地在任何组件中使用它： computed: { doneTodosCount () { return store.getters.doneTodosCount } } 你也可以通过让 getter 返回一个函数，来实现给 getter 传参。在你对 store 里的数组进行查询时非常有用。 getters: { // ... getTodoById: (state) => (id) => { return state.todos.find(todo => todo.id === id) } } store.getters.getTodoById(2) // -> { id: 2, text: '...', done: false } mapGetters辅助函数 mapGetters 辅助函数仅仅是将 store 中的 getter 映射到局部计算属性： import store from '../store' class Index { // ... computed = { // 使用对象展开运算符将 getter 混入 computed 对象中 ...store.mapGetters([ 'doneTodosCount', 'anotherGetter', // ... ]) } }; export default new Index(); 如果你想将一个 getter 属性另取一个名字，使用对象形式： store.mapGetters({ // 映射 `this.doneCount` 为 `store.getters.doneTodosCount` doneCount: 'doneTodosCount' }) "},"logic/store/mutation.html":{"url":"logic/store/mutation.html","title":"mutation","keywords":"","body":"Mutation 更改 chameleon内置store 的 store 中的状态的唯一方法是提交 mutation。chameleon内置store 中的 mutation 非常类似于事件：每个 mutation 都有一个字符串的 事件类型 (type) 和 一个 回调函数 (handler)。这个回调函数就是我们实际进行状态更改的地方，并且它会接受 state 作为第一个参数： import createStore from 'chameleon-store' const store = createStore({ state: { count: 1 }, mutations: { increment (state) { // 变更状态 state.count++ } } }) export default store 你不能直接调用一个 mutation handler。这个选项更像是事件注册：“当触发一个类型为 increment 的 mutation 时，调用此函数。”要唤醒一个 mutation handler，你需要以相应的 type 调用 store.commit 方法： store.commit('increment') 提交载荷（Payload） 你可以向 store.commit 传入额外的参数，即 mutation 的 载荷（payload）： // ... mutations: { increment (state, n) { state.count += n } } store.commit('increment', 10) 在大多数情况下，载荷应该是一个对象，这样可以包含多个字段并且记录的 mutation 会更易读： // ... mutations: { increment (state, payload) { state.count += payload.amount } } store.commit('increment', { amount: 10 }) Mutation 需遵守 Chameleon 的响应规则 既然 chameleon内置store 中的状态是响应式的，那么当我们变更状态时，监视状态的 Chameleon 组件也会自动更新。这也意味着 chameleon内置store 中的 mutation 也需要与使用 Chameleon 一样遵守一些注意事项： 最好提前在你的 store 中初始化好所有所需属性。 当需要在对象上添加新属性时，你应该 以新对象替换老对象。例如，利用 stage-3 的对象展开运算符我们可以这样写： state.obj = { ...state.obj, newProp: 123 } 使用常量替代 Mutation 事件类型 使用常量替代 mutation 事件类型在各种 Flux 实现中是很常见的模式。这样可以使 linter 之类的工具发挥作用，同时把这些常量放在单独的文件中可以让你的代码合作者对整个 app 包含的 mutation 一目了然： // mutation-types.js export const SOME_MUTATION = 'SOME_MUTATION' // store.js import createStore from 'chameleon-store' import { SOME_MUTATION } from './mutation-types' const store = createStore({ state: { ... }, mutations: { // 我们可以使用 ES2015 风格的计算属性命名功能来使用一个常量作为函数名 [SOME_MUTATION] (state) { // mutate state } } }) export default store 用不用常量取决于你——在需要多人协作的大型项目中，这会很有帮助。但如果你不喜欢，你完全可以不这样做。 Mutation 必须是同步函数 一条重要的原则就是要记住 mutation 必须是同步函数。为什么？请参考下面的例子： mutations: { someMutation (state) { api.callAsyncMethod(() => { state.count++ }) } } 现在想象，我们正在 debug 一个 app 并且观察 devtool 中的 mutation 日志。每一条 mutation 被记录，devtools 都需要捕捉到前一状态和后一状态的快照。然而，在上面的例子中 mutation 中的异步函数中的回调让这不可能完成：因为当 mutation 触发的时候，回调函数还没有被调用，devtools 不知道什么时候回调函数实际上被调用——实质上任何在回调函数中进行的状态的改变都是不可追踪的。 在组件中提交Mutation 你可以在组件中使用 store.commit('xxx') 提交 mutation，或者使用 mapMutations 辅助函数将组件中的 methods 映射为 store.commit 调用。 import store from '../store' createComponent({ // ... methods: { ...store.mapMutations([ 'increment', // 将 `this.increment()` 映射为 `store.commit('increment')` // `mapMutations` 也支持载荷： 'incrementBy' // 将 `this.incrementBy(amount)` 映射为 `store.commit('incrementBy', amount)` ]), ...store.mapMutations({ add: 'increment' // 将 `this.add()` 映射为 `store.commit('increment')` }) } }) 下一步：Action 在 mutation 中混合异步调用会导致你的程序很难调试。例如，当你调用了两个包含异步回调的 mutation 来改变状态，你怎么知道什么时候回调和哪个先回调呢？这就是为什么我们要区分这两个概念。在 chameleon内置store 中，mutation 都是同步事务： store.commit('increment') // 任何由 \"increment\" 导致的状态变更都应该在此刻完成。 为了处理异步操作，让我们来看一看 Action。 "},"logic/store/action.html":{"url":"logic/store/action.html","title":"action","keywords":"","body":"Action Action 类似于 mutation，不同在于： Action 提交的是 mutation，而不是直接变更状态。 Action 可以包含任意异步操作。 让我们来注册一个简单的 action： import createStore from 'chameleon-store' const store = createStore({ state: { count: 0 }, mutations: { increment (state) { state.count++ } }, actions: { increment (context) { context.commit('increment') }, increment2({rootState, state, getters, dispatch, commit}) { } } }) export default store Action 函数接受一个 context 对象，因此你可以调用 context.commit 提交一个 mutation，或者通过 context.rootState、context.state 和 context.getters 来获取全局state、局部state 和 全局 getters。 实践中，我们会经常用到 ES2015 的 参数解构 来简化代码（特别是我们需要调用 commit 很多次的时候）： actions: { increment ({ commit }) { commit('increment') } } 分发 Action Action 通过 store.dispatch 方法触发： store.dispatch('increment') 乍一眼看上去感觉多此一举，我们直接分发 mutation 岂不更方便？实际上并非如此，还记得 mutation 必须同步执行这个限制么？Action 就不受约束！我们可以在 action 内部执行异步操作： actions: { incrementAsync ({ commit }) { setTimeout(() => { commit('increment') }, 1000) } } Actions 支持同样的载荷方式进行分发： // 以载荷形式分发 store.dispatch('incrementAsync', { amount: 10 }) 来看一个更加实际的购物车示例，涉及到调用异步 API 和分发多重 mutation： actions: { checkout ({ commit, state }, products) { // 把当前购物车的物品备份起来 const savedCartItems = [...state.cart.added] // 发出结账请求，然后乐观地清空购物车 commit(types.CHECKOUT_REQUEST) // 购物 API 接受一个成功回调和一个失败回调 shop.buyProducts( products, // 成功操作 () => commit(types.CHECKOUT_SUCCESS), // 失败操作 () => commit(types.CHECKOUT_FAILURE, savedCartItems) ) } } 注意我们正在进行一系列的异步操作，并且通过提交 mutation 来记录 action 产生的副作用（即状态变更）。 在组件中分发Action 你在组件中使用 store.dispatch('xxx') 分发 action，或者使用 mapActions 辅助函数将组件的 methods 映射为 store.dispatch 调用： import store from '../store' class Index { methods = { ...store.mapActions([ 'increment', // 将 `this.increment()` 映射为 `store.dispatch('increment')` // `mapActions` 也支持载荷： 'incrementBy' // 将 `this.incrementBy(amount)` 映射为 `store.dispatch('incrementBy', amount)` ]), ...store.mapActions({ add: 'increment' // 将 `this.add()` 映射为 `store.dispatch('increment')` }) } }; export default new Index(); 组合 Action Action 通常是异步的，那么如何知道 action 什么时候结束呢？更重要的是，我们如何才能组合多个 action，以处理更加复杂的异步流程？ 首先，你需要明白 store.dispatch 可以处理被触发的 action 的处理函数返回的 Promise，并且 store.dispatch 仍旧返回 Promise： actions: { actionA ({ commit }) { return new Promise((resolve, reject) => { setTimeout(() => { commit('someMutation') resolve() }, 1000) }) } } 现在你可以： store.dispatch('actionA').then(() => { // ... }) 在另外一个 action 中也可以： actions: { // ... actionB ({ dispatch, commit }) { return dispatch('actionA').then(() => { commit('someOtherMutation') }) } } 最后，如果我们利用 async / await，我们可以如下组合 action： // 假设 getData() 和 getOtherData() 返回的是 Promise actions: { async actionA ({ commit }) { commit('gotData', await getData()) }, async actionB ({ dispatch, commit }) { await dispatch('actionA') // 等待 actionA 完成 commit('gotOtherData', await getOtherData()) } } 一个 store.dispatch 在不同模块中可以触发多个 action 函数。在这种情况下，只有当所有触发函数完成后，返回的 Promise 才会执行。 "},"logic/store/module.html":{"url":"logic/store/module.html","title":"子模块","keywords":"","body":"Module 当应用变得非常复杂时，store 对象就有可能变得相当臃肿。 为了解决以上问题，chameleon内置store 允许我们将 store 分割成模块（module）。每个模块拥有自己的 state、mutation、action、getter、甚至是嵌套子模块——从上至下进行同样方式的分割： import createStore from 'chameleon-store' const moduleA = { state: { ... }, mutations: { ... }, actions: { ... }, getters: { ... } } const moduleB = { state: { ... }, mutations: { ... }, actions: { ... } } const store = createStore({ modules: { a: moduleA, b: moduleB } }) store.state.a // -> moduleA 的状态 store.state.b // -> moduleB 的状态 模块的局部状态 对于模块内部的 mutation 和 getter，接收的第一个参数是模块的局部状态对象。 const moduleA = { state: { count: 0 }, mutations: { increment (state) { // 这里的 `state` 对象是模块的局部状态 state.count++ } }, getters: { doubleCount (state) { return state.count * 2 } } } 同样，对于模块内部的 action，局部状态通过 context.state 暴露出来，根节点状态则为 context.rootState： const moduleA = { // ... actions: { incrementIfOddOnRootSum ({ state, commit, rootState }) { if ((state.count + rootState.count) % 2 === 1) { commit('increment') } } } } 对于模块内部的 getter，根节点状态会作为第三个参数暴露出来： const moduleA = { // ... getters: { sumWithRootCount (state, getters, rootState) { return state.count + rootState.count } } } 模块动态注册 在 store 创建之后，你可以使用 store.registerModule 方法注册模块： // 注册模块 `myModule` store.registerModule('myModule', { // ... }) 之后就可以通过 store.state.myModule 访问模块的状态。 "},"logic/store/structure.html":{"url":"logic/store/structure.html","title":"目录结构","keywords":"","body":"项目结构 Chameleon内置store 并不限制你的代码结构。但是，它规定了一些需要遵守的规则： 应用层级的状态应该集中到单个 store 对象中。 提交 mutation 是更改状态的唯一方法，并且这个过程是同步的。 异步逻辑都应该封装到 action 里面。 只要你遵守以上规则，如何组织代码随你便。如果你的 store 文件太大，只需将 action、mutation 和 getter 分割到单独的文件。 对于大型应用，我们会希望把 Chameleon 相关代码分割到模块中。下面是项目结构示例： ├── app ├── assets ├── pages # 页面 │ └── ... ├── components # 组件 │ ├── c-todoitem │ └── ... └── store ├── action-types.js # 定义 actions 的类型 ├── actions.js # 根级别的 actions ├── getter-types.js # 定义 getters 的类型 ├── getters.js # 根级别的 getters ├── index.js # 我们组装模块并导出 store 的地方 ├── mutation-types.js # 定义 mutations 的类型 ├── mutations.js # 根级别的 mutation ├── state.js # 组件初始状态数据 └── modules # 子模块 ├── ... "},"framework/settings.html":{"url":"framework/settings.html","title":"配置","keywords":"","body":"配置 针对项目、组件、路由等的特定配置，以满足各种方式的需求。 "},"framework/json.html":{"url":"framework/json.html","title":"组件配置","keywords":"","body":"组件配置 组件的配置以json对象的格式配置在.cml文件中，结构如下： { \"base\":{ \"usingComponents\": { \"navi\": \"/components/navi/navi\", \"c-cell\": \"/components/c-cell/c-cell\", \"c-list\": \"/components/c-list/c-list\", \"navi-npm\": \"cml-test-ui/navi/navi\" } }, \"wx\": { \"navigationBarTitleText\": \"index\", \"backgroundTextStyle\": \"dark\", \"backgroundColor\": \"#E2E2E2\", \"component\": true } \"web\": { }, \"weex\": { } } base 对象为各端共用的配置对象。 wx、web、weex分别对应三端特有的配置对象，base的配置会应用到每一端的配置，内部做的merge。 usingComponents字段是目前最重要的配置，各端都会使用，小程序规定页面的json文件中配置使用到的组件。web和weex端的构建时也是根据该字段去找到相应的组件进行自动化的注册。所以用到组件必须进行配置 usingComponents中组件的引用地址。 支持引用src和node_modules下的组件，地址禁止包含后缀扩展名： src下可以写相对路径，也可以写相对于src的绝对路径，例如/components/**, node_modules下的组件，不需要写node_modules，直接从npm的包名称开始写例如cml-test-ui/navi/navi。 引用的组件类型支持： .cml扩展名跨端组件 .vue扩展名的vue、weex组件，仅在多态组件可用 小程序组件文件夹路径，仅在多态组件可用 .js扩展名的react组件，仅在多态组件可用 \b小程序端所需要的一些配置，写在各自的特有配置对象中 "},"framework/router.html":{"url":"framework/router.html","title":"路由配置","keywords":"","body":"路由管理 chameleon项目内置了一套各端统一的路由管理方式。 路由配置文件 src/router.config.json是路由的配置文件,内容如下： { \"mode\": \"history\", \"domain\": \"https://www.chameleon.com\", \"routes\":[ { \"url\": \"/cml/h5/index\", \"path\": \"/pages/index/index\", \"mock\": \"index.php\" } ] } mode 为web端路由模式，分为hash或history。 domain 为web端地址的域名。 routes 为路由配置 path为路由对应的cml文件的路径,以src目录下开始的绝对路径，以/开头。 url为web端的访问路径 mock为该路由对应的mock文件(仅模拟模板下发需要) 小程序端路由 在微信小程序端，构建时会将router.config.json的内容，插入到app.json的pages字段，实现小程序端的路由。 使用路由场景 应用内路由 跨应用路由 "},"framework/config.html":{"url":"framework/config.html","title":"工程配置","keywords":"","body":"项目配置 本文档描述了项目配置的全部参数及使用方法。 配置文件 chameleon的构建过程是配置化的，项目的根目录下提供一个chameleon.config.js文件，在该文件中可以使用全局对象cml的api去操作配置对象。例如： // 设置静态资源的线上路径 const publicPath = '//www.static.chameleon.com/static'; // 设置api请求前缀 const apiPrefix = 'https://api.chameleon.com'; // 合并配置 cml.config.merge({ wx: { build: { apiPrefix } }, web: { dev: { hot: true, console: true }, build: { publicPath: `${publicPath}/web`, apiPrefix } }, weex: { build: { publicPath: `${publicPath}/weex`, apiPrefix } } }) 配置api cml.config.merge(obj) merge方式修改配置。 cml.config.assign(obj) assign方式修改配置 cml.config.get() 获取config配置 配置详解 下面就详细介绍配置中的功能。 web端页面文件\b类型 templateType, String 类型。该字段控制web端构建\b出的页面文件类型。 templateType: 'html' 构建出.html文件，纯前端模板 templateType: 'smarty' 构建出.tpl文件 例如： cml.config.merge({ templateType: 'html' }); web端页面文件名称 projectName, String 类型。 该字段控制web端构建\b出的模板文件名称，默认是当前项目的根目录文件夹名称。 例如： cml.config.merge({ projectName: '\btest_cml', templateType: 'html' }) web端构建出 test_cml.html文件 模板语法 templateLang, String 类型。chameleon的视图层支持两种模板语法，通过在template\b\b上的lang属性做区分，如果不写默认是cml语法。该字段控制init page 和init component\b 时生成的cml文件的template模板上的lang属性。例如： cml.config.merge({ templateLang: '\bcml' }); 支持端配置 platforms, Array[String]类型。 \b配置当前项目支持的\b端，该配置决定cml dev和cml build命令启动构建的端，决定cml init命令初始化多态接口和多态组件时只生成相应端代码。 例如： cml.config.merge({ platforms: ['web','wx'], }); cml dev和cml build只启动web和wx端的构建。 关闭某一端构建 devOffPlatform和buildOffPlatform, Array[String] 类型。 \b当我们执行cml dev 和 cml build 时会自动构建输出\b所有平台的代码，可以通过这两个字段控制不需要构建的平台，目前支持取值[\"web\",\"wx\",\"weex\"]。 例如： cml.config.merge({ devOffPlatform: ['wx'], buildOffPlatform: ['wx'] }); 语法检查 enableLinter, Boolean \b类型。 默认为 true，是否开启chameleon的语法检查，会在命令行提示语法错误。 多态校验控制 check, Object 类型。 chameleon提供了接口多态与组件多态的写法，同时为了保证代码的质量提供了多态校验的方法，可以通过check字段进行校验的控制。 check.enable, Boolean 类型。 控制是否开启多态校验，默认true。 check.enableTypes, Array[String] 类型。 \b可取值[\"Object\",\"Array\",\"Nullable\"],控制校验中是否可以定义直接定义Object和Array类型，和\b是否可以定义可为空类型,默认值为[]。 例如： cml.config.merge({ check: { enable: true, enableTypes: [\"Object\",\"Array\",\"Nullable\"] } }); 全局变量校验 enableGlobalCheck, Boolean 类型。默认是false,控制是否进行全局变量的检验。 例如： cml.config.merge({ enableGlobalCheck: true }); 全局变量校验白名单 globalCheckWhiteList, Array[String|RegExp] 类型。 chameleon内置了全局变量校验的功能 可以设置白名单不校验某些文件。以文件绝对路径进行匹配，可以是正则表达式径，也可以是字符串的endWiths。 例如： cml.config.merge({ globalCheckWhiteList: ['jquery.js',/node_modules/] }); 则所有以 jquery.js 结尾的文件以及 正则匹配 /node_modules/ 的不做校验； dev服务端口 devPort, Number 类型。 dev模式启动的web服务端口，默认是从8000开始寻找空闲端口，避免了启动多个项目时的端口冲突问题。如果想指定端口可以使用该参数进行配置。 例如： cml.config.merge({ devPort: 8080 }); 配置babel-loader不处理的文件 excludeBablePath, Array[String|RegExp] 类型。 const path = require('path'); cml.config.merge({ excludeBablePath:[/test-exclude/,path.resolve(__dirname,'./src/excludes')], }) 这个配置的结果会作为webpack模块配置中 Rule.exclude的值； cmss处理 cmss，Object类型。 仅用于web端。其中包含rem及scale属性，web端构建时默认将cpx\b转为rem，当不需要时转为rem时，将rem置为false，则scale参数生效，scale为像素缩放倍数，默认为1，会将cpx按照scale的设置进行缩放为px。例如： cml.config.merge({ cmss: { rem: false, scale: 0.5 } }); 该设置web端cpx不转为rem，而缩小1倍转为px，例如10cpx转为5px。 禁用基础样式 baseStyle， Object类型。 chameleon为了让各端样式统一，默认会在全局插入一些基础样式，如果开发者的跨端不需要这些基础样式，可以通过该参数进行设置。key值为端名称，value为Boolean值，是否插入\b基础样式。例如： cml.config.merge({ baseStyle: { web: false, wx: false, weex: false }, }); 该设置web、wx、weex端均不插入基础样式。 全局引用npm组件库 cmlComponents, Array[String] 类型。 当我们想把npm组件库中的组件全部自动引入，而不需要单独引入时，可以通过该字段配置npm包名称。例如 cml-ui是我们提供的一个npm组件库，可以进行如下配置： cml.config.merge({ cmlComponents: ['cml-ui'] }); npm组件库的package.json\b中的main字段可以指定路径，否则就会查找\bnpm包中的所有cml文件自动引入，自动引入的组件名称为cml文件名称。 构建结果信息 buildInfo, Object 类型。 buildInfo.wxAppId,String 类型。微信的appId。 当执行完cml build后会生成一个config.json\b文件，该文件存储构建后各平台的页面信息。可以通过这个json文件做页面的动态下发，页面降级等等。 例如： cml.config.merge({ buildInfo: { wxAppId: '123456' } }); cml build 后生成\b在dist/config.json { \"wx\": { \"appId\": \"123456\", \"path\": \"/pages/index/index\" }, \"web\": { \"url\": \"https://api.chameleon.com/cml/h5/index\" }, \"weex\": { \"url\": \"https://static.chameleon.com/pinche/hkcml/weex/hybridkits_pageone_e86b77ae05a015a3a546.js\", \"query\": { \"path\": \"/pages/index/index\" } } } config.json中微信小程序的appId是\b通过buildInfo配置生成，其他的页面信息是根据router.config.json中的配置生成。 例如： cml.config.merge({ enableLinter: false }); 构建入口与页面\b 默认的入口与页面集成在脚手架中，对于有特殊\b需求的开发者，chameleon提供了可以自定义web端构建入口与页面，weex端构建入口的功能。 entry, Object \b类型。 entry.template, String 类型。 页面文件的绝对路径。 entry.web, String 类型。 web端入口文件的\b绝对路径。 entry.weex, String 类型。 wewx端入口文件的\b绝对路径。 例如： var path = require('path'); cml.config.merge({ entry: { template: path.resolve('./src/index.html') web: path.resolve('./src/mian.web.js') weex: path.resolve('./src/main.weex.js') } }) 平台内配置 \b每一个平台的构建会需要不同的配置，所以针对每一个平台会有一个平台配置对象，平台配置对象中又有多个media配置对象，例如dev或者build的配置。\b下面讲述的配置项都是放在media对象中。例如： wx web weex是平台对象，里面的dev和build是media对象。 cml.config.merge({ wx: { dev: {}, build: {} }, web: { dev: {}, build: {} }, weex: { dev: {}, build: {} } }); 文件指纹 文件指纹是文件的唯一标识，以文件的内容生成hash值作为文件名称的一部分。在开启强缓存的情况下，如果文件的 URL 不发生变化，无法刷新浏览器缓存。文件指纹\b\b用于更新浏览器的缓存。小程序端不需要文件指纹。 默认图片资源\b开启hash，build模式开启hash。\b通过hash字段配置。 hash, Boolean 类型。 \b控制打包出的js和css文件是否带hash后缀，图片字体等静态资源自动带hash，其小程序端不支持hash参数。 例如： cml.config.merge({ web: { dev: { hash: true } } }) 下图为web端开启文件指纹的打包结果。 代码压缩 为了减少资源网络传输的大小，通过压缩器对 js、css、图片进行压缩是一直以来前端工程优化的选择。在chameleon中只需要\b配置minimize参数。 minimize, Boolean 类型。 \b\b控制打包出的文件是否进行压缩。 例如： cml.config.merge({ web: { dev: { minimize: true } } }); 资源发布路径 publicPath, String 类型。 \b\b控制代码中静态资源的引用路径，\b线上发布需要用到，media为dev时默认 小程序端是本地路径，web和weex端是当前dev服务的\b路径。 例如： cml.config.merge({ web: { build: { publicPath: \"http://www.chameleon.com/static\" } } }); 热更新与自动刷新 热更新与自动刷新都是提高本地开发效率的手段，当项目中的源代码发生改变时，\b能够自动的在页面看到改变，其中热更新不需要重新刷新预览的页面。目前只有web端的开发支持热更新，通过hot参数配置。 dev模式默认自动刷新，web端可以选择开启热更新。 hot, Boolean 类型。 控制是否开启热更新，只在web端生效，开启热更新时，css代码不会单独分离出来，如果进行线上js代理本地js调试问题时，请关闭热更新。 例如： cml.config.merge({ web: { dev: { hot: true } } }); 打包资源分析 analysis, Boolean类型。 控制是否\b打开webpack打包分析工具， 内部使用的webpack-bundle-analyzer插件。 例如： cml.config.merge({ web: { dev: { analysis: true } } }); 调试窗口 console, Boolean类型。 控制是否打开页面上的调试窗口，只在web端有效，方便在真机上进行调试。 例如： cml.config.merge({ web: { dev: { console: true } } }) \b\b内置变量 definePlugin, Object类型，内部使用webpack.DefinePlugin实现，定义运行时的内置变量。 例如： cml.config.merge({ web: { dev: { definePlugin: { 'process.env.TEST': JSON.stringify('CML_TEST') } } } }) \b\bapi请求前缀 apiPrefix, String类型。 这个配置与网络请求相关，在wx和weex项目中，ajax的请求不能像web端一样只写相对路径，而是要写带有域名的绝对路径，chameleon-api 这个基础库，提供了网络请求的api，get、post、request方法，该方法会在运行时将请求的相对路径上添加配置的apiPrefix。media是dev时 默认为当前dev服务的地址。 例如： chameleon.config.js // 设置api请求前缀 const apiPrefix = 'http://api.chameleon.com'; cml.config.merge({ wx: { dev: { apiPrefix: 'http://172.22.137.29:8000' }, build: { apiPrefix } } }) import cml from 'chameleon-api' class Index { methods = { sendGet() { cml.get({ url: '/api/driver/getList', data: { name: 'cml', age: 18 } }).then(res=>{ console.log(res) }).catch(e=>{ console.log(e) }) } } }; export default new Index(); 在执行cml wx dev命令构建的结果中，cml.get方法发送的请求是http://172.22.137.29:8000/api/driver/getList 在执行cml wx build命令构建的结果中，cml.get方法发送的请求是http://api.chameleon.com/api/driver/getList 模块标识类型 moduleIdType,String类型。 设置webpack打包模块的id类型。 number 顺序排列的数组下标。 hash 利用 webpack.HashedModuleIdsPlugin() 模块的id类型为模块内容的hash值。 name 利用webpack.NamedModulesPlugin() 模块的id类型为文件的路径。 chameleon 用于build模式，模块的id类型为模块内容的hash，并且最终文件的hash\b也经过优化处理，根据文件内容绝对hash值。 默认media为dev时 取值\b为name 方便开发调试， media为build时取值为chameleon 保证hash值由文件内容决定，更好的做缓存持久化。 例如： cml.config.merge({ web: { dev: { moduleIdType: \"number\" } } }) 自定义构建配置 如果我们需要多套构建配置，可以自定义一个media，比如设置weex.custom 对象，然后执行cml weex custom即可使用你设置的custom配置进行构建，但是不会启动dev服务和watch。 例如： cml.config.merge({ weex: { custom: { minimize: true, moduleIdType: \"number\" } } }) 组件导出配置 组件导出相关的配置请参见组件导出介绍。 修改webpack配置 在chameleon.config.js中可以通过api获取到构建之前的webpack配置并对其进行修改。使用方式： cml.utils.plugin('webpackConfig', function({ type, media, webpackConfig }, cb) { // cb函数用于设置修改后的配置 cb({ type, media, webpackConfig }); }); "},"api/api.html":{"url":"api/api.html","title":"API","keywords":"","body":"API chameleon 支持大量基础API，对外提供统一的接口，以模块的方式引入chameleon-api进行使用。 例如: import cml from 'chameleon-api' cml.showToast({ message: 'Hello world!', duration: 1000 }) 注意： 接口均以promise形式进行返回，所以你可以结合异步流程控制如async、await进行操作。 API模块为按需加载模块，可有效减少包体积。 \b\b失败回调的返回格式为{errMsg:string}，如果是自己扩展的方法也建议按照此结构进行构造。 你还可以利用接口多态来实现跨端的接口或差异化实现特定端接口。 "},"api/runtime/runtime.html":{"url":"api/runtime/runtime.html","title":"运行时相关","keywords":"","body":"runtime Module 加载接口 export&import @import "},"api/runtime/module.html":{"url":"api/runtime/module.html","title":"export&import","keywords":"","body":"export & import chameleon框架的编译时加载方案是在ES6的module能力基础上扩展的，主要由两个命令构成：export和import。 export 命令 export命令用于规定模块的对外接口。 一个模块就是一个独立的文件。该文件内部的所有变量，外部无法获取。如果你希望外部能够读取模块内部的某个变量，就必须使用export关键字输出该变量。下面是一个 JS 文件，里面使用export命令输出变量。 // profile.js const name = 'Mike'; const gender = 'male'; const age = 24; export {name, gender, age}; import 命令 import命令用于输入其他模块提供的功能。 使用export命令定义了模块的对外接口以后，通过import命令加载这些模块。 导入规范如下表所示： 当前文件后缀 仅限导入的类型 示例 .cml .js、.json import a from 'a.js'; import b from 'b.json'; *.[web|weex|wx].cml .interface、.js、.json import a from 'a.js'; import b from 'b.json'; import c from 'c.interface'; .js .interface、.js、.json import a from 'a.js'; import b from 'b.json'; import c from 'c.interface'; .interface .js、.json import a from 'a.js'; import b from 'b.json'; 如果没有加后缀名，会依次查找后缀为.interface, .js的文件 // 会依次查找 profile.interface profile.js import {name, gender, age} from './profile'; // 最后找到 profile.js function setName(human) { human.textContent = name + ' ' + gender + ' ' + age; } "},"api/runtime/@import.html":{"url":"api/runtime/@import.html","title":"@import","keywords":"","body":"@import 指定导入的外部样式表及目标媒体。支持导入.css、.less、.stylus类型文件。 该规则必须在样式表头部最先声明。并且其后的分号是必需的，如果省略了此分号，外部样式表将无法正确导入，并会生成错误信息。 @import './base.css'; @import './base.less'; @import './base.stylus'; "},"api/request.html":{"url":"api/request.html","title":"网络请求","keywords":"","body":"网络请求 get 发送get请求 参数 参数 类型 必需 默认值 说明 url String 是 网络请求地址，如果项目中配置了apiPrefix并且setting中的apiPrefix为true，则添加配置的前缀 data Object 否 要传的参数，会拼接在请求的url中 header Object 否 设置http请求的header resDataType String 否 json 设置response的数据类型, 为json时, 会尝试对返回值进行JSON.parse() setting Object 否 {apiPrefix: true, jsonp: false} 自定义了设置，apiPrefix为是否添加chameleon.config.js中设置的apiPrefix; jsonp 为 true 时会发起一个 jsonp 请求 返回值 返回promise，对应的请求成功和失败回调 举例 cml.get({ url: 'https://cml.com/api/user/1' }).then(res => { cml.showToast({ message: JSON.stringify(res), duration: 2000 }) }, err => { cml.showToast({ message: JSON.stringify(err), duration: 2000 }) }) post 发送post请求 参数 参数 类型 必需 默认值 说明 url String 是 网络请求地址，如果项目中配置了apiPrefix并且setting中的apiPrefix为true，则添加配置的前缀 data Object 否 要传的参数，会拼接在请求的url中 header Object 否 设置http请求的header contentType String 否 form 取值：form或json，决定body中data的格式，对应header中content-type为application/x-www-form-urlencoded或application/json resDataType String 否 json 设置response的数据类型, 为json时, 会尝试对返回值进行JSON.parse() 返回值 返回promise，对应的请求成功和失败回调 举例 cml.post({ url: 'https://cml.com/api/user/update', data: { a: 1 } }).then(res => { cml.showToast({ message: JSON.stringify(res), duration: 2000 }) }, err => { cml.showToast({ message: JSON.stringify(err), duration: 2000 }) }) request 发送request请求 参数 参数 类型 必需 默认值 说明 url String 是 网络请求地址，如果项目中配置了apiPrefix并且setting中的apiPrefix为true，则添加配置的前缀 data Object 否 要传的参数，会拼接在请求的url中 method Object 否 若cml.get()/cml.post()无法满足需求,如需使用DELETE/PUT时,可调用此方法 header Object 否 设置http请求的header contentType String 否 form 取值：form或json，决定body中data的格式，对应header中content-type为application/x-www-form-urlencoded或application/json resDataType String 否 json 设置response的数据类型, 为json时, 会尝试对返回值进行JSON.parse() 返回值 返回promise，对应的请求成功和失败回调 举例 cml.request({ url: 'https://cml.com/api/user/1', data: { a: 1 }, method: 'PUT' }).then(res => { cml.showToast({ message: JSON.stringify(res), duration: 2000 }) }, err => { cml.showToast({ message: JSON.stringify(err), duration: 2000 }) }) "},"api/navigate.html":{"url":"api/navigate.html","title":"路由导航","keywords":"","body":"路由导航 navigateTo 保留当前页面，跳转到应用内的某个页面。 参数 参数名 类型 必填 默认值 说明 path String 是 无 应用内页面的路径， 路由里面的path值 (用于小程序端) query Object 否 无 要传递的参数，可在将进入页面的beforeCreate里面获取 返回值 无 举例 cml.navigateTo({ path: '/pages/navigateBack/index', query: { a: 1, b: 'test' } }) redirectTo 关闭当前页面，跳转到应用内的某个页面 参数 参数名 类型 必填 默认值 说明 path String 是 无 应用内页面的路径， 即路由里面的path值 (用于小程序端) query Object 否 无 要传递给将进入页面参数，可在将进入页面的beforeCreate里面获取 返回值 无 举例 cml.redirectTo({ path: '/pages/navigateBack/index', query: { a: 1, b: 'test' } }) navigateBack 关闭当前页面，返回上一页面 \b参数 参数名 类型 必填 默认值 说明 backPageNum Number[负数] 否 -1 要返回的页面级数, 为负数, 默认返回上一页 举例 cml.navigateBack(-1); "},"api/storage.html":{"url":"api/storage.html","title":"数据存储","keywords":"","body":"数据存储 setStorage 该方法通过键值对的形式将数据存储到本地。同时也可以通过该方法更新已有的数据。 参数 参数 类型 说明 key String 要存储的键 value String/Number/Object/Array 储存的值 返回值 返回promise 举例 cml.setStorage('name', 'Hanks').then(()=>{ },function(err){ }) getStorage \b获取本地存储的对应键名的键值 参数 参数 类型 说明 key String 存储的键名 返回值 返回promise 返回值 类型 说明 value String 存储的键名对应的键值 举例 cml.getStorage('name').then((value)=>{ // 处理获取到的键值 },function(err){ }) removeStorage 删除本地存储中对应键值对应的数据 参数 参数 类型 说明 key String 存储的键名 返回值 返回promise 举例 cml.removeStorage('name').then(()=>{ },function(err){ }) "},"api/location.html":{"url":"api/location.html","title":"地理位置","keywords":"","body":"获取地理位置 注： 在weex端，接入chameleon客户端sdk之后才可以使用该方法 getLocationInfo 参数 无 返回值 参数 类型 说明 lng Number 经度 lat Number 纬度 举例 cml.getLocationInfo().then(res => { // res: { lng[number]: 40.33, lat[number]: 154.33 } cml.showToast({ message: JSON.stringify(res), duration: 2000 }) }) "},"api/system.html":{"url":"api/system.html","title":"系统信息","keywords":"","body":"获取系统信息 get\bSystemInfo 获取系统信息，至少返回系统类型，如ios或android。 参数 无 返回值 返回值 类型 说明 os String 系统类型，ios或android。注意是小写。 env String 所处环境，web，weex，wx（微信小程序） viewportWidth Number \b视口宽度 viewportHeight Number \b视口高度 extraParams Object 包含端内bridge或小程序api返回的所有信息 举例 cml.getSystemInfo().then(info => { }) "},"api/launchOptions.html":{"url":"api/launchOptions.html","title":"启动参数","keywords":"","body":"启动参数信息 getLaunchOptionsSync() 获取程序启动时的参数信息（同步方法） 参数 无 返回值 参数 类型 说明 query Object 小程序，web或者native中启动时的query信息 path String 启动小程序的路径 scene Number 启动小程序的场景值 其他 Any 小程序中并列返回的其他参数 举例 let obj = getLaunchOptionsSync(); cml.showToast({ message: JSON.stringify(obj) }) "},"api/getRect.html":{"url":"api/getRect.html","title":"元素属性","keywords":"","body":"元素属性 getRect 获取某个节点的部分属性 参数 参数名 类型 必填 默认值 说明 ref String 是 无 页面上标记了ref属性的节点 context context 是 无 由于小程序端限制, 组件内获取元素属性需要指定组件的上下文, 通常传this即可 返回值 \bPromise成功回调返回值: 返回值 类型 说明 width number 节点的宽度 height number 节点的高度 left number 节点的左边界坐标 right number 节点的右边界坐标 top number 节点的上边界坐标 bottom number 节点的下边界坐标 举例 // 'refTest'为\btemplate中某个节点的ref属性所对应的值 cml.getRect('refTest', this).then(res => { cml.showToast({ message: JSON.stringify(res) }) }) "},"api/px.html":{"url":"api/px.html","title":"单位转换","keywords":"","body":"单位转换 尺寸单位 cpx: chemeleon体系中的尺寸单位，可以根据屏幕宽度进行自适应，规定屏幕的\b宽度为750cpx。例如在iPhone6上，屏幕宽度为375px(css像素)，则750cpx = 375px,即1cpx = 0.5px px2cpx px转cpx，输入一个px值得到当前设备上对应的cpx值 参数 参数 类型 说明 px Number 要转换为cpx的px值 返回值 返回对应的cpx值 举例 const cpx = cml.px2cpx(100); cpx2px cpx转px，输入一个cpx值得到当前设备上对应的px值 参数 参数 类型 说明 cpx Number 要转换为px的cpx值 返回值 返回对应的px值 举例 const px = cml.cpx2px(100); "},"api/modal.html":{"url":"api/modal.html","title":"交互反馈","keywords":"","body":"交互反馈 showToast 显示消息的提示框 参数 showToast方法传入一个对象，\b对象中包含如下参数： 参数名 类型 必填 默认值 说明 message String 否 无 展示的内容 duration number 否 2000 展示的持续时间(以毫秒为单位) 举例 cml.showToast({ message: \"Hello World\", duration: 1000 }) alert 用于确保用户可以得到某些消息的警示框。当警示框出现后，用户需要点击确定按钮才能继续进行操作。 参数说明 alert方法传入一个对象，对象中包含如下参数： 参数名 类型 必填 默认值 说明 message String 否 无 \b警示框内显示的文本信息 confirmTitle String 否 确定 确认按钮上显示的文字信息，默认是\"确认\" 返回值 调用alert之后返回一个Promise对象 举例 cml.alert({ message:'This is alert! ', confirmTitle:\"ok\" }).then(function(){ cml.showToast({ message:'success!', duration:1000 }) }) confirm 用于使用户可以接受或验证某些信息的确认框。当确认框出现后，用户需要点击确认或取消按钮才能继续进行操作。 参数说明 confirm方法传入一个对象，对象中包含如下参数: 参数名 类型 必填 默认值 说明 message String 否 无 确认框内显示的文字信息 confirmTitle String 否 确定 确认按钮上显示的文字信息，默认是\"确认\" cancelTitle String 否 取消 取消按钮上显示的文字信息，默认是“取消” 返回值 调用confrim之后返回一个Promise对象，其成功回调返回值为： \b返回值 类型 说明 value String 所点击按钮上的文本信息 举例 cml.confirm({ message:'Do you confirm?', confirmTitle:\"ok\", cancelTitle: \"cancel\" }).then(function(value){ cml.showToast({ message: \"用户点击了\"+value, duration:1000 }) }) "},"api/title.html":{"url":"api/title.html","title":"设置title","keywords":"","body":"设置title setTitle 设置当前页面的title（在weex端请使用page组件的title属性来设置title） 参数 \b参数 类型 说明 title String 标题内容 返回值 无 举例 cml.setTitle('我是标题') "},"api/open.html":{"url":"api/open.html","title":"打开/关闭应用页面","keywords":"","body":"打开新的应用页面 打开新的应用页面 open 参数 参数名 类型 必填 默认值 说明 url String 是 无 chameleon地址带参数 commonPatchParams Object 否 无 额外传入的需要同时添加到各个端的参数\b，可用于业务代码自定义添加 extraOptions Object 否 无 额外传入的配置，\bcloseCurrent: true 会关闭当前页面后再打开新页面 返回值 无 举例 cml.open( 'https://url?wx_addr=xxx29134e8fa.js&weixin_appid=123456&path=page/a/b/c', { wd: 'chameleon', time: new Date() }, { closeCurrent: false } ); 关闭当前页面 这个方法设计的初衷是关闭当前“单页面应用”。如果是你要在页面应用中返回上个页面，请使用navigate api来后退。 注意：在浏览器端，该功能\b属于部分支持。 注： 在weex端，接入chameleon客户端sdk之后才可以使用该方法 close 参数 无 返回值 无 举例 cml.close() "},"api/chooseImage.html":{"url":"api/chooseImage.html","title":"获取照片","keywords":"","body":"选取照片 通过拍照，相册，拍照相册二选一3种方式选择照片数据 注： 在weex端，接入chameleon客户端sdk之后才可以使用该方法 chooseImage 参数 参数 类型 必填 说明 params.type String 是 类型camera(相机)，album(相册)，choice(菜单选择) 注意web在端外使用js方式，故默认使用拍照相册二选一方式 callbackSuccess Function 是 获取返回的数据回调，返回参数包含 \bweb和weex使用返回的base64数据, 微信小程序使用返回的tempFilePathsWx字段 callbackFail Function 否 调用发生失败信息 示例 // choice方式选择图片 cml.chooseImage({ type: 'choice' }).then((res) => { const myImageData = res.base64; // 微信小程序中使用返回的 res.WxTempFilePaths[0] // 接下来可以进行上传到服务器等操作 }) "},"api/clipBoard.html":{"url":"api/clipBoard.html","title":"剪贴板","keywords":"","body":"剪贴板 setClipBoardData 传进setClipBoardData方法中的内容(text)将会自动复制到系统剪贴板。 返回值promise的回调中会告知你此操作是否成功 参数 参数名 类型 必填 默认值 说明 data string 是 无 无 举例 cml.setClipBoardData('你所需要复制的文本内容').then(res=>{ cml.showToast({ message: JSON.stringify(res), duration: 2000 }) }).catch(reason=>{ cml.showToast({ message: JSON.stringify(reason), duration: 2000 }) }) getClipBoardData 获取系统剪贴板中的内容(text)注意： 出于安全考虑和平台限制，只支持获取在本页中复制的内容。 如果你当前没有在本页面发生过copy操作，而触发了此方法，则会返回fail。 参数 无 返回值 Promise 返回值类型为: 返回值 类型 说明 \bres string 当前系统剪贴板中的内容 举例 cml.getClipBoardData().then(res=>{ cml.showToast({ message: JSON.stringify(res), duration: 2000 }) }) "},"api/socket.html":{"url":"api/socket.html","title":"WebSocket","keywords":"","body":"WebSocket 注： 在weex端，接入chameleon客户端sdk之后才可以使用该方法 initSocket 该方法传入一个url，返回一个WebSocket实例 参数 参数 类型 说明 url String 开发者服务器 ws 接口地址 返回值 返回WebSocket实例 举例 假设将调用cml.initSocket返回的WebSocket实例命名为ws，则ws上具有的方法如下： ws.send(data): 通过WebSocket连接向服务端发送数据,data支持字符串和对象 ws.close(): 关闭WebSocket连接 ws.onopen(): 监听WebSocket连接打开事件 ws.onclose(): 监听WebSocket连接关闭事件 ws.onmessage(): 监听WebSocket接收到服务器的消息事件 ws.onerror(): 监听WebSocket错误事件 let ws = cml.initSocket('ws://172.22.137.223:3333'); ws.onopen(() => { cml.showToast({ message: 'socket connected...', duration: 1000 }); setTimeout(() => { ws.send('hello cml socket'); }, 2000); }); ws.onmessage(res => { cml.showToast({ message: 'receive from server: ' + res.data, duration: 1000 }) ws.send({ keyword:'socket传递复杂类型', content: 'hello cml socket', arr: ['test1', 12, {}] }) }); ws.onerror(err => { console.error(err) }); ws.onclose(() => { cml.showToast({ message: 'socket closed...' }) }); setTimeout(() => { ws.close(); }, 20000); "},"api/timer.html":{"url":"api/timer.html","title":"计时器","keywords":"","body":"计时器 setTimeout 设定一个定时器，在定时到期以后执行注册的回调函数 参数 参数 类型 说明 callback Function 回调函数 delay Number 延迟时间，单位ms 返回值 返回值 类型 说明 ID Number \b计时器id 举例 setTimeout(()=>{ // do something after 3000ms }, 3000) clearTimeout 取消由 setTimeout() 方法设置的定时器 参数 参数 类型 说明 ID Number \b计时器id 返回值 无 举例 var timer = setTimeout(()=>{ // do something after 3000ms }, 3000); clearTimeout(timer) setInterval 设定一个定时器，按照指定的周期（以毫秒计）来执行注册的回调函数 参数 参数 类型 说明 callback Function 回调函数 delay Number 延迟时间，单位ms 返回值 返回值 类型 说明 ID Number \b计时器id 举例 setInterval(()=>{ // do something every 3000ms }, 3000) clearInterval 取消由 setInterval() 方法设置的定时器\b。 参数 参数 类型 说明 ID Number \b计时器id 返回值 无 举例 var timer = setInterval(()=>{ // do something after 3000ms }, 3000); clearInterval(timer) "},"api/caniuse.html":{"url":"api/caniuse.html","title":"canIUse","keywords":"","body":"canIUse 用来查询某个方法chameleon是否支持。调用此方法，并传入你想知道是否支持的方法名。 使用示例 cml.canIUse('showToast').then(() => { // 支持 }, () => { // 不支持 }; "},"api/async.html":{"url":"api/async.html","title":"异步流程控制","keywords":"","body":"异步控制 你可以使用Promise，async、await来更好的进行异步流\b的控制。 Promise((resolve, reject) => {}) 参数 resolve：成功回调 reject：\b失败回调 const promise = new Promise((resolve, reject) => { // 异步操作的代码 if (/* 异步操作成功 */){ resolve(value); } else { reject(error); } }); async，await const sleep = function (time) { return new Promise((resolve, reject) => { setTimeout(() => { resolve('ok'); }, time); }) }; const start = async function () { let result = await sleep(3000); console.log(result); } start(); "},"api/error_control.html":{"url":"api/error_control.html","title":"异常和错误处理","keywords":"","body":"错误处理 在跨端的代码的书写中，你可以使用try catch，Promise.catch()来进行错误的处理，但不可以在小程序和weex端的代码里出现window.onerror方法\b。 promise.then().catch((e) => {}) 举例 var promise = new Promise(function(resolve, reject) { resolve('Success'); }); promise.then(function(value) { console.log(value); // \"Success!\" throw 'oh, no!'; }).catch(function(e) { console.log(e); // \"oh, no!\" }) try catch 你可以使用try catch finally来捕获和处理异常错误。\b 举例 try { throw \"myException\"; // generates an exception } catch (e) { // statements to handle any exceptions logMyErrors(e); // pass exception object to error handler } "},"api/animationFrame.html":{"url":"api/animationFrame.html","title":"动画关键帧","keywords":"","body":"动画关键帧 requestAnimationFrame (callback: function) 方法告诉客户在下一次重绘之前需要调用的函数。（回调次数：web端通常是每秒60次，大多数浏览器通常匹配 W3C 所建议的刷新频率，其它端为60次） 参数 参数名 类型 必填 说明 callback function 是 该函数在下次重绘前调用。只有一个参数，即开始触发回调的时间（performance.now() 的返回值） cancelAnimationFrame (id: number) 取消由 requestAnimationFrame方法设置的关键帧 参数 参数名 类型 必填 说明 ID number 是 要取消的定时器ID "},"api/createAnimation/main.html":{"url":"api/createAnimation/main.html","title":"动画","keywords":"","body":"动画 动画模块用来在目标元素上执行动画 可执行一系列简单的变换 (位置、大小、旋转角度、背景颜色和透明度等) "},"api/createAnimation/createAnimation.html":{"url":"api/createAnimation/createAnimation.html","title":"cml.createAnimation","keywords":"","body":"cml.createAnimation() 返回一个动画实例 animation。调用实例的方法来描述动画。最后通过实例的 export 方法导出动画数据传递给目标组件的c-animation属性。 参数 参数名 类型 必填 默认值 说明 object.duration number 否 400 动画持续时间，单位 ms object.delay number 否 0 动画延迟时间，单位 ms object.timingFunction string 否 'linear' 回调函数 object.transformOrigin string 否 '50% 50%' 定义变化过程的中心点 object.cb number function 无 回调函数 timingFunction 的合法值 值 说明 'linear' 动画从头到尾的速度是相同的 'ease' 动画以低速开始，然后加快，在结束前变慢 'ease-in' 动画以低速开始 'ease-in-out' 动画以低速开始和结束 'ease-out' 动画以低速结束 返回值 \b返回值 类型 说明 animation animation 动画实例 "},"api/createAnimation/animation/main.html":{"url":"api/createAnimation/animation/main.html","title":"Animation","keywords":"","body":"animation 动画实例 animation.export() 导出动画队列 animation.step(object Object) 表示一组动画完成。可以在一组动画中调用任意多个动画方法，一组动画中的所有动画会同时开始，一组动画完成后才会进行下一组动画 animation.rotate(number | number angle) 从原点顺时针旋转一个角度 animation.rotateX(number | number angle) 从 X 轴顺时针旋转一个角度 animation.rotateY(number | number angle) 从 Y 轴顺时针旋转一个角度 animation.rotateZ(number | number angle) 从 Z 轴顺时针旋转一个角度 animation.scale(number sx, number sy) 缩放 animation.scaleX(number scale) 缩放 X 轴 animation.scaleY(number scale) 缩放 Y 轴 animation.translate(number, number) 平移变换 animation.translateX(number) 对 X 轴平移 animation.translateY(number) 对 Y 轴平移 animation.opacity(number) 设置透明度 animation.backgroundColor(string value) 设置背景色 （目前只支持16进制） animation.width(number) 设置宽度 animation.height(number) 设置高度 示例 请点击我 import { createAnimation } from \"@didi/chameleon-api\"; const animation = createAnimation(); class Index { data = { animationData: null, } methods = { handleClick() { this.animationData = animation .translateX(200).step({duration: 1000}) .translateY(200).step({duration: 1000}) .width(100).step({duration: 1000}) .height(100).step({duration: 1000}) .backgroundColor('#000000').step({duration: 1000}) .opacity(0.1).step({duration: 1000}) .export(); } } } export default new Index(); .block { position: absolute; width: 200cpx; height: 200cpx; background-color: #E3EDCD; } { \"base\": { \"usingComponents\": {} } } wx web native 查看完整示例 "},"api/createAnimation/animation/step.html":{"url":"api/createAnimation/animation/step.html","title":".step","keywords":"","body":"animation.step(object Object) 表示一个动画动作的结束 参数 参数名 类型 必填 默认值 说明 duration number 否 400 动画持续时间，单位 ms delay number 否 0 动画延迟时间，单位 ms transformOrigin string 否 '50% 50%' 定义变化过程的中心点 cb number function 无 回调函数 timingFunction 的合法值 值 说明 'linear' 动画从头到尾的速度是相同的 'ease' 动画以低速开始，然后加快，在结束前变慢 'ease-in' 动画以低速开始 'ease-in-out' 动画以低速开始和结束 'ease-out' 动画以低速结束 返回值 返回值 \b返回值 类型 说明 animation animation 动画实例 "},"api/createAnimation/animation/rotate.html":{"url":"api/createAnimation/animation/rotate.html","title":".rotate","keywords":"","body":"animation.rotate() 从原点顺时针旋转一个角度 参数 参数 类型 说明 number number angle 旋转的角度 返回值 \b返回值 类型 说明 animation animation 动画实例 注： 调用export方法后不会清除该样式 示例 请点击我 import { createAnimation } from \"@didi/chameleon-api\"; const animation = createAnimation(); class Index { data = { animationData: null, } methods = { handleClick() { this.animationData = animation .rotate(90).step({duration: 1000}) .export(); } } } export default new Index(); .block { position: absolute; width: 200cpx; height: 200cpx; background-color: #E3EDCD; } { \"base\": { \"usingComponents\": {} } } "},"api/createAnimation/animation/rotateX.html":{"url":"api/createAnimation/animation/rotateX.html","title":".rotateX","keywords":"","body":"animation.rotateX() 从 X 轴顺时针旋转一个角度 参数 参数 类型 说明 number number angle 旋转的角度 返回值 \b返回值 类型 说明 animation animation 动画实例 注： 调用export方法后不会清除该样式 示例 请点击我 import { createAnimation } from \"@didi/chameleon-api\"; const animation = createAnimation(); class Index { data = { animationData: null, } methods = { handleClick() { this.animationData = animation .rotateX(90).step({duration: 1000}) .export(); } } } export default new Index(); .block { position: absolute; width: 200cpx; height: 200cpx; background-color: #E3EDCD; } { \"base\": { \"usingComponents\": {} } } "},"api/createAnimation/animation/rotateY.html":{"url":"api/createAnimation/animation/rotateY.html","title":".rotateY","keywords":"","body":"animation.rotateY() 从 Y 轴顺时针旋转一个角度 参数 参数 类型 说明 number number angle 旋转的角度 返回值 \b返回值 类型 说明 animation animation 动画实例 注： 调用export方法后不会清除该样式 示例 请点击我 import { createAnimation } from \"@didi/chameleon-api\"; const animation = createAnimation(); class Index { data = { animationData: null, } methods = { handleClick() { this.animationData = animation .rotateY(90).step({duration: 1000}) .export(); } } } export default new Index(); .block { position: absolute; width: 200cpx; height: 200cpx; background-color: #E3EDCD; } { \"base\": { \"usingComponents\": {} } } "},"api/createAnimation/animation/rotateZ.html":{"url":"api/createAnimation/animation/rotateZ.html","title":".rotateZ","keywords":"","body":"animation.rotateZ() 从 Z 轴顺时针旋转一个角度 参数 参数 类型 说明 number number angle 旋转的角度 返回值 \b返回值 类型 说明 animation animation 动画实例 注： 调用export方法后不会清除该样式 示例 请点击我 import { createAnimation } from \"@didi/chameleon-api\"; const animation = createAnimation(); class Index { data = { animationData: null, } methods = { handleClick() { this.animationData = animation .rotateZ(90).step({duration: 1000}) .export(); } } } export default new Index(); .block { position: absolute; width: 200cpx; height: 200cpx; background-color: #E3EDCD; } { \"base\": { \"usingComponents\": {} } } "},"api/createAnimation/animation/scale.html":{"url":"api/createAnimation/animation/scale.html","title":".scale","keywords":"","body":"animation.scale() 缩放 参数 参数 类型 说明 number sx number 当仅有 sx 参数时，表示在 X 轴、Y 轴同时缩放sx倍数 number sy number 在 Y 轴缩放 sy 倍数 返回值 \b返回值 类型 说明 animation animation 动画实例 注： 调用export方法后不会清除该样式 示例 请点击我 import { createAnimation } from \"@didi/chameleon-api\"; const animation = createAnimation(); class Index { data = { animationData: null, } methods = { handleClick() { this.animationData = animation .scale(2, 2).step({duration: 1000}) .export(); } } } export default new Index(); .block { position: absolute; width: 200cpx; height: 200cpx; background-color: #E3EDCD; } { \"base\": { \"usingComponents\": {} } } "},"api/createAnimation/animation/scaleX.html":{"url":"api/createAnimation/animation/scaleX.html","title":".scaleX","keywords":"","body":"animation.scaleX() 缩放 X 轴 参数 参数 类型 说明 number sx number X 轴的缩放倍数 返回值 \b返回值 类型 说明 animation animation 动画实例 注： 调用export方法后不会清除该样式 示例 请点击我 import { createAnimation } from \"@didi/chameleon-api\"; const animation = createAnimation(); class Index { data = { animationData: null, } methods = { handleClick() { this.animationData = animation .scaleX(2).step({duration: 1000}) .export(); } } } export default new Index(); .block { position: absolute; width: 200cpx; height: 200cpx; background-color: #E3EDCD; } { \"base\": { \"usingComponents\": {} } } "},"api/createAnimation/animation/scaleY.html":{"url":"api/createAnimation/animation/scaleY.html","title":".scaleY","keywords":"","body":"animation.scaleY() 缩放 Y 轴 参数 参数 类型 说明 number sx number Y 轴的缩放倍数 返回值 \b返回值 类型 说明 animation animation 动画实例 注： 调用export方法后不会清除该样式 示例 请点击我 import { createAnimation } from \"@didi/chameleon-api\"; const animation = createAnimation(); class Index { data = { animationData: null, } methods = { handleClick() { this.animationData = animation .scaleY(2).step({duration: 1000}) .export(); } } } export default new Index(); .block { position: absolute; width: 200cpx; height: 200cpx; background-color: #E3EDCD; } { \"base\": { \"usingComponents\": {} } } "},"api/createAnimation/animation/translate.html":{"url":"api/createAnimation/animation/translate.html","title":".translate","keywords":"","body":"animation.translate() 对 X 轴坐标进行倾斜 参数 参数 类型 说明 number tx number 在 X 轴平移的距离 number ty number 在 Y 轴平移的距离 返回值 \b返回值 类型 说明 animation animation 动画实例 注： 调用export方法后不会清除该样式 示例 请点击我 import { createAnimation } from \"@didi/chameleon-api\"; const animation = createAnimation(); class Index { data = { animationData: null, } methods = { handleClick() { this.animationData = animation .translate(100, 100).step({duration: 1000}) .export(); } } } export default new Index(); .block { position: absolute; width: 200cpx; height: 200cpx; background-color: #E3EDCD; } { \"base\": { \"usingComponents\": {} } } "},"api/createAnimation/animation/translateX.html":{"url":"api/createAnimation/animation/translateX.html","title":".translateX","keywords":"","body":"animation.translateX() 在 X 轴平移 参数 参数 类型 说明 number tx number 在 X 轴平移的距离 返回值 \b返回值 类型 说明 animation animation 动画实例 注： 调用export方法后不会清除该样式 示例 请点击我 import { createAnimation } from \"@didi/chameleon-api\"; const animation = createAnimation(); class Index { data = { animationData: null, } methods = { handleClick() { this.animationData = animation .translateX(100).step({duration: 1000}) .export(); } } } export default new Index(); .block { position: absolute; width: 200cpx; height: 200cpx; background-color: #E3EDCD; } { \"base\": { \"usingComponents\": {} } } "},"api/createAnimation/animation/translateY.html":{"url":"api/createAnimation/animation/translateY.html","title":".translateY","keywords":"","body":"animation.translateY() 在 Y 轴平移 参数 参数 类型 说明 number ty number 在 Y 轴平移的距离 返回值 \b返回值 类型 说明 animation animation 动画实例 注： 调用export方法后不会清除该样式 示例 请点击我 import { createAnimation } from \"@didi/chameleon-api\"; const animation = createAnimation(); class Index { data = { animationData: null, } methods = { handleClick() { this.animationData = animation .translateY(100).step({duration: 1000}) .export(); } } } export default new Index(); .block { position: absolute; width: 200cpx; height: 200cpx; background-color: #E3EDCD; } { \"base\": { \"usingComponents\": {} } } "},"api/createAnimation/animation/opacity.html":{"url":"api/createAnimation/animation/opacity.html","title":".opacity","keywords":"","body":"animation.opacity() 设置透明度 参数 \b返回值 类型 说明 number value number 高度值 返回值 \b返回值 类型 说明 animation animation 动画实例 示例 请点击我 import { createAnimation } from \"@didi/chameleon-api\"; const animation = createAnimation(); class Index { data = { animationData: null, } methods = { handleClick() { this.animationData = animation .opacity(0.1).step({duration: 1000}) .export(); } } } export default new Index(); .block { position: absolute; width: 200cpx; height: 200cpx; background-color: #E3EDCD; } { \"base\": { \"usingComponents\": {} } } "},"api/createAnimation/animation/backgroundColor.html":{"url":"api/createAnimation/animation/backgroundColor.html","title":".backgroundColor","keywords":"","body":"animation.backgroundColor() 设置背景色 参数 \b参数名 类型 说明 string value string 颜色值（目前只支持16进制） 返回值 \b返回值 类型 说明 animation animation 动画实例 示例 请点击我 import { createAnimation } from \"@didi/chameleon-api\"; const animation = createAnimation(); class Index { data = { animationData: null, } methods = { handleClick() { this.animationData = animation .backgroundColor('#000000').step({duration: 1000}) .export(); } } } export default new Index(); .block { position: absolute; width: 200cpx; height: 200cpx; background-color: #E3EDCD; } { \"base\": { \"usingComponents\": {} } } "},"api/createAnimation/animation/width.html":{"url":"api/createAnimation/animation/width.html","title":".width","keywords":"","body":"animation.width() 设置宽度 参数 \b参数名 类型 说明 number value Number 长度值 返回值 \b返回值 类型 说明 animation animation 动画实例 示例 请点击我 import { createAnimation } from \"@didi/chameleon-api\"; const animation = createAnimation(); class Index { data = { animationData: null, } methods = { handleClick() { this.animationData = animation .height(100).step({duration: 1000}) .export(); } } } export default new Index(); .block { position: absolute; width: 200cpx; height: 200cpx; background-color: #E3EDCD; } { \"base\": { \"usingComponents\": {} } } "},"api/createAnimation/animation/height.html":{"url":"api/createAnimation/animation/height.html","title":".height","keywords":"","body":"animation.height() 设置高度 参数 \b参数名 类型 说明 number value number 长度值 返回值 \b返回值 类型 说明 animation animation 动画实例 示例 请点击我 import { createAnimation } from \"@didi/chameleon-api\"; const animation = createAnimation(); class Index { data = { animationData: null, } methods = { handleClick() { this.animationData = animation .height(100).step({duration: 1000}) .export(); } } } export default new Index(); .block { position: absolute; width: 200cpx; height: 200cpx; background-color: #E3EDCD; } { \"base\": { \"usingComponents\": {} } } "},"api/createAnimation/animation/export.html":{"url":"api/createAnimation/animation/export.html","title":".export","keywords":"","body":"animation.export() 导出动画队列。export 方法每次调用后会清掉之前的动画操作，但会保留transtorm族和transformOrigin。 参数 无 返回值 \b返回值 类型 说明 animationData object 已生成的动画数据 "},"api/store/store.html":{"url":"api/store/store.html","title":"Store","keywords":"","body":"Store 通过 chameleon-store 创建的Store实例,有以下方法： ChameleonStore.createStore(options: Object): Object Store构造器。详细介绍 ChameleonStore.Store 实例方法 Store.commit(type: string, payload?: any) 提交 mutation。详细介绍 Store.dispatch(type: string, payload?: any) 分发 action。详细介绍 Store.mapState(map: Array | Object): Object 为组件创建计算属性以返回 store 中的状态。详细介绍 Store.mapGetters(map: Array | Object): Object 为组件创建计算属性以返回 getter 的返回值。详细介绍 Store.mapMutations(map: Array | Object): Object 创建组件方法提交 mutation。详细介绍 Store.mapActions(map: Array | Object): Object 创建组件方法分发 action。详细介绍 Store.registerModule(path: String, module: Module) 注册一个动态模块。详细介绍 "},"api/store/createStore.html":{"url":"api/store/createStore.html","title":"Store.createStore","keywords":"","body":"ChameleonStore.createStore // store.js import createStore from 'chameleon-store' const store = createStore({ ...options }) export default store createStore 构造器选项 state 类型: Object chameleon store 实例的根 state 对象。详细介绍 mutations 类型: { [type: string]: Function } 在 store 上注册 mutation，处理函数总是接受 state 作为第一个参数（如果定义在模块中，则为模块的局部状态），payload 作为第二个参数（可选）。 详细介绍 actions 类型: { [type: string]: Function } 在 store 上注册 action。处理函数总是接受 context 作为第一个参数，payload 作为第二个参数（可选）。 context 对象包含以下属性： { state, // 等同于 `store.state`，若在模块中则为局部状态 rootState, // 等同于 `store.state`，只存在于模块中 commit, // 等同于 `store.commit` dispatch, // 等同于 `store.dispatch` getters, // 等同于 `store.getters` rootGetters // 等同于 `store.getters`，只存在于模块中 } 同时如果有第二个参数 payload 的话也能够接收。 详细介绍 getters 类型: { [key: string]: Function } 在 store 上注册 getter，getter 方法接受以下参数： state, // 如果在模块中定义则为模块的局部状态 getters, // 等同于 store.getters 当定义在一个模块里时会特别一些： state, // 如果在模块中定义则为模块的局部状态 getters, // 等同于 store.getters rootState // 等同于 store.state rootGetters // 所有 getters 注册的 getter 暴露为 store.getters。 详细介绍 modules 类型: Object 包含了子模块的对象，会被合并到 store，大概长这样： { key: { state, namespaced?, mutations, actions?, getters?, modules? }, ... } 与根模块的选项一样，每个模块也包含 state 和 mutations 选项。模块的状态使用 key 关联到 store 的根状态。模块的 mutation 和 getter 只会接收 module 的局部状态作为第一个参数，而不是根状态，并且模块 action 的 context.state 同样指向局部状态。 "},"api/store/commit.html":{"url":"api/store/commit.html","title":"Store.commit","keywords":"","body":"Store.commit 提交 mutation。 详细介绍 参数说明 参数 类型 必填 说明 type String 是 类型 payload any 否 载荷,传入的额外参数 示例 // store.js import createStore from 'chameleon-store' const store = createStore({ state: { count: 0 }, mutations: { increment (state) { state.count++ } } }) export default store // app.js store.commit('increment') "},"api/store/dispatch.html":{"url":"api/store/dispatch.html","title":"Store.dispatch","keywords":"","body":"Store.dispatch 分发 action。返回一个解析所有被触发的 action 处理器的 Promise。详细介绍 参数说明 参数 类型 必填 说明 type String 是 类型 payload any 否 载荷,传入的额外参数 示例 // store.js import createStore from 'chameleon-store' const store = createStore({ state: { count: 0 }, mutations: { increment (state) { state.count++ } }, actions: { incrementAsync ({ commit }) { setTimeout(() => { commit('increment') }, 1000) } } }) export default store // app.js store.dispatch('incrementAsync') "},"api/store/mapState.html":{"url":"api/store/mapState.html","title":"Store.mapState","keywords":"","body":"Store.mapState 为组件创建计算属性以返回 chameleon store 中的状态。详细介绍 参数说明 参数 类型 必填 说明 map Array | Object 是 如果是对象形式，成员可以是一个函数。function(state: any) 示例 // store.js import createStore from 'chameleon-store' const store = createStore({ state: { count: 0 }, mutations: { increment (state) { state.count++ } } }) export default store // app.js import store from './store.js' class Index { // ... computed = store.mapState({ // 箭头函数可使代码更简练 count: state => state.count, // 传字符串参数 'count' 等同于 `state => state.count` countAlias: 'count', // 为了能够使用 `this` 获取局部状态，必须使用常规函数 countPlusLocalState (state) { return state.count + this.localCount } }) }; export default new Index(); "},"api/store/mapGetters.html":{"url":"api/store/mapGetters.html","title":"Store.mapGetters","keywords":"","body":"Store.mapGetters 为组件创建计算属性以返回 getter 的返回值。详细介绍 参数说明 参数 类型 必填 说明 map Array | Object 是 如果是对象形式，成员可以是一个函数。function(state: any) 示例 // store.js import createStore from 'chameleon-store' const store = createStore({ state: { count: 0 }, mutations: { increment (state) { state.count++ } } }) export default store // app.js import store from './store.js' class Index { // ... computed = { // 使用对象展开运算符将 getter 混入 computed 对象中 ...store.mapGetters([ 'doneTodosCount', 'anotherGetter', // ... ]) } }; export default new Index(); "},"api/store/mapMutations.html":{"url":"api/store/mapMutations.html","title":"Store.mapMutations","keywords":"","body":"Store.mapMutations 创建组件方法提交 mutation。详细介绍 参数说明 参数 类型 必填 说明 map Array | Object 是 如果是对象形式，成员可以是一个函数。function(commit: function, ...args: any[]) 示例 // store.js import createStore from 'chameleon-store' const store = createStore({ state: { count: 0 }, mutations: { increment (state) { state.count++ } } }) export default store // app.js import store from './store.js' class Index { // ... methods = { ...store.mapActions([ 'increment', // 将 `this.increment()` 映射为 `this.$store.dispatch('increment')` // `mapActions` 也支持载荷： 'incrementBy' // 将 `this.incrementBy(amount)` 映射为 `this.$store.dispatch('incrementBy', amount)` ]), ...store.mapActions({ add: 'increment' // 将 `this.add()` 映射为 `this.$store.dispatch('increment')` }) } }; export default new Index(); "},"api/store/mapActions.html":{"url":"api/store/mapActions.html","title":"Store.mapActions","keywords":"","body":"Store.mapActions 创建组件方法分发 action。详细介绍 参数说明 参数 类型 必填 说明 map Array | Object 是 如果是对象形式，成员可以是一个函数。function(dispatch: function, ...args: any[]) 示例 // store.js import createStore from 'chameleon-store' const store = createStore({ state: { count: 0 }, mutations: { increment (state) { state.count++ } } }) export default store // app.js import store from './store.js' class Index { // ... methods = { ...store.mapMutations([ 'increment', // 将 `this.increment()` 映射为 `this.$store.commit('increment')` // `mapMutations` 也支持载荷： 'incrementBy' // 将 `this.incrementBy(amount)` 映射为 `this.$store.commit('incrementBy', amount)` ]), ...store.mapMutations({ add: 'increment' // 将 `this.add()` 映射为 `this.$store.commit('increment')` }) } }; export default new Index(); "},"api/store/registerModule.html":{"url":"api/store/registerModule.html","title":"Store.registerModule","keywords":"","body":"Store.registerModule 注册一个动态模块。详细介绍 参数说明 参数 类型 必填 说明 path String 是 模块注册路径名 module Module 是 模块 示例 // 注册模块 `myModule` store.registerModule('myModule', { // ... }) "},"component/component.html":{"url":"component/component.html","title":"组件","keywords":"","body":"Chameleon 组件 框架 提供了大量内置组件和扩展组件，抹平多端差异，便于开发者通过组合这些组件，创建出强大的应用程序。 内置组件 扩展组件 "},"component/base/base.html":{"url":"component/base/base.html","title":"内置组件","keywords":"","body":"内置组件 内置组件不需要额外引入，框架会依据使用的组件按需加载。 基础内容 布局容器 表单组件 媒体组件 注：内置组件会整合各端组件共有属性，如需要使用某一端特有组件，请从业务出发使用 组件多态差异化实现功能。 "},"component/base/content/content.html":{"url":"component/base/content/content.html","title":"基础内容","keywords":"","body":"基础内容 view text page block cell "},"component/base/content/view.html":{"url":"component/base/content/view.html","title":"view","keywords":"","body":"view 视图容器。 类似web端的div块级元素标签。 示例 class View { }; export default new View(); .flex-item { width: 200cpx; height: 300cpx; background-color: #81c0c0; } { \"base\": {} } wx web native Bug & Tip 如果需要使用滚动视图，请使用 scroller 包裹 查看完整示例 "},"component/base/content/text.html":{"url":"component/base/content/text.html","title":"text","keywords":"","body":"text 文本容器。 按照指定的样式渲染文本内容。 示例 Original message: {{ message }} Computed reversed message: {{ reversedMessage }} class Text { data = { message: 'Hello' } computed = { reversedMessage: function () { return this.message.split('').reverse().join('') } } }; export default new Text(); { \"base\": {} } Bug & Tip 会保留文本头尾空白（空格、换行符等），若发现文本内容位置不符合预期，大概率是写成下面格式了： 我是有空格和换行符的文本 不支持子组件。 只能包含文本值，使用 双花括号 标记可以将变量值作为文本内容 查看完整示例 "},"component/base/content/page.html":{"url":"component/base/content/page.html","title":"page","keywords":"","body":"page 含titleBar基础页面容器 内置了weex端titleBar以及多端修改页面标题方法，titleBar为固定高度88cpx。 属性 属性名 类型 必填 默认值 说明 title String 是 titleBar所显示标题内容 c-bind:back EventHandle 否 点击返回时触发 slot 插槽名 作用 titlebar 自定义titlebar，自定义时需保证高度为88cpx menu 自定义菜单 默认页面内容 示例 这是页面内容 import cml from 'chameleon-api' class Page { methods = { goback() { cml.showToast({ message: 'goback' }) } } } export default new Page(); .main { color: red; } { \"base\": {} } Bug & Tip 组件为页面级基础容器组件，只能在页面组件中使用，在普通组件中使用不能保证正确显示，使用时需位于页面组件根结点位置。 组件在weex端titlebar高度为88cpx，在使用定位时注意兼容。 组件内置weex端titlebar仅能满足常规使用，若需要复杂的titlebar则需要自己实现。 由于android和ios页面渲染差异，android端是从状态栏以下开始渲染，而ios是从状态栏开始渲染页面，所以在ios端需要考虑状态栏高度 查看更多示例 "},"component/base/content/block.html":{"url":"component/base/content/block.html","title":"block","keywords":"","body":"block 包装容器 内置组件是一个包装容器，只接受控制属性，不会渲染在页面中 示例 chameleon block class Block { data = { show: true } methods = { clickHandle() { this.show = !this.show; } } } export default new Block(); .container { align-items: center; } { \"base\": {} } "},"component/base/content/cell.html":{"url":"component/base/content/cell.html","title":"cell","keywords":"","body":"cell 子列表项容器。 类似 web端的 li 元素标签，作为列表容器的子列表项。 示例 1 class Cell { } export default new Cell(); { \"base\": {} } Bug & Tip 的宽度等于父组件 的宽度，并且 高度会自适应，指定 margin 样式无效 查看完整示例 "},"component/base/layout/layout.html":{"url":"component/base/layout/layout.html","title":"布局容器","keywords":"","body":"布局容器 scroller list container row col carousel carousel-item "},"component/base/layout/scroller.html":{"url":"component/base/layout/scroller.html","title":"scroller","keywords":"","body":"scroller 可滚动视图区域。 可容纳排成一列的子组件的滚动器。 属性 属性名 类型 必填 默认值 说明 height Number scroll-direction为`vertical`时必传 0 定义纵向滚动区域的高度 注意： 1、 height=\"{{100}}\" /> 这样传值才是Number类型 2、height为-1时，的可滚动区域高度为scroller放置点至页面底部 width Number scroll-direction为`horizontal`时必传 0 定义横向滚动区域的宽度 注意： height为-1时，填充页面剩余宽度 scroll-direction String 否 vertical 定义滚动的方向。可选为 horizontal 或者 vertical cstyle String 否 自定义组件内联样式 bottom-offset Number 否 0 距底部/右边多远时（单位cpx），触发 onBottom 事件 scroll-top Number 否 0 scroll-direction为`vertical`时，设置滚动到的位置，（单位cpx） scroll-left Number 否 0 scroll-direction为`horizontal`时，设置滚动到的位置，（单位cpx） bounce Boolean 否 true 上拉下拉是否回弹(仅支持web) bounce Boolean 否 true 上拉下拉是否回弹(仅支持web) c-bind:scrolltobottom EventHandle 否 滚动到底部，会触发 scrolltobottom 事件 返回事件对象： event.type= \"scrolltobottom\" event.detail = { direction } c-bind:onscroll EventHandle 否 滚动时触发， 返回事件对象： event.type = 'scroll' event.detail = {scrollLeft, scrollTop, scrollHeight, scrollWidth, deltaX, deltaY} 限制 不允许相同方向的 或者 互相嵌套，换句话说就是嵌套的 / 必须是不同的方向。 举个例子，不允许一个垂直方向的 嵌套的一个垂直方向的 中，但是一个垂直方向的 是可以嵌套的一个水平方向的 或者 中的。 示例 {{item.label}} class Scroller { data = { /** * scroller 配置 */ bottomOffset: 20, scrollDirection: 'vertical', panels: [ ], rows: [] } methods = { change (e) { let target = e.currentTarget let dataset = target.dataset let i = dataset.idx const item = this.panels[i] if (item) { item.height = item.height === 200 ? 400 : 200 item.width = item.width === 330 ? 730 : 330 item.computedStyle = this.$cmlStyle(`height:${item.height}cpx;width:${item.width}cpx;background-color:${item.bgc};opacity:${item.opacity}`) } }, randomfn () { let ary = []; for(let i = 1; i .container { position: absolute; top: 0; left: 0; right: 0; bottom: 0; } .title { text-align: center; flex-direction: row; justify-content: center; } .panel { display: flex; margin: 10cpx; top:10cpx; align-items: center; justify-content: center; text-align: center; border: 1px solid #666; border-radius: 10cpx; transition-property: width,height; transition-duration: 0.5s; transition-delay: 0s; transition-timing-function: cubic-bezier(0.25, 0.1, 0.25, 1.0); } .cell{ display: flex; background-color:white; flex-direction: row; } .text { font-size: 60cpx; color: white; } { \"base\": {}, \"wx\": {} } wx web native Bug & Tip 使用竖向滚动时，需要有一个固定高度。 如果子组件的总高度高于其本身，那么所有的子组件都可滚动。 可以当作根元素或者嵌套元素使用。 中不可以使用 、 组件。 中不建议在上面加class改变样式，可以通过cstyle属性传入内联样式。 的子组件定位无效。 "},"component/base/layout/list.html":{"url":"component/base/layout/list.html","title":"list","keywords":"","body":"list 可滚动长列表。 标签内可包含多条 ，适合用于长列表的展示。 使用文档 cell。 属性 属性名 类型 必填 默认值 说明 height Number 必传 0 定义滚动区域的高度 注意： 1、 height=\"{{100}}\" /> 这样传值才是Number类型 2、height为-1时， 的可滚动区域高度为list放置点至页面底部 bottom-offset Number 否 0 距底部/右边多远时（单位cpx），触发 onBottom 事件 cstyle String 否 自定义组件内联样式 to-element String 否 滚动到的元素，仅支持ref(web、weex端) bounce Boolean 否 true 上拉下拉是否回弹(仅支持web) c-bind:scrolltobottom EventHandle 否 滚动到底部，会触发 scrolltobottom 事件 返回事件对象： event.type= \"scrolltobottom\" event.detail = { direction } c-bind:onscroll EventHandle 否 滚动时触发， 返回事件对象： event.type = 'scroll' event.detail = {scrollLeft, scrollTop, scrollHeight, scrollWidth, deltaX, deltaY} 限制 不允许相同方向的 或者 互相嵌套，换句话说就是嵌套的 / 必须是不同的方向。 举个例子，不允许一个垂直方向的 嵌套的一个垂直方向的 中，但是一个垂直方向的 是可以嵌套的一个水平方向的 list 或者 中的。 示例 {{item}} import cml from 'chameleon-api' const LOADMORE_COUNT = 4 class List { data = { /** * list 配置 子元素必须是 cell 标签 */ bottomOffset: 20, lists: [1, 2, 3, 4, 5, 6, 7, 8, 9, 10] } methods = { onBottom(e) { cml.showToast({ message: \"loadmore\", duration: 1000 }); setTimeout(() => { const length = this.lists.length for (let i = length; i .container { position: absolute; top: 88cpx; left: 0; right: 0; bottom: 0; } .panel { display: flex; width: 600cpx; height: 300cpx; margin-left: 75cpx; margin-top: 35cpx; margin-bottom: 35cpx; flex-direction: column; justify-content: center; border-width: 2px; border-style: solid; border-color: rgb(162, 217, 192); background-color: rgba(162, 217, 192, 0.2); } .text { font-size: 88cpx; text-align: center; color: #41B883; } { \"base\": {} } wx web native Bug & Tip 组件的父容器必须为可定位元素， 内容的布局由父容器决定。 中不可以使用 、 组件。 中不建议在上加class改变样式，可以通过cstyle属性传入内联样式。 的子组件定位无效。 "},"component/base/layout/container.html":{"url":"component/base/layout/container.html","title":"container","keywords":"","body":"container 属性 属性名 类型 必填 默认值 说明 direction String 否 'row' container内布局组件的排列方式，默认是水平（row),可取值为 \b'row'或者 'column' main 属性名 类型 必填 默认值 说明 main-style String 否 '' 容器的样式 head 属性名 类型 必填 默认值 说明 head-style String 否 '' 容器的样式 foot 属性名 类型 必填 默认值 说明 foot-style String 否 '' 容器的样式 aside 属性名 类型 必填 默认值 说明 aside-style String 否 '' 容器的样式 示例 header main header main footer aside main header aside main header aside main foot aside header main aside header main footer class CLayout { } export default new CLayout(); { \"base\": {} } wx web native 查看完整示例 "},"component/base/layout/row.html":{"url":"component/base/layout/row.html","title":"row","keywords":"","body":"row 横向flex布局容器 是提供横向flex布局的容器，与 组件（提供纵向flex布局）结合使用，可快速构建整洁干净的flex布局效果。 row属性 属性名 类型 必填 默认值 说明 justify String 否 center 横向对齐方式，可选值包括：start/end/center/space-around/space-between align String 否 middle 纵向对齐方式，可选值包括：top/middle/bottom height Number 否 0 容器高度，值为0时容器高度由内部元素高度决定 wrap Boolean 否 false 是否支持换行 margin Number 否 0 容器上下间隔（单位cpx） 示例 class Row { } export default new Row(); { \"base\": {} } wx web native 查看完整示例 Bug & Tip 组件内部不一定要使用组件，可使用任何需要布局的容器或组件。 如果 组件内部不使用组件，需要自行设置内部的宽高等属性。 如果 组件内部使用组件，需要将组件设置为 组件的直接子节点。 和 组件组合使用类似栅格布局， 和 组件只能相互嵌套。 建议使用高度属性设置组件高度，而非使用css控制，否则垂直居中的样式可能会受到影响。 "},"component/base/layout/col.html":{"url":"component/base/layout/col.html","title":"col","keywords":"","body":"col 纵向flex布局容器 与 组件结合使用，可快速构建整洁干净的flex布局。 属性 属性名 类型 必填 默认值 说明 width Number 否 0 容器宽度，值为0时容器宽度由内部元素宽度决定 height Number 否 0 容器高度，值为0时容器高度由内部元素高度决定 background-color String 否 容器背景色 margin Number 否 0 容器左右间隔（单位cpx） 示例 class Col { } export default new Col(); .col-item { background: #aaa; width:200cpx; height:100cpx; } { \"base\": {} } wx web native 查看完整示例 "},"component/base/layout/carousel.html":{"url":"component/base/layout/carousel.html","title":"carousel","keywords":"","body":"carousel 轮播图。 标签内可包含多条 ，适合轮播图展示。 属性 属性名 类型 默认值 说明 autoplay Boolean false 是否自动切换 current Number 0 当前所在滑块的索引值 interval Number 5000 自动切换的时间间隔 circular Boolean false 是否采用衔接滑动 indicator-dots Boolean false 是否显示面板指示点 change EventHandle current 改变时会触发 change 事件，event.detail = {current: activeIndex} 示例 carousel class Carousel {} export default new Carousel(); .container { height: 300cpx; } .carousel-item { height: 300cpx; width: 750cpx; } { \"base\": { \"usingComponents\": {} } } wx web native Bug & Tip 如需兼容安卓端，carousel需要有一个固定高度。 "},"component/base/layout/carousel-item.html":{"url":"component/base/layout/carousel-item.html","title":"carousel-item","keywords":"","body":"carousel-item 轮播图子容器 仅可放置在组件中使用，使用文档请查看 carousel。 属性 无 "},"component/base/form/form.html":{"url":"component/base/form/form.html","title":"表单组件","keywords":"","body":"表单组件 button input textarea switch radio checkbox "},"component/base/form/button.html":{"url":"component/base/form/button.html","title":"button","keywords":"","body":"button 按钮 属性 属性名 类型 必填 默认值 说明 text String 否 \"确认\" 按钮文案 size String 否 \"none\" 按钮尺寸,可选值：full、big、medium、small type String 否 \"blue\" 按钮颜色,可选值：red、orange、blue、white、green disabled Boolean 否 false 是否禁用 btn-style String 否 自定义button的样式，样式字段采用驼峰或者短横线命名 text-style String 否 自定义按钮text的样式，样式字段采用驼峰或者短横线命名 disabled-style String 否 定义button disabled的样式，样式字段采用驼峰或者短横线命名 open-type String 否 微信开放能力，只支持wx端 lang String 否 \"en\" 指定返回用户信息的语言，有效值：zh_CN 简体中文，zh_TW 繁体中文，en 英文 open-type=\"getUserInfo\"时生效 c-bind:getuserinfo Handler 否 用户点击该按钮时，会返回获取到的用户信息 open-type=\"getUserInfo\"时生效 session-from String 否 会话来源 open-type=\"contact\"时生效 send-message-title String 否 \"当前标题\" 会话内消息卡片标题 open-type=\"contact\"时生效 send-message-path String 否 \"当前分享路径\" 会话内消息卡片点击跳转小程序路径 open-type=\"contact\"时生效 send-message-img String 否 截图 会话内消息卡片图片 open-type=\"contact\"时生效 show-message-card Boolean 否 false 是否显示会话内消息卡片 open-type=\"contact\"时生效 c-bind:contact Handler 否 客服消息回调 open-type=\"contact\"时生效 c-bind:getphonenumber Handler 否 获取用户手机号回调 open-type=\"getPhoneNumber\"时生效 app-parameter String 否 打开APP时，向APP传递的参数 open-type=\"launchApp\"时生效 c-bind:error Handler 否 当使用开放能力时，发生错误的回调 open-type=\"launchApp\"时生效 c-bind:opensetting Handler 否 在打开授权设置页后回调 open-type=\"openSetting\"时生效 c-bind:onclick EventHandle 否 button 点击事件 返回事件对象： event.type= \"onclick\" event.detail = { type, disabled } open-type 的有效值 值 说明 contact 打开客服会话，如果用户在会话中点击消息卡片后返回小程序，可以从 c-bind:contact 回调中获取到用户所点消息的页面路径 path 和对应的参数 query share 触发用户转发 getUserInfo 获取用户信息，可以从c-bind:getuserinfo回调中获取到用户信息 getPhoneNumber 获取用户手机号，可以从c-bind:getphonenumber回调中获取到微信服务器返回的加密数据 launchApp 打开APP，可以通过app-parameter属性设定向APP传的参数，通过 c-bind:error 可以监听打开 APP 的错误事件 openSetting 打开授权设置页 feedback 打开“意见反馈”页面 示例 import cml from 'chameleon-api' class Button { methods = { testclick(e) { let type = e.detail.type cml.showToast({ message: type + ' button' }) } } } export default new Button(); { \"base\": {} } wx web native 查看完整示例 "},"component/base/form/input.html":{"url":"component/base/form/input.html","title":"input","keywords":"","body":"input 输入框 属性 属性名 类型 必填 默认值 说明 value String 否 输入框的初始内容 type String 否 \"text\" 输入框的类型 placeholder String 否 提示用户输入的内容 disabled Boolean 否 false 是否禁用 focus Boolean 否 false 获取焦点（web端不支持） maxlength Number 否 140 最大输入长度 return-key-type String 否 \"done\" 设置键盘右下角按钮的文字（web端不支持） placer-holder-color String 否 \"#bebebe\" 指定placeholder的颜色（web端不支持） c-style String 否 自定义样式,样式字段采用驼峰或者短横线命名 maxValue Number 否 Infinity 最大值 仅对type=\"number\"生效 minValue Number 否 -Infinity 最小值 仅对type=\"number\"生效 c-bind:input EventHandle 否 键盘输入时触发 返回事件对象： event.type=\"input\", event.detail={value} c-bind:confirm EventHandle 否 点击完成按钮时触发 返回事件对象： event.type=\"confirm\", event.detail c-bind:focus EventHandle 否 输入框获取焦点时触发 返回事件对象： event.type=\"focus\", event.detail c-bind:blur EventHandle 否 输入框失去焦点时触发 返回事件对象： event.type=\"blur\" event.detail type 的有效值： 值 说明 text 文本类型的输入 password 密码类型的输入 number 数字类型的输入 return-key-type 的有效值： 值 说明 done 右下角按钮为“完成” search 右下角按钮为“搜索” next 右下角按钮为“下一个” go 右下角按钮为“前往” 示例 class Input { data = { isfocus: false } computed = {} watch = {} methods = { bindblurevent() { console.log('blur'); this.isfocus = false; } } mounted = function(res) { setTimeout(() => { this.isfocus = true; }, 300); } }; export default new Input(); { \"base\": {} } wx web native 查看完整示例 Bug & Tip web端不支持自动focus return-key-type字段web端不支持 "},"component/base/form/textarea.html":{"url":"component/base/form/textarea.html","title":"textarea","keywords":"","body":"textarea 多行输入框 属性 属性名 类型 必填 默认值 说明 value String 否 多行输入框的初始内容 type String 否 \"text\" 多行输入框的类型 placeholder String 否 提示用户输入的内容 disabled Boolean 否 false 是否禁用 focus Boolean 否 false 获取焦点（web端不支持） maxlength Number 否 140 最大输入长度 return-key-type String 否 \"done\" 设置键盘右下角按钮的文字（web端不支持） placer-holder-color String 否 “#666” 指定placeholder的颜色（web端不支持） c-style String 否 自定义样式,样式字段采用驼峰或者短横线命名 rows Number 否 2 text-area行数，weex、web端生效 c-bind:input EventHandle 否 键盘输入时触发 返回事件对象： event.type=\"input\", event.detail={value} c-bind:confirm EventHandle 否 点击完成按钮时触发 返回事件对象： event.type=\"confirm\", event.detail c-bind:focus EventHandle 否 输入框获取焦点时触发 返回事件对象： event.type=\"focus\", event.detail c-bind:blur EventHandle 否 输入框失去焦点时触发 返回事件对象： event.type=\"blur\", event.detail type 的有效值： 值 说明 text 文本类型的输入 password 密码类型的输入 number 数字类型的输入 return-key-type 的有效值： 值 说明 done 右下角按钮为“完成” search 右下角按钮为“搜索” next 右下角按钮为“下一个” go 右下角按钮为“前往” 示例 class Textarea { data = { isfocus: false } methods = { bindblurevent() { console.log('blur') this.isfocus = false; } } mounted = function(res) { setTimeout(() => { this.isfocus = true; }, 300); } }; export default new Textarea(); { \"base\": {} } wx web native 查看完整示例 Bug & Tip wx端不能包裹在里面 web端不支持自动focus return-key-type字段web端不支持 "},"component/base/form/switch.html":{"url":"component/base/form/switch.html","title":"switch","keywords":"","body":"switch 开关 属性 属性名 类型 必填 默认值 说明 checked Boolean 否 关闭 是否开启switch按钮 label String 否 按钮文案 disabled Boolean 否 false 是否禁用 c-bind:change EventHandle 否 点击按钮触发 返回事件对象： event.detail 返回值： event.detail.value 示例 class Switch { data = { switchValue: false } methods = { switchChange (e) { this.switchValue = e.detail.value } } }; export default new Switch(); { \"base\": {} } wx web native 查看完整示例 "},"component/base/form/radio.html":{"url":"component/base/form/radio.html","title":"radio","keywords":"","body":"radio 单选框 属性 属性名 类型 必填 默认值 说明 checked Boolean 否 关闭 是否开启 label String 否 单选框文案 disabled Boolean 否 false 是否禁用 position String 否 left 单选框相对于文案的位置，可选值包括：left、right group-index Number 否 -1 表示在radio-group中的索引 c-bind:change EventHandle 否 点击单选框触发 返回事件对象： event.detail 返回值： event.detail.value 示例 class Index { data = { radioValue: false } methods = { valueChange (e) { this.radioValue = e.detail.value; } } } export default new Index(); { \"base\": {} } wx web native 查看完整示例 "},"component/base/form/checkbox.html":{"url":"component/base/form/checkbox.html","title":"checkbox","keywords":"","body":"checkbox 复选框 属性 属性名 类型 必填 默认值 说明 checked Boolean 否 关闭 是否开启 label String 否 复选框文案 disabled Boolean 否 false 是否禁用 position String 否 left 复选框相对于文案的位置，可选值包括：left、right group-index Number 否 -1 表示在checkbox-group中的索引 c-bind:change EventHandle 否 点击复选框触发 返回事件对象： event.detail 返回值： event.detail.value 示例 class Checkbox { data = { checkboxValue: true } methods = { valueChange (e) { this.checkboxValue = e.detail.value } } }; export default new Checkbox(); { \"base\": {} } wx web native 查看完整示例 "},"component/base/media/media.html":{"url":"component/base/media/media.html","title":"媒体组件","keywords":"","body":"媒体组件 image video "},"component/base/media/image.html":{"url":"component/base/media/image.html","title":"image","keywords":"","body":"image 图片 属性 属性名 类型 必填 默认值 说明 src String 否 图片资源地址，支持本地路径和网络图片资源 c-bind:onload EventHandle 否 当图片载入完成时触发 返回事件对象: event.type= \"onload\" event.detail = { height,width } c-bind:onerror EventHandle 否 当图片发生错误时触发 返回事件对象: event.type = \"onerror\" 示例 class Image { data = { imageSrc: require('../../../assets/images/chameleon.jpg') } methods = { imageLoad(e){}, imageError(e){} } } export default new Image(); .container { display: flex; flex-direction: column; align-items: center; } { \"base\": {} } wx web native 查看完整示例 "},"component/base/media/video.html":{"url":"component/base/media/video.html","title":"video","keywords":"","body":"video 视频播放器 属性 属性名 类型 必填 默认值 说明 src String 否 要播放视频的资源地址 autoplay Boolean 否 false 是否自动播放 controls Boolean 否 false 是否显示默认播放控件（播放/暂停按钮、播放进度、时间）（只对wx有效） c-bind:start EventHandle 否 当开始/继续播放时触发start事件 c-bind:pause EventHandle 否 当暂停播放时触发 pause 事件 c-bind:finish EventHandle 否 当播放到末尾时触发 finish 事件 c-bind:fail EventHandle 否 视频播放出错时触发 fail 示例 import cml from 'chameleon-api' class Video { data = { videoSrc: 'http://wxsnsdy.tc.qq.com/105/20210/snsdyvideodownload?filekey=30280201010421301f0201690402534804102ca905ce620b1241b726bc41dcff44e00204012882540400&bizid=1023&hy=SH&fileparam=302c020101042530230204136ffd93020457e3c4ff02024ef202031e8d7f02030f42400204045a320a0201000400', state: '----', } } export default new Video(); .video { width: 720cpx; height: 350cpx; margin-top: 60cpx; } { \"base\": {} } wx web native Bug & Tip 是唯一合法的子组件。 查看完整示例 "},"component/expand/expand.html":{"url":"component/expand/expand.html","title":"扩展组件","keywords":"","body":"扩展组件 扩展组件需要额外引入。如： { \"base\": { \"usingComponents\": { \"c-dialog\": \"cml-ui/components/c-dialog/c-dialog\" } } } 分类 说明 多态组件 使用基于多态协议扩展的最底层组件 复合组件 普通业务功能的聚合，调用多态组件或者复合组件进行功能封装 扩展原生组件 native 原生解析渲染，灵活定制、跨端兼容 * [多态组件](/component/expand/polymorphism/polymorphism.html) * [复合组件](/component/expand/compound/compound.html) * [扩展原生组件](/component/expand/native/native.html) --> 资料：cml-ui chameleon 扩展组件库。 "},"component/expand/compound/c-toast.html":{"url":"component/expand/compound/c-toast.html","title":"c-toast","keywords":"","body":"c-toast 提示框 属性 属性名 类型 必填 默认值 说明 message String 是 提示框提示的内容 duration Number 否 3000 提示的延迟时间，单位为毫秒 type String 否 “loading” 提示框的类型，有效值：loading/success/warn mask Boolean 否 false 是否显示透明蒙层 show Boolean 否 false 是否显示 need-icon Boolean 否 true 是否显示图标 示例 class C_toast { } export default new C_toast(); { \"base\": { \"usingComponents\": { \"c-toast\": \"cml-ui/components/c-toast/c-toast\" } } } wx web native 查看完整示例 "},"component/expand/compound/c-loading.html":{"url":"component/expand/compound/c-loading.html","title":"c-loading","keywords":"","body":"c-loading 加载中 属性 属性名 类型 必填 默认值 说明 tip String 否 'loading...' 描述文案 loading Boolean 否 true 是否为加载中状态 示例1 注： 使用此模式时，请将c-loading组件放在所有元素的最后，如使用router-view，请放在router-view后面 { \"base\": { \"usingComponents\": { \"c-loading\": \"cml-ui/components/c-loading/c-loading\" } } } wx web native 示例2 class CLoading { } export default new CLoading(); { \"base\": { \"usingComponents\": { \"c-loading\": \"cml-ui/components/c-loading/c-loading\" } } } wx web native "},"component/expand/compound/c-dialog.html":{"url":"component/expand/compound/c-dialog.html","title":"c-dialog","keywords":"","body":"c-dialog 对话框 属性 属性名 类型 必填 默认值 说明 title String 是 对话框提示的标题 content String 是 对话框提示的内容 type String 否 alert 对话框的类型，有效值：alert/confirm cancel-text String 否 “取消” 取消按钮的文字 confirm-text String 否 “确定” 确认按钮的文字 icon-type String 否 “warn” 图标，有效值success/warn icon-url String 否 图标地址 icon-style Object 否 图标的样式 mask Boolean 否 true 是否显示透明蒙层 show Boolean 否 false 开启打开alert类型对话框 show-close Boolean 否 false 是否显示close关闭图标 c-bind:show EventHandle 否 开启alert类型对话框时触发返回事件对象：event.type=\"changeShow\",e.detail={value} c-bind:cancel EventHandle 否 用户点击cancel时触发返回事件对象：event.type=\"cancelEvent\" c-bind:confirm EventHandle 否 用户点击confirm时触发返回事件对象：event.type=\"confirmEvent\" c-bind:close EventHandle 否 点击close图标时触发返回事件对象： event.type=\"closeEvent\" 示例 class C_dialog { } export default new C_dialog(); { \"base\": { \"usingComponents\": { \"c-dialog\": \"cml-ui/components/c-dialog/c-dialog\" } } } wx web native 查看完整示例 "},"component/expand/compound/c-popup.html":{"url":"component/expand/compound/c-popup.html","title":"c-popup","keywords":"","body":"c-popup 蒙层 属性 属性名 类型 必填 默认值 说明 mask Boolean 否 true 是否显示透明蒙层 show Boolean 是 false 开启打开popup center Boolean 否 true 内容是否垂直水平居中 position String 否 内容展示位置，优先级比center高，可选值left/top/right/bottom c-bind:close EventHandle 否 点击蒙层时触发 示例 class C_popup { } export default new C_popup(); { \"base\": { \"usingComponents\": { \"c-popup\": \"cml-ui/components/c-popup/c-popup\" } } } wx web native 查看完整示例 "},"component/expand/compound/c-tip.html":{"url":"component/expand/compound/c-tip.html","title":"c-tip","keywords":"","body":"c-tip 提示 属性 属性名 类型 必填 默认值 说明 show Boolean 否 false 提示框是否显示 direction String 否 top 提示框所在位置，可选值top/right/bottom/left offset-left Number 否 小三角之Tip左边距离 offset-top Number 否 小三角之Tip顶部距离 offset-right Number 否 小三角之Tip右边距离 offset-bottom Number 否 小三角之Tip底部距离 c-bind:close EventHandle 点击关闭按钮触发 注意：Tip小三角默认是居中显示的，当direction值为top或bottom时，如果offset-left或offset-right有值且不是NaN，则小三角的距离为传入值 示例 Tip Awesome! class CTip { } export default new CTip(); { \"base\": { \"usingComponents\": { \"c-tip\": \"cml-ui/components/c-tip/c-tip\" } } } wx web native 查看完整示例 "},"component/expand/compound/c-actionsheet.html":{"url":"component/expand/compound/c-actionsheet.html","title":"c-actionsheet","keywords":"","body":"c-actionsheet 操作列表 属性 属性名 类型 必填 默认值 说明 title String 否 标题 操作列表标题 list Array 是 [] 操作列表数据，如['action1', 'action2'] active Number 当前选中元素索引，从0开始 show Boolean 否 false 操作列表是否显示 cancel-txt String 否 取消 取消按钮文本 header-style String 否 标题自定义样式 cancel-style String 否 取消按钮自定义样式 content-style String 否 普通操作样式 active-style String 否 当前选中操作样式 c-bind:select EventHandle 否 点击操作时触发，event.detail = { index, value } c-bind:cancel EventHandle 否 点击取消或蒙层时触发 示例 class C_actionsheet { data = { list: [\"高铁\", \"火车\", \"飞机\", \"打车\", \"地铁\"], title: \"出行方式\" } } export default new C_actionsheet(); { \"base\": { \"usingComponents\": { \"c-actionsheet\": \"cml-ui/components/c-actionsheet/c-actionsheet\" } } } wx web native 查看完整示例 "},"component/expand/compound/c-tab.html":{"url":"component/expand/compound/c-tab.html","title":"c-tab","keywords":"","body":"c-tab 属性 属性名 类型 必填 默认值 说明 tabs Array 是 [] tabs显示内容数组，tabs中数组中具体的值请看tabs详情 active-label String 是 tabs数组中的某一个label的值 注意必须和tabs数组中某一个label的值相等 inline Boolean 否 true 代表每一个tab栏的 \b前置icon + tab内容 + 后置icon 的排列方向，默认水平排列 line-style String 否 '' 标识tab栏的下划标志线的样式 active-label-style String 否 \"color:#FC9153\" 标识tab栏激活后的文案的样式 has-underline Boolean 否 true 是否需要下划线 active-icon-style String 否 '' label前缀icon或者后缀icon激活后的样式 事件 事件名 描述 事件参数中detail对象 tabclick 点击每个tab时候出发的事件名称 label:表示激活tab的文案,activeIndex:表示激活tab的索引 tabs数组具体属性详情 属性名 类型 必填 默认值 说明 label String 是 tabs数组中的某一个label的值 注意必须和tabs数组中某一个label的值相等 labelStyle String 否 外部传入控制每一个tab栏的文案样式 prefixStyle String 否 外部传入控制每一个tab栏的前缀样式 suffixStyle String 否 外部传入控制每一个tab栏的后缀样式 c-tab-pane 属性 属性名 类型 必填 默认值 说明 tabs Array 是 [] tabs显示内容数组，tabs中数组中具体的值请看tabs详情 active-label String 是 tabs数组中的某一个label的值 注意必须和tabs数组中某一个label的值相等 注意，如果c-tab-pane组件配合c-tabs组件使用，那么二者的tabs和active-label属性必须引用同一个值；每个c-tab-pane组件下，同时对应一个c-tab-pane-item组件； c-tab-pane-item 用于提供一个可以容纳每个pane的容器,宽度 750cpx; 示例 单tab案例 tab+pane案例 {{item.label}} --> 1 2 3 4 { \"base\": { \"usingComponents\": { \"c-tab\": \"cml-ui/components/c-tab/c-tab\", \"c-tab-pane\": \"cml-ui/components/c-tab-pane/c-tab-pane\", \"c-tab-pane-item\": \"cml-ui/components/c-tab-pane-item/c-tab-pane-item\" } } } wx web native 查看完整示例 "},"component/expand/compound/c-picker.html":{"url":"component/expand/compound/c-picker.html","title":"c-picker","keywords":"","body":"c-picker 底部弹起的滚动选择器 属性 属性名 类型 必填 默认值 说明 show Boolean 是 false 是否点击打开滚动选择器 title String 否 \"请选择\" 滚动选择器的标题 header-height Number 是 100 滚动选择器标题栏的高度 data-height Number 是 400 滚动选择器数据栏的高度 data Array 是 滚动选择器滚动的数据 default-index Number 是 0 滚动选择器默认的数据索引 text-align String 是 \"center\" 滚动选择器的文本样式:\"居中\" cancel-btn-style String 否 自定义取消按钮的样式，样式字段采用驼峰或者短横线命名 confirm-btn-style String 否 自定义确定按钮的样式,样式字段采用驼峰或者短横线命名 c-bind:cancel EventHandle 否 用户点击\"取消\"时触发:返回事件对象:event.type=\"cancel\" c-bind:confirm EventHandle 否 用户点击\"确定\"时触发:返回事件对象:event.type=\"confirm\" c-bind:selectchange EventHandle 是 选择器滚动时触发: 返回事件对象: event.type=\"selectchange\" event.detail = {index} 示例 点击选择：{{provins[provinsIndex]}} class CPicker { data = { provins: [ \"北京市\", \"天津市\", \"河北省\", \"山西省\", \"内蒙古\", \"辽宁省\", \"吉林省\", \"黑龙江省\", \"上海市\", \"江苏省\", \"浙江省\", \"安徽省\", \"福建省\", \"江西省\", \"山东省\", \"河南省\", \"湖北省\", \"湖南省\", \"广东省\", \"广西\", \"海南省\", \"重庆市\", \"四川省\", \"贵州省\", \"云南省\", \"西藏\", \"陕西省\", \"甘肃省\", \"青海\", \"宁夏\", \"新疆\" ], defaultIndex: 0, provinsIndex: 0, pickerShow: false } computed = {} watch = {} methods = { selectchange(e) { this.provinsIndex = this.defaultIndex = e.detail.index; }, showClick() { this.pickerShow = true; }, cancel() { this.pickerShow = false; }, confirm() { this.pickerShow = false; } } beforeCreate() {} created() {} beforeMount() {} mounted() {} beforeDestroy() {} destroyed() {} } export default new CPicker(); .container { background: #f8f8f8; } .page-demo { background: #fafafa; } .title-text { color: #999; margin: 30cpx 20cpx 10cpx; display: block; font-size: 28cpx; } .picker-item { background: #fff; border-top: 1px solid #d9d9d9; border-bottom: 1px solid #d9d9d9; display: flex; flex-direction: row; } .picker-text-left { font-size: 40cpx; height: 70cpx; line-height: 70cpx; margin-left: 20cpx; width: 300cpx; } .picker-text-right { font-size: 40cpx; height: 70cpx; line-height: 70cpx; margin-left: 20cpx; flex: 1; text-align: center; } .select-text { font-size: 32cpx; text-align: center; display: flex; justify-content: center; align-items: center; } { \"base\": { \"usingComponents\": { \"c-picker\": \"cml-ui/components/c-picker/c-picker\" } }, \"wx\": {} } wx web native "},"component/expand/polymorphism/c-picker-panel.html":{"url":"component/expand/polymorphism/c-picker-panel.html","title":"c-picker-panel","keywords":"","body":"c-picker-panel 从底部弹起的控制板。 属性 属性名 类型 必填 默认值 说明 show Boolean 是 false 是否点击打开底部控制板 title String 否 \"请选择\" 控制板的标题 header-height Number 是 100 底部控制板标题栏的高度 cancel-btn-style String 否 自定义取消按钮的样式，样式字段采用驼峰或者短横线命名 confirm-btn-style String 否 自定义确定按钮的样式,样式字段采用驼峰或者短横线命名 c-bind:cancel EventHandle 否 用户点击\"取消\"时触发:返回事件对象:event.type=\"cancel\" c-bind:confirm EventHandle 否 用户点击\"确定\"时触发:返回事件对象:event.type=\"confirm\" 示例 c-picker-panel 点击选择：{{provins[provinsIndex]}} import { provins } from \"./data\"; class CPickerPanel { data = { provins: [ \"北京市\", \"天津市\", \"河北省\", \"山西省\", \"内蒙古\", \"辽宁省\", \"吉林省\", \"黑龙江省\", \"上海市\", \"江苏省\", \"浙江省\", \"安徽省\", \"福建省\", \"江西省\", \"山东省\", \"河南省\", \"湖北省\", \"湖南省\", \"广东省\", \"广西\", \"海南省\", \"重庆市\", \"四川省\", \"贵州省\", \"云南省\", \"西藏\", \"陕西省\", \"甘肃省\", \"青海\", \"宁夏\", \"新疆\" ], defaultIndex: 0, provinsIndex: 0, panelShow: false } computed = {} watch = {} methods = { selectchange(e) { this.provinsIndex = this.defaultIndex = e.detail.index; }, showClick() { this.panelShow = true; }, cancel() { this.panelShow = false; }, confirm() { this.panelShow = false; } } beforeCreate() {} created() {} beforeMount() {} mounted() {} beforeDestroy() {} destroyed() {} } export default new CPickerPanel(); .container { background: #f8f8f8; position: absolute; top: 88cpx; bottom: 0; left: 0; right: 0; } .page-demo { background: #fafafa; position: absolute; top: 0; bottom: 0; left: 0; right: 0; } .title-text { color: #999; margin: 30cpx 20cpx 10cpx; display: block; font-size: 28cpx; } .picker-item { background: #fff; border-top: 1px solid #d9d9d9; border-bottom: 1px solid #d9d9d9; display: flex; flex-direction: row; } .picker-text-left { font-size: 40cpx; height: 70cpx; line-height: 70cpx; margin-left: 20cpx; width: 300cpx; } .picker-text-right { font-size: 40cpx; height: 70cpx; line-height: 70cpx; margin-left: 20cpx; flex: 1; text-align: center; } .select-text { font-size: 32cpx; text-align: center; display: flex; justify-content: center; align-items: center; } { \"base\": { \"usingComponents\": { \"c-picker-panel\": \"cml-ui/components/c-picker-panel/c-picker-panel\", \"c-picker-item\": \"cml-ui/components/c-picker-item/c-picker-item\" } }, \"wx\": {} } wx web native "},"component/expand/polymorphism/c-picker-item.html":{"url":"component/expand/polymorphism/c-picker-item.html","title":"c-picker-item","keywords":"","body":"c-picker-item 滚动选择器 属性 属性名 类型 必填 默认值 说明 data Array 是 [''] 滚动选择器滚动的数据 default-index Number 是 0 滚动选择器默认的数据索引 height Number 是 400 滚动选择器的高度 text-align String 是 \"center\" 滚动选择器的文本样式:\"居中\" c-bind:selectchange EventHandle 是 选择器滚动时触发: 返回事件对象: event.type=\"selectchange\" event.detail = {index} 示例 选择的值：{{provins[provinsIndex]}} import { provins } from \"./data\"; class CPickerItem { data = { provins: [ \"北京市\", \"天津市\", \"河北省\", \"山西省\", \"内蒙古\", \"辽宁省\", \"吉林省\", \"黑龙江省\", \"上海市\", \"江苏省\", \"浙江省\", \"安徽省\", \"福建省\", \"江西省\", \"山东省\", \"河南省\", \"湖北省\", \"湖南省\", \"广东省\", \"广西\", \"海南省\", \"重庆市\", \"四川省\", \"贵州省\", \"云南省\", \"西藏\", \"陕西省\", \"甘肃省\", \"青海\", \"宁夏\", \"新疆\" ], defaultIndex: 0, provinsIndex: 0 } computed = {} watch = {} methods = { selectchange(e) { this.provinsIndex = this.defaultIndex = e.detail.index; } } beforeCreate() {} created() {} beforeMount() {} mounted() {} beforeDestroy() {} destroyed() {} } export default new CPickerItem(); .container { background: #f8f8f8; } .page-demo { background: #fafafa; } .title-text { color: #999; margin: 30cpx 20cpx 10cpx; display: block; font-size: 28cpx; } .picker-item { background: #fff; border-top: 1px solid #d9d9d9; border-bottom: 1px solid #d9d9d9; display: flex; flex-direction: row; } .picker-text-left { font-size: 40cpx; height: 70cpx; line-height: 70cpx; margin-left: 20cpx; width: 300cpx; } .picker-text-right { font-size: 40cpx; height: 70cpx; line-height: 70cpx; margin-left: 20cpx; flex: 1; text-align: center; } .select-text { font-size: 32cpx; text-align: center; display: flex; justify-content: center; align-items: center; } { \"base\": { \"usingComponents\": { \"c-picker-item\": \"cml-ui/components/c-picker-item/c-picker-item\" } }, \"wx\": {} } wx web native "},"component/expand/compound/c-checkbox-group.html":{"url":"component/expand/compound/c-checkbox-group.html","title":"c-checkbox-group","keywords":"","body":"c-checkbox-group 复选框列表 属性 属性名 类型 必填 默认值 说明 option Array 是 [] 选项数组 horizontal Boolean 否 false 单选框排列方向，默认纵向排列 position String 否 left 按钮相对于文案的位置，可选值包括：left、right c-bind:groupchange EventHandle 否 点击按钮出发 返回事件对象： event.detail 返回值： event.detail.value - 修改后的选项数组 event.detail.index - 修改的复选框索引 event.detail.selected - 选中的项目文案数组 示例 class CCheckbox { data = { checkboxGroupOption: [{ checked: true, label: 'one', disabled: true }, { checked: false, label: 'two' }, { checked: false, label: 'three' }], selected: 'one', } methods = { groupChangeHandler (e) { this.checkboxGroupOption = e.detail.value this.selected = e.detail.selected.join(', ') } } } export default new CCheckbox(); { \"base\": { \"usingComponents\": { \"c-checkbox-group\": \"cml-ui/components/c-checkbox-group/c-checkbox-group\" } } } wx web native 查看完整示例 "},"component/expand/compound/c-radio-group.html":{"url":"component/expand/compound/c-radio-group.html","title":"c-radio-group","keywords":"","body":"c-radio-group 单选框列表 属性 属性名 类型 必填 默认值 说明 option Array 是 [] 选项数组 horizontal Boolean 否 false 单选框排列方向，默认纵向排列 position String 否 left 按钮相对于文案的位置，可选值包括：left、right c-bind:groupchange EventHandle 否 点击按钮出发 返回事件对象： event.detail 返回值： event.detail.value - 修改后的选项数组 event.detail.index - 修改的单选框索引 示例 class CRadio { data = { radioGroupOption: [ { checked: false, label: 'Option1', }, { checked: false, label: 'Option2' }, { checked: false, label: 'Option3', disabled: true } ], radioSelect: '' } methods = { groupChangeHandler (e) { this.radioSelect = this.radioGroupOption[e.detail.index].label } } } export default new CRadio(); { \"base\": { \"usingComponents\": { \"c-radio-group\": \"cml-ui/components/c-radio-group/c-radio-group\" } } } wx web native 查看完整示例 "},"component/expand/polymorphism/c-refresh.html":{"url":"component/expand/polymorphism/c-refresh.html","title":"c-refresh","keywords":"","body":"c-refresh 上拉&下拉刷新 属性 属性名 类型 必填 默认值 说明 display Boolean 否 false 是否显示上拉&下拉 direction String 否 top 上拉或者下拉，top表示下拉刷新，bottom表示上拉刷新 custom-ui Boolean 否 false 是否要自定义ui, 选择自定义ui需要可在c-refresh标签内部布局和定义 c-bind:refreshevent EventHandle 是 下拉或上拉时出发: 返回事件对象: event.detail 返回值： event.detail.value 示例 {{item.label}} = sumPage }}\">没有更多了... 上拉刷新... import cml from 'chameleon-api' class Refresh { data = { topRefreshing:false, bottomRefreshing: false, bottomOffset: 20, scrollDirection: 'vertical', panels: [ ], rows: [], sumPage: 4, page: 0, loadingTextStyle: '' } methods = { getPanels (direction) { if (this.page >= this.sumPage) return let rows = this.randomfn() this.panels = direction == 1 ? [...this.panels, ...rows]: [...rows, ...this.panels]; this.page++; }, onrefreshUp (e) { this.topRefreshing = e.detail.value setTimeout(() => { this.getPanels(-1) this.topRefreshing = false }, 2000) }, onrefreshDown (e) { this.bottomRefreshing = e.detail.value setTimeout(() => { this.getPanels(1) this.bottomRefreshing = false }, 2000) }, change (e) { let target = e.currentTarget let dataset = target.dataset let i = dataset.idx const item = this.panels[i] if (item) { item.height = item.height === 200 ? 400 : 200 item.width = item.width === 330 ? 730 : 330 item.computedStyle = `height:${item.height}cpx;width:${item.width}cpx;background-color:${item.bgc};opacity:${item.opacity}` } }, randomfn () { let ary = []; for(let i = 1; i= this.sumPage) return this.bottomRefreshing = true; } } created(res) { this.getPanels() this.loadingTextStyle = 'color:#999;font-size:36cpx;margin:30cpx 0;' } } export default new Refresh(); .container { flex: 1; } .title { text-align: center; flex-direction: row; justify-content: center; } .panel { display: flex; margin: 10cpx; top:10cpx; align-items: center; justify-content: center; text-align: center; border: 1px solid #666; border-radius: 10cpx; transition-property: width,height; transition-duration: 0.5s; transition-delay: 0s; transition-timing-function: cubic-bezier(0.25, 0.1, 0.25, 1.0); } .cell{ display: flex; background-color:white; flex-direction: row; } .text { font-size: 60cpx; color: white; } .no-more-text { color: #999; font-size: 36cpx; text-align: center; margin:50cpx 0; display: flex; justify-content: center; flex-direction: row; align-items: center; } { \"base\": { \"usingComponents\": { \"c-refresh\": \"cml-ui/components/c-refresh/c-refresh\" } }, \"wx\": {} } wx web native Bug & Tip 组件必须定义在或组件内部, 并且在垂直方向上才能生效。 组件使用时建议将或组件进行fixed的定位，否则下拉效果失效。 "},"extend/advanced_use.html":{"url":"extend/advanced_use.html","title":"高级使用","keywords":"","body":"高级使用 工程化 导入与导出 Native渲染能力接入 定制扩展端 "},"framework/polymorphism/intro.html":{"url":"framework/polymorphism/intro.html","title":"多态协议","keywords":"","body":"多态协议 定义标准接口(interface)，各端模块各自独立实现，编译时和运行时对实现的接口输入输出做检查。 主要2个目标： 保障多端可维护性 编译时拆分多端代码 Chameleon的是多端的上层应用语言，在这样的目标下，用户扩展功能时，保障业务代码和各端通信一致性变得特别重要。 用户也许只实现一个API跨2端，保障一致很简单，在一个超过5万行代码的复杂应用里，用户扩展了100个接口呢，如果你觉得还很简单，那跨6个端呢，在应用持续高速迭代中让用户人肉保障多端一致性实在太艰难，即使能做到，可维护性也会极差，跨端也会失去意义。 以上，跨端很美好，最大风险是可维护性问题。多态协议是Chameleon业务层代码和各端底层组件和接口的分界点，Chameleon会严格“管制”输入输出值的类型和结构，同时会严格检查业务层JS代码，避免直接使用某端特有的接口，不允许在公共代码处使用某个端特定的方法，即使这段代码不会执行，例如禁止使用window、wx、weex等方法。 统一多态协议设计的灵感来自于Apache Thrift - 可伸缩的跨语言服务开发框架，本质上跨端也属于跨语言。 它能让Chameleon开发者快速接入各个客户端底层功能，且不会因为各端接口差异、产品需求差异导致正常业务代码被打散，变得可读性差、难以维护，避免结果适得其反，具体Case；各个客户端底层功能实现可以一部分来自Chameleon提供的基础组件和基础api库，一部分来自chameleon开发者，一部分来自各端生态开源库（Chameleon拥抱开源社区，你可以直接安装某个端的组件在使用多态协议扩展到某个端使用）。 "},"framework/polymorphism/api.html":{"url":"framework/polymorphism/api.html","title":"接口多态","keywords":"","body":"接口多态 初始化多态接口 项目根目录下执行cml init component，选择多态接口，输入文件名称，例如utils，生成如下文件结构 ├── components └──utils └── utils.interface 初始化文件内容如下： interface UtilsInterface { getMsg(msg: string): void; } class Method implements UtilsInterface { getMsg(msg) { return 'web:' + msg; } } export default new Method(); class Method implements UtilsInterface { getMsg(msg) { return 'weex:' + msg; } } export default new Method(); class Method implements UtilsInterface { getMsg(msg) { return 'wx:' + msg; } } export default new Method(); 文件中利用标签将各端代码进行物理隔离，利用cml-type属性指定平台。 cml-type=\"interface\"为接口定义部分，利用接口校验语法定义这个接口的方法及方法的参数与返回值。 cml-type=\"web|wx|weex\"为各端实现部分，按照interface接口的定义进行方法的实现输入输出。注意要以export default的形式导出对象。 cml-type=\"web\" 可以调用web端任意方法和全局变量 cml-type=\"wx\" 可以调用微信小程序端任意方法和全局变量 cml-type=\"weex\" 可以调用weex端任意方法和全局变量 调用多态接口 在需要使用多态接口的组件中引入，代码如下： import utils from '/components/utils/utils.interface' let message = utils.getMsg(); 场景举例 手把手教你系列- 实现多态API 扩展阅读 什么时候用到接口多态？ 接口多态适用于因为端的不同而进行不同接口的调用或者不同业务逻辑处理的场景。 例如:我们的页面现在需要一个本地存储功能的需求，我们已知各端的接口调用方法 web端接口是localStorage.setItem 微信小程序端的接口是wx.setStorageSync weex端的接口是storage.setItem 如果不使用接口多态我们只能根据不同环境去调用各自的接口 if(process.env.platform === 'web') { localStorage.setItem(key, value, function(e) { }); } else if(process.env.platform === 'wx') { wx.setStorageSync(key, value); } else if(process.env.platform === 'weex') { storage.setItem(key, value, function(e) { }); } 这样的代码有如下\b\b待解决问题： 增加代码复杂度，难以维护 各端接口的参数不一致，\b写多种逻辑 各端接口耦合在一起，bug风险极高 没有做到各端代码的分离，增大代码体积 利用了接口多态之后的使用方式如下： import utils from 'utils.interface'; utils.setStorage(key, value,cb) utils.interface对setStorage进行了封装,文件内容如下： // 定义一个传参为string类型，返回值为undefine的函数类型 type Callback = (state: string) => undefined; // 定义模块的interface interface UtilsInterface { // 定义setStorage方法 参数个数及返回值类型 setStorage(key: string, value: string, cb: Callback ): undefined; } // web端\b接口实现 class Method \bimplements UtilsInterface { setStorage(key, value, cb) { try { localStorage.setItem(key, value); cb('success'); } cache(e) { cb('fail'); } } } export default new Method(); // weex端\b接口实现 class Method \bimplements UtilsInterface { setStorage(key, value, cb) { storage.setItem(key, value, function(e) { if (e.result == \"success\") { cb('success'); } else { cb('fail'); } }); } } export default new Method(); // wx端\b接口实现 class Method \bimplements UtilsInterface { setStorage(key, value, cb) { \btry { wx.setStorageSync(key, value); cb('success'); } catch(e) { cb('fail'); } } } export default new Method(); 接口多态的优势 保证接口一致性 chameleon的目标是跨多端，接口多态的作用就是屏蔽各端差异，调用多态接口的代码运行在多端，如果保证不了一致性，很可能出现某一端的需求引起的接口改动影响到其他端的功能，导致线上问题。 我们\b设计了cml-type=\"interface\"接口定义部分，目的就是做一致性的校验，各端模块的构造函数要实现该接口，我们在开发环境运行时提供了接口的校验。 代码独立性 \b\b接口多态中利用标签对各端代码进行物理隔离，独立实现，每一端的编译只编译该端的代码，不会有任何影响。 \b充分扩展性 在独立性的基础上，就可以在各端的代码中完全使用各端的接口，以及引用各自端的第三方npm包。 "},"framework/polymorphism/component.html":{"url":"framework/polymorphism/component.html","title":"组件多态","keywords":"","body":"组件多态 chameleon在跨端的统一性上做了很多的工作，但即使是做到了99%的统一，仍然存在着1%的差异，基于代码可维护性的考量，chameleon引入了多态协议。 组件多态的使用 项目根目录下执行cml init component，选择多态组件，输入组件名称，例如c-list，生成如下文件结构 ├── components │ ├── c-list │ │ ├── c-list.interface │ │ ├── c-list.web.cml │ │ ├── c-list.weex.cml │ │ ├── c-list.wx.cml │ │ └── ... interface 文件 .interface文件利用接口校验语法对组件的属性和事件进行类型定义，\b保证各端的组件和事件一致，框架在开发环境的运行时做校验。例如c-list.interface type eventType = 'change'; type eventDetail = { value: string } type changeEvent = (a: eventType, detail: eventDetail) => void; export default Interface Clist { name: string, age: number, changeEvent: changeEvent } *.[web|weex|wx].cml c-list.web.cml、c-list.weex.cml、c-list.wx.cml、... 文件是灰度区，它是唯一可以调用下层端组件的CML文件，分别是web、weex、wx三个端的调用入口。建议这一块代码尽量薄，只是用来调用下层端代码，不要编写过于重的代码。 在灰度区的template模板中： 可以调用下层组件时，该组件传入的属性是各自下层端的语法，绑定的函数回调事件对象也是原始对象。 也可以正常使用普通的cml模板语法 在灰度区的script逻辑代码中： 可以调用下层端的全局变量和任意方法，以及下层端的生命周期。 也可以正常使用普通cml逻辑代码。 在灰度区的style样式代码中： 可以使用下层端css语法。 也可以正常调用cmss语法。 使用举例 手把手教你系列- 实现多态 echart 扩展阅读 什么时候用到组件多态？ chameleon中的组件是采用单文件格式的cml文件，其中包括了一个组件所拥有的视图层、逻辑层及配置信息。考虑以下两种场景： 场景一：当某个功能组件需要调用各端的原生组件，各端原生组件的属性不一致，或者一端有原生组件，其他端需要组合实现等。 场景二：产品在需求上导致某一个组件在各端的结构表现不同。 为什么要引入多态协议 以场景一为例，先看一个最容易理解的跨端组件实现： {{item.name}} // 假设wx-list 是微信小程序原生的组件 // 假设list 是weex端原生的组件 上面的代码块是一个简单的列表实现，wx和weex都是使用了各自的原生组件，这样的实现方法其实是把三端或者N端的模版放在了同一个文件中，当然，这里只是展示了模版的复杂，假设在js代码块中也存在着端的判断，那代码的复杂可想而知。 总结下来，这样的代码有如下\b\b待解决问题： 增加代码复杂度，难以维护 各端组件的属性和事件定义可能不一致 各端组件耦合在一起，bug风险极高 没有做到各端代码的分离，增大体积 而利用了组件多态之后的使用方式如下： 可以看到我们只引用了一个c-list组件，该组件提供了统一的属性。 "},"framework/engineering.html":{"url":"framework/engineering.html","title":"工程化","keywords":"","body":"工程化 工程化是使用软件工程的技术和方法对项目的开发、上线和维护进行管理。chameleon的工程化包含如下几个大方面： 1 模块化，项目中的文件统一以模块化的方式引入，包括.css,.js以及定义的interface文件，这样做有如下好处避免变量污染与命名冲突，提高代码的复用率，提高代码的可维护性。 2 组件化，chameleon定义了.cml文件，以组件为单位，将一个组件需要的视图、逻辑、样式、配置采用单文件的形式进行开发，提高了代码的可读性。 3 本地开发解决方案，chameleon提供了大量的工程化方法，解决本地开发时的各种痛点，包括 提供dev服务，mock数据等能力，达到不依赖后端实现开发的前后端分离。 提供\b热更新，自动刷新，调试窗口，线上资源代理等能力，提高本地开发时的效率。 4 线上部署解决方案，chameleon的构建是完全配置化的，内置线上线下两种构建模式，线上工程化相关功能包括 线上静态资源的路径指定 \b基于文件内容的文件指纹 减少文件体积的代码压缩 5 渐进式使用，chameleon提供了两种渐进式使用的方式，一种是将chameleon的组件导出成各端的原生组件，第二种方式是引用插件在webpack项目中使用chameleon组件与接口。 "},"framework/mock.html":{"url":"framework/mock.html","title":"数据mock","keywords":"","body":"数据mock \bmock文件的使用 /mock/api/文件夹存放模拟api请求的文件，格式如下： module.exports = [ { method: 'get', path: '/api/driver/getList', controller: function (req, res, next) { console.log('/api/driver/getList') res.json({ total: 100, driverList: [] }); }, } ] method指定请求方法，默认值['get','post'] path指定请求的路径 controller 是express的中间件形式，在中间件中可以做任何操作最后调用res的方法返回结果。 启动dev服务后，通过ip+端口+path即可访问配置的api请求。 如何mock api请求 上面\b\b讲解了mock文件的使用，实际的请求都是\b线上的地址，那代码\b中如何做到线上和线下的分离呢？ 例如： 线上的api域名都为api.chameleon.com, 有一个请求地址为api.chameleon.com/api/getdriver。 通过配置+内置网络请求接口\b即可解决上述问题： 1 配置apiPrefix，默认dev模式的api前缀为本机\bip+启动端口，所以media\b为dev不用配置, media为build中配置apiPrefix为线上api域名。 // 设置api请求前缀 const apiPrefix = 'http://api.chameleon.com'; cml.config.merge({ wx: { dev: { }, build: { apiPrefix } } }) 2 使用内置网络请求接口发起网络请求。 import cml from \"chameleon-api\"; cml.get({ url: '/api/getdriver' }) .then(res => { cml.showToast({ message: JSON.stringify(res), duration: 2000 }) }, err => { cml.showToast({ message: JSON.stringify(err), duration: 2000 }) }); 内置网络请求接口会自动在传入的url前拼接配置的apiPrefix,这样就实现了在dev模式请求为本地ip端口+/api/getdriver，在build模式请求为线上域名+/api/getdriver。 3 配置本地mock, 在/mock/api/文件夹下创建文件。 module.exports = [ { method: 'get', path: '/api/getdriver', controller: function (req, res, next) { console.log('/api/getdriver') res.json({ total: 100, data: 'chameleon' }); }, }, ] 4 自定义内置变量 实现api分离的原理重点在于可以配置变量在不同的media为不同的值，api分离定义的是apiPrefix，实际上可以通过process.env.apiPrefix访问。 chameleon提供了可以配置内置变量。 例如： cml.config.merge({ web: { dev: { definePlugin: { 'process.env.TEST': JSON.stringify('CML_DEV') } }, build: { definePlugin: { 'process.env.TEST': JSON.stringify('CML_BUILD') } } } }) 如何mock php模板下发数据 /mock/template/文件夹下存放的php文件是下发的模板数据，php文件内将下发的数据赋值给$chameleon对象，例如： 0, \"errmsg\" => \"\", \"pageData\" => array( \"pageInfo\" => array( \"title\" => \"chameleon\", \"content\" => \"chameleon跨端\" ) ) ); ?> 在模板中通过变量pageData,errno,errmsg接收。 var pageData = {json_encode($pageData)} var errno = {json_encode($errno)} var errmsg = {json_encode($errmsg)} 同时还模拟了与模板下发的pageData相同的ajax请求，只需在当前访问页面的url上添加puredata=1参数。 { errno: 0, errmsg: '', pageData: { pageInfo: { title: 'chameleon', content: 'chameleon跨端' } } } "},"framework/source_location.html":{"url":"framework/source_location.html","title":"资源定位","keywords":"","body":"资源定位 静态资源引用 模板中引用静态资源，不能直接将资源的路径写在模板中，而是要通过js中require该静态资源得到变量，在模板中引用该变量。 该路径会根据项目配置的publicPath自动替换成正确路径。利用该功能可以实现\b静态资源\b开发路径和部署路径之间的\b分离，开发者只需要写相对路径，线上可以通过设置publicPath指定任意路径。 --> class Index { data = { imgPath: require(\"./assets/logo.png\") } }; export default new Index(); 图片base64\b 支持在引用图片url后面添加inline参数，以指定图片的base64格式，例如： class Index { data = { imgPath: require(\"./assets/logo.png?__inline\") } }; export default new Index(); "},"framework/devproxy.html":{"url":"framework/devproxy.html","title":"代理调试","keywords":"","body":"代理模式开发 调试线上编译处理过的非可读性代码，可以使用本功能 通过简单的chameleon配置将线上文件代理到线下的开发环境，这样就可以通过修改线下的源码debug线上页面了，使用方法如下： 第一步 chameleon.config.js中开启代理模式: { ... proxy: { enable: true, } ... } 第二步 执行以下命令 cml dev 第三步 根据调试面板打印的信息给手机安装证书 第四步 根据上图提示将手机代理到相应的端口 完成以上步骤就可以进行代理开发了。 默认代理了weex和web端的js和css文件，如需代理更多文件，可以\b添加mapremote配置，方法如下： { ... proxy: { enable: true, mapremote: [{ from: 'https://a.b.com/weex/aaa_(.+).js', to: 'http://localhost:8000/weex/aaa.js' },{ from: 'https://a.b.com/weex/bbb_(.+).js', to: 'http://localhost:8000/weex/bbb.js' }] } ... } "},"framework/chameleon_url.html":{"url":"framework/chameleon_url.html","title":"Chameleon URL","keywords":"","body":"一个完整 Chameleon URL 一个 Chameleon URL 能在多端运行，在普通浏览器/webview运行 web 端，小程序运行小程序端，Native渲染（weex）则拉取对应的 JS Bundle并展现，完整地址如下，使用场景包含： a.跨应用页面之间跳转使用 open 接口 b.服务端下发给端（weex/浏览器/小程序）进行跳转 https://h5地址? cml_addr=jsbundle地址& weixin_appid=123456& path=路由path 参数 作用 说明 h5地址 H5端的地址或者用于提示bundle出错的h5地址 \b如果你没有h5地址，可以选择将h5地址写为jsbundle地址（后面的cml_addr\b\b=jsbundle地址依然需要）。 cml_addr 描述weex/rn js bundle地址 内部非使用sdk开发者\b暂时使用wx_addr字段 weixin_appid 描述微信小程序的app id 微信小程序跳转需要 appid path 描述应用里面的页面路由， 即路由里面的path值 "},"framework/polymorphism/standards.html":{"url":"framework/polymorphism/standards.html","title":"规范与校验","keywords":"","body":"规范与校验 按照框架定义，有相应的目录规范，文件规范，文件内容规范等，按照规范编写代码，可以最大程度的减少开发、调试时间。 另，框架提供了校验工具，让开发者可以提前发现不符合规范的问题，提高效率。 "},"framework/polymorphism/check.html":{"url":"framework/polymorphism/check.html","title":"接口语法校验","keywords":"","body":"接口校验语法 接口是一系列方法的声明，是一些方法特征的集合，一个接口只有方法的特征没有方法的实现，因此这些方法可以在不同的地方被不同的类实现，而这些实现可以具有不同的行为（功能）进行沟通。 校验配置 通过配置决定是否开启接口的校验。 Object、Array、Nullable这三个类型默认是不支持的，因为我们建议更精确的校验，可以通过配置文件开启这三个类型。 具体参见多态校验控制的配置 类型说明 \b注意：建议定义类型的时候取值为 Number String Boolean Null Undefined(Void) Object Array Function Date RegExp 目前chameleon接口定义支持简单类型和复合类型。 其中简单类型包括以下类型： Number(number) String(string) Boolean(bool) Undefined(void) Null 复合类型包括以下类型： Function Object Array Date RegExp Promise 接口语法 接口的使用分两个过程： 定义一个接口。 定义实现接口的类。 接口定义 范式: interface [接口名称] { // 接口中的属性 [属性名称]: [类型], // 接口中的方法 [方法名称]([传入参数1名称]: [传入参数1类型], [传入参数2名称]: [传入参数2类型], ...): [返回类型] } 举例： // 一个名为interface1的接口 interface interface1 { // foo1: 传入分别为string和number的两个数据，返回值类型为string值 foo1(a: string, b: number): string; // foo2: 传入分别为string和Callback(上文定义)的两个数据，返回值类型为bool值 foo2(c: string, d: Callback): string; } 实现接口（定义类） 范式： class [类名称] implaments [接口名称] { // 实现接口中的属性 [属性名称]: [类型] // 实现接口中的方法 [方法名称]([传入参数1名称], [传入参数2名称], ...) { return [返回值]; } } 举例： // 实现一个名称为Clazz，实现上文定义的interface1接口 class Clazz implaments interface1 { // 实现interface1定义的foo1方法，输入值和输出值要满足定义 foo1(a, b) { return 'hello ' + a + ' : ' + (b + 1); } // 实现interface1定义的foo2方法，输入值和输出值要满足定义 foo2(c, d) { return 'balabala...'; } } 复合类型的定义范式 type [类型名称] = [类型定义] 不同的复合类型，类型定义也不相同，下面会对三种复合类型做详细说明。 Function类型定义 范式: type [Function类型名称] = ([传入参数1名称]: [传入参数1类型], [传入参数2名称]: [传入参数2类型], ...) => [返回类型] 举例： // 定义一个传参分别为number,string,bool类型的三个参数，返回值为number的函数类型 type Callback = (a: number, b: string, c: bool) => number; Object类型定义 范式： type [Object类型名称] = { [属性名称1]: [类型1], [属性名称2]: [类型2] } 举例： // 定义含有a,b,c三个属性的复合类型 type Scheme = { a: string, b: bool, c: number } Array类型定义 范式： type [Array类型名称] = [ [类型1] ] 举例： // 定义名称为arrayType1的数组类型，数组元素为number类型 type arrayType1 = [ number ] 目前数组的详细校验只能校验数组中的元素是同一种类型，即[1,2,3],而不能校验 [1,2,'this is string']; 如果想要校验某个入参或者函数的返回值是一个数组，但是数组中的值得类型不是同一类型 或者只想简单的对某个对象进行类型校验，但是对象中具体的key-value值不想校验； 那么在- 项目配置开启['Object','Array']直接校验的前提下，可以如下写**interface EntryInterface { handleDate(arr:Array,o:Object) : Array } class Method implements EntryInterface { let arr = [1,2,3,'str']; let obj = {address:'China'} handleDate(arr,obj){ return ['this is str',{name:\"jhon\"}]; } } 此时校验就只会校验入参或者返回值得数据类型是否是 Array 或者 Object ，而不会深入校验数组或者对象中的元素； 复合类型中的相互嵌套 Function、Object、Array三种复合类型可以互相嵌套： // 定义一个传参分别为number,string,bool类型的三个参数，返回值为number的函数类型 type Callback = (a: number, b: string, c: bool) => number; // 定义名称为arrayType1的数组类型，数组元素为number类型 type arrayType1 = [ number ] // 定义名称为Scheme的，含有Array类型和Function类型属性的Object类型 type Scheme = { a: arrayType1, b: Callback, } // 定义名称为Plan，含有Scheme类型和Callback的属性的Object类型 type Plan = { a: string, b: Scheme, c: Callback } // 定义名称为arrayType1类型，元素为Plan类型 type arrayType1 = [ Plan ] Promise 类型的定义 对于 async函数，由于该函数调用之后的返回值是 Promise对象，所以这样的函数的返回值要声明成 Promise; interface EntryInterface { appEntry(): Promise; appEntry2() : Promise; } 在 methods 中 class Method implements EntryInterface { async appEntry(num) { } appEntry2(){ return new Promise((resolve,reject) => { setTimeout(resolve,2000); }) } } Date 类型的定义 如果函数参数或者返回值是 Date 数据类型，那么可以按照下面的方式进行定义； interface EntryInterface { handleDate(d:Date) : Date } class Method implements EntryInterface { handleDate(d){ return new Date(); } } RegExp 类型的定义 如果函数参数或者返回值是 RegExp 数据类型，那么可以按照下面的方式进行定义； interface EntryInterface { handleDate(d:RegExp) : RegExp } class Method implements EntryInterface { handleDate(r){ return new RegExp(); } } Maybe Types : 意味着该值可能是这种类型，但是也可能是 undefined 或者 null 注意如果要定义Nullable（?Number）这样的参数，那么该参数的占位符是必须的 interface EntryInterface { acceptsMaybeNumber(a:? Number,b:String,c:Boolean) : Undefined } class Method implements EntryInterface { acceptsMaybeNumber(a,b,c){ } } acceptsMaybeNumber(42,'str',true); // Works! acceptsMaybeNumber(undefined,'str',true); // Works! acceptsMaybeNumber(null,'str',true); // Works! acceptsMaybeNumber(\"42\",'str',true); // Error! //**注意如果要定义Nullable（?Number）这样的参数，那么该参数的占位符是必须的,在校验入参的时候，会按照interface中定义的顺序，有序的校验传入的参数是否和interface中定义的数据参数类型一直，(?Number)这种定义的校验其实只是说明这个参数可以是 null undefined number类型的数据，但是是必须传递的** acceptsMaybeNumber('str',true); // Error! "},"framework/global_check.html":{"url":"framework/global_check.html","title":"全局变量校验","keywords":"","body":"全局变量校验 chameleon的代码最终会运行在多端框架中，每一个端都会有一些特有的全局变量，chameleon内部维护了一个各端全局变量的散列表如下表所示。 全局变量校验校验的是某一端运行的代码中存在其他端的全局变量并且不是当前端的全局变量。例如非微信小程序端的\b代码中不能出现wx全局变量，非百度小程序的代码中不能出现\bswan全局变量。 可以通过项目配置决定是否开启全局变量校验，还可以配置哪些文件是白名单文件不进行校验。 端全局变量 微信小程序[\"wx\"] 百度小程序[\"swan\"] weex[\"weex\"] 支付宝小程序[\"my\"] web[\"postMessage\",\"blur\",\"focus\",\"close\",\"frames\",\"self\",\"window\",\"parent\",\"opener\",\"top\",\"length\",\"closed\",\"location\",\"document\",\"origin\",\"name\",\"history\",\"locationbar\",\"menubar\",\"personalbar\",\"scrollbars\",\"statusbar\",\"toolbar\",\"status\",\"frameElement\",\"navigator\",\"customElements\",\"external\",\"screen\",\"innerWidth\",\"innerHeight\",\"scrollX\",\"pageXOffset\",\"scrollY\",\"pageYOffset\",\"screenX\",\"screenY\",\"outerWidth\",\"outerHeight\",\"devicePixelRatio\",\"clientInformation\",\"screenLeft\",\"screenTop\",\"defaultStatus\",\"defaultstatus\",\"styleMedia\",\"onanimationend\",\"onanimationiteration\",\"onanimationstart\",\"onsearch\",\"ontransitionend\",\"onwebkitanimationend\",\"onwebkitanimationiteration\",\"onwebkitanimationstart\",\"onwebkittransitionend\",\"isSecureContext\",\"onabort\",\"onblur\",\"oncancel\",\"oncanplay\",\"oncanplaythrough\",\"onchange\",\"onclick\",\"onclose\",\"oncontextmenu\",\"oncuechange\",\"ondblclick\",\"ondrag\",\"ondragend\",\"ondragenter\",\"ondragleave\",\"ondragover\",\"ondragstart\",\"ondrop\",\"ondurationchange\",\"onemptied\",\"onended\",\"onerror\",\"onfocus\",\"oninput\",\"oninvalid\",\"onkeydown\",\"onkeypress\",\"onkeyup\",\"onload\",\"onloadeddata\",\"onloadedmetadata\",\"onloadstart\",\"onmousedown\",\"onmouseenter\",\"onmouseleave\",\"onmousemove\",\"onmouseout\",\"onmouseover\",\"onmouseup\",\"onmousewheel\",\"onpause\",\"onplay\",\"onplaying\",\"onprogress\",\"onratechange\",\"onreset\",\"onresize\",\"onscroll\",\"onseeked\",\"onseeking\",\"onselect\",\"onstalled\",\"onsubmit\",\"onsuspend\",\"ontimeupdate\",\"ontoggle\",\"onvolumechange\",\"onwaiting\",\"onwheel\",\"onauxclick\",\"ongotpointercapture\",\"onlostpointercapture\",\"onpointerdown\",\"onpointermove\",\"onpointerup\",\"onpointercancel\",\"onpointerover\",\"onpointerout\",\"onpointerenter\",\"onpointerleave\",\"onafterprint\",\"onbeforeprint\",\"onbeforeunload\",\"onhashchange\",\"onlanguagechange\",\"onmessage\",\"onmessageerror\",\"onoffline\",\"ononline\",\"onpagehide\",\"onpageshow\",\"onpopstate\",\"onrejectionhandled\",\"onstorage\",\"onunhandledrejection\",\"onunload\",\"performance\",\"stop\",\"open\",\"alert\",\"confirm\",\"prompt\",\"print\",\"requestAnimationFrame\",\"cancelAnimationFrame\",\"requestIdleCallback\",\"cancelIdleCallback\",\"captureEvents\",\"releaseEvents\",\"getComputedStyle\",\"matchMedia\",\"moveTo\",\"moveBy\",\"resizeTo\",\"resizeBy\",\"getSelection\",\"find\",\"webkitRequestAnimationFrame\",\"webkitCancelAnimationFrame\",\"fetch\",\"btoa\",\"atob\",\"createImageBitmap\",\"scroll\",\"scrollTo\",\"scrollBy\",\"onappinstalled\",\"onbeforeinstallprompt\",\"crypto\",\"ondevicemotion\",\"ondeviceorientation\",\"ondeviceorientationabsolute\",\"indexedDB\",\"webkitStorageInfo\",\"sessionStorage\",\"localStorage\",\"chrome\",\"visualViewport\",\"speechSynthesis\",\"webkitRequestFileSystem\",\"webkitResolveLocalFileSystemURL\",\"openDatabase\",\"applicationCache\",\"caches\",\"whichAnimationEvent\",\"animationendEvent\",\"infinity\",\"SETTING\",\"AppView\",\"ExtensionOptions\",\"ExtensionView\",\"WebView\",\"iconPath\",\"_app\",\"_ZOOM_\",\"Feed\",\"md5\",\"$\",\"jQuery\",\"Search\",\"windmill\",\"Lethargy\",\"alertTimeOut\",\"supportApps\",\"lethargyX\",\"lethargyY\",\"iView\",\"onModuleResLoaded\",\"iEditDelete\",\"infinityDrag\",\"i\",\"array\",\"TEMPORARY\",\"PERSISTENT\",\"addEventListener\",\"removeEventListener\",\"dispatchEvent\"] "},"framework/linter.html":{"url":"framework/linter.html","title":"代码规范校验","keywords":"","body":"代码规范校验 核心文件校验 检查以下文件是否存在 chameleon.config.js src/app/app.cml src/router.config.json CML文件规范校验 多文件cml格式下，是否存在interface文件 命名名称是否符合规范 模板规范校验 根据模板语法(lang=vue|cml)校验语法是否正确 模板中组件使用是否符合规范 脚本规范校验 编写一端代码逻辑时，如果使用其他端的全局变量，会校验失败。 使用未定义的event名称时，会报错 使用未定义的prop名称时，会报错 样式规范校验 满足css规则 不支持级联 配置规范校验 json格式是否合法 usingComponents只放置在base字段下 "},"framework/linter/core.html":{"url":"framework/linter/core.html","title":"核心文件校验","keywords":"","body":"核心文件校验 根据chameleon目录结构，确定核心文件的位置，保证chameleon项目能够正常运行。 目录结构 ├── chameleon.config.js // 项目的配置文件 ├── dist // 打包产出目录 ├── mock // 模拟数据目录 ├── node_modules // npm包依赖 ├── package.json └── src // 项目源代码 ├── app // app入口 ├── components // 组件文件夹 ├── pages // 页面文件夹 ├── router.config.json // 路由配置文件 └── store // 全局状态管理 核心文件列表 会对以下核心文件进行检查： chameleon.config.js src/app/app.cml src/router.config.json "},"framework/linter/cml-file.html":{"url":"framework/linter/cml-file.html","title":"CML文件规范校验","keywords":"","body":"CML文件规范校验 CML文件规范校验包括校验以下三个规范： CML文件命名规范 CML文件内容规范 CML Interface内容规范 CML文件命名规范 以cml后缀结尾的文件分两种情况： 1. 多端实现完全一致组件命名格式： [component name].cml 组件所有逻辑实现在同一文件中 举例： demo.cml 2. 多端实现不一致组件命名格式： [component name].[weex|wx|web].cml 组件文件名按照适配端命名，需要同一目录下的interface文件组合使用 [component name].interface 举例： demo.interface demo.weex.cml demo.wx.cml demo.web.cml CML文件内容规范 cml文件中可能包括以下几个字段标签 template(template规范)：标签中书写组件的视图层结构，chameleon自定义了一套标签语言，结合基础组件、事件系统，可以构建出页面的结构。 style(CMSS规范)：标签中书写组件的样式, 描述视图中的元素样式。 script(script规范)：标签中填充编写组件逻辑层响应页面操作的代码。 json(json规范)：标签中书写组件的配置信息。 举例： // demo.cml code class Index { } export default new Index(); #banner { background-color: #ff0000; } { \"base\":{ \"usingComponents\": { } }, \"wx\": { \"navigationBarTitleText\": \"index\", \"backgroundTextStyle\": \"dark\", \"backgroundColor\": \"#E2E2E2\", \"component\": true } \"web\": { }, \"weex\": { } } CML Interface内容规范 具体可参见interface规范，.interface后缀文件用于定义多态组件的接口。 "},"framework/linter/standards/cml-interface.html":{"url":"framework/linter/standards/cml-interface.html","title":"interface规范","keywords":"","body":"interface规范 接口是一系列方法的声明，是一些方法特征的集合，一个接口只有方法的特征没有方法的实现，因此这些方法可以在不同的地方被不同的类实现，而这些实现可以具有不同的行为（功能）进行沟通。 类型说明 注意：建议定义类型的时候取值为 Number String Boolean Null Undefined(Void) Object Array Function Date RegExp 目前chameleon接口定义支持简单类型和复合类型。 其中简单类型包括以下类型： Number(number) String(string) Boolean(bool) Undefined(void) Null 复合类型包括以下类型： Function Object Array Date RegExp Promise 接口语法 接口的使用分两个过程： 定义一个接口。 定义实现接口的类。 接口定义 范式: interface [接口名称] { // 接口中的属性 [属性名称]: [类型], // 接口中的方法 [方法名称]([传入参数1名称]: [传入参数1类型], [传入参数2名称]: [传入参数2类型], ...): [返回类型] } 举例： // 一个名为interface1的接口 interface interface1 { // foo1: 传入分别为string和number的两个数据，返回值类型为string值 foo1(a: string, b: number): string; // foo2: 传入分别为string和Callback(上文定义)的两个数据，返回值类型为bool值 foo2(c: string, d: Callback): string; } 实现接口（定义类） 范式： class [类名称] implaments [接口名称] { // 实现接口中的属性 [属性名称]: [类型] // 实现接口中的方法 [方法名称]([传入参数1名称], [传入参数2名称], ...) { return [返回值]; } } 举例： // 实现一个名称为Clazz，实现上文定义的interface1接口 class Clazz implaments interface1 { // 实现interface1定义的foo1方法，输入值和输出值要满足定义 foo1(a, b) { return 'hello ' + a + ' : ' + (b + 1); } // 实现interface1定义的foo2方法，输入值和输出值要满足定义 foo2(c, d) { return 'balabala...'; } } 复合类型的定义范式 type [类型名称] = [类型定义] 不同的复合类型，类型定义也不相同，下面会对三种复合类型做详细说明。 Function类型定义 范式: type [Function类型名称] = ([传入参数1名称]: [传入参数1类型], [传入参数2名称]: [传入参数2类型], ...) => [返回类型] 举例： // 定义一个传参分别为number,string,bool类型的三个参数，返回值为number的函数类型 type Callback = (a: number, b: string, c: bool) => number; Object类型定义 范式： type [Object类型名称] = { [属性名称1]: [类型1], [属性名称2]: [类型2] } 举例： // 定义含有a,b,c三个属性的复合类型 type Scheme = { a: string, b: bool, c: number } Array类型定义 范式： type [Array类型名称] = [ [类型1] ] 举例： // 定义名称为arrayType1的数组类型，数组元素为number类型 type arrayType1 = [ number ] 复合类型中的相互嵌套 Function、Object、Array三种复合类型可以互相嵌套： // 定义一个传参分别为number,string,bool类型的三个参数，返回值为number的函数类型 type Callback = (a: number, b: string, c: bool) => number; // 定义名称为arrayType1的数组类型，数组元素为number类型 type arrayType1 = [ number ] // 定义名称为Scheme的，含有Array类型和Function类型属性的Object类型 type Scheme = { a: arrayType1, b: Callback, } // 定义名称为Plan，含有Scheme类型和Callback的属性的Object类型 type Plan = { a: string, b: Scheme, c: Callback } // 定义名称为arrayType1类型，元素为Plan类型 type arrayType1 = [ Plan ] Promise 类型的定义 对于 async函数，由于该函数调用之后的返回值是 Promise对象，所以这样的函数的返回值要声明成 Promise; interface EntryInterface { appEntry(): Promise; appEntry2() : Promise; } 在 methods 中 class Method implements EntryInterface { async appEntry(num) { } appEntry2(){ return new Promise((resolve,reject) => { setTimeout(resolve,2000); }) } } Date 类型的定义 如果函数参数或者返回值是 Date 数据类型，那么可以按照下面的方式进行定义； interface EntryInterface { handleDate(d:Date) : Date } class Method implements EntryInterface { handleDate(d){ return new Date(); } } RegExp 类型的定义 如果函数参数或者返回值是 RegExp 数据类型，那么可以按照下面的方式进行定义； interface EntryInterface { handleDate(d:RegExp) : RegExp } class Method implements EntryInterface { handleDate(r){ return new RegExp(); } } "},"framework/linter/cml-template.html":{"url":"framework/linter/cml-template.html","title":"模板规范校验","keywords":"","body":"模板规范校验 该文档汇集模板校验支持所有检查点，附录有模板格式规范 模板语言校验 模板可以指定模板语言，指定方式为在 template 标签上指定 lang 属性， 其合法值为 \"cml\" 和 \"vue\"。 校验点: template 可以忽略 lang 属性，此时默认值为 cml template lang 属性如果指定，则必须为 \"cml\" 或者 \"vue\" 报错信息：'the tag template lang attribute: \"\" is not valid'. 模板 template 标签校验 校验点：每个模板只能\b且必须有一对 template 根标签。 报错信息：\"Each template can only have one group of template tags.\" 模板内 tags 校验 每个模板都有一个模板语言和一个平台类型，其中模板语言由 template 的 lang 属性指定，平台类型由模板文件的文件名解析出来。 对于多态组件平台类型可以直接从文件名解析出来， 比如 index.web.cml, index.weex.cml, index.wx.cml 对应的平台类型分别为 web, weex, wx。 对于单文件组件，由于其模板要跨三端，故模板中只能使用 chameleon 原生支持的内建标签。 校验点： 单文件组件只能使用 chameleon 内建标签，使用非内建标签校验不通过。 chameleon 内建标签有: ['template','view','text','block','scroller','list','cell','image','switch','video','input','button','radio','checkbox', 'page', 'router-view', 'slot'] src/app/app.cml 项目启动文件中可以使用app组件，且只有store和router-config属性 多态组件可以使用 chameleon 内建标签，\b加上各平台类型所支持的原生标签，使用其他标签验证不同过。在使用平台类型支持的原生标签时，必须使用 'origin-' \b为前缀。比如: 在 wx 平台下使用 swiper 标签，那么在模板里的写法是 'origin-swiper'. 各个平台类型支持的原生标签列举如下: web 平台原生支持标签: [\"a\",\"abbr\",\"acronym\",\"address\",\"applet\",\"area\",\"article\",\"aside\",\"audio\",\"b\",\"base\",\"basefont\",\"bdi\",\"bdo\",\"big\",\"blockquote\",\"body\",\"br\",\"button\",\"canvas\",\"caption\",\"center\",\"cite\",\"code\",\"col\",\"colgroup\",\"command\",\"datalist\",\"dd\",\"del\",\"details\",\"dir\",\"div\",\"dfn\",\"dialog\",\"dl\",\"dt\",\"em\",\"embed\",\"fieldset\",\"figcaption\",\"figure\",\"font\",\"footer\",\"form\",\"frame\",\"frameset\",\"h1\",\"h2\",\"h3\",\"h4\",\"h5\",\"h6\",\"head\",\"header\",\"hr\",\"html\",\"i\",\"iframe\",\"img\",\"input\",\"ins\",\"kbd\",\"keygen\",\"label\",\"legend\",\"li\",\"link\",\"map\",\"mark\",\"menu\",\"menuitem\",\"meta\",\"meter\",\"nav\",\"noframes\",\"noscript\",\"object\",\"ol\",\"optgroup\",\"option\",\"output\",\"p\",\"param\",\"pre\",\"progress\",\"q\",\"rp\",\"rt\",\"ruby\",\"s\",\"samp\",\"script\",\"section\",\"select\",\"small\",\"source\",\"span\",\"strike\",\"strong\",\"style\",\"slot\",\"sub\",\"summary\",\"sup\",\"table\",\"tbody\",\"td\",\"textarea\",\"tfoot\",\"th\",\"thead\",\"time\",\"title\",\"tr\",\"track\",\"tt\",\"u\",\"ul\",\"var\",\"video\",\"wbr\"] weex 平台原生支持标签: ['a','div','image','indicator','input','list','cell','recycle-list','loading','refresh','scroller','slider','textarea','text','richtext','video','waterfall','web'] wx 平台原生支持标签: ['template','view','block','scroll-view','swiper','movable-view','movable-area','cover-view','cover-image','icon','text','rich-text','progress','lable','input','form','checkbox','picker','picker-view','radio','switch','slider','textarea','navigator','functional-page-navigator','camera','live-player','live-pusher','map','open-data','web-view','ad','official-account','slot'] 报错信息：'tag: \"\" is either not allowed in this template or not referenced as a component' 模板指令校验 除引入的\b平台原生组件对应的标签和'origin-'为前缀的原生标签，每个模板只能够使用 template lang 指定\b\b模板语言对应的指令。Chameleon \b现只提供两种模板语言 'vue' 和 'cml'。其对应的指令列举如下: lang='cml' 支持的指令：['c-if','c-else','c-else-if','c-for','c-for-index','c-for-item','c-model','c-text','c-show','c-bind','c-catch','c-key'] lang='vue' 支持的指令：['v-if','v-else','v-else-if','v-for','v-on','v-bind','v-html','v-show','v-model','v-pre','v-once','slot-scope','is','@',':'] 校验点： 单文件模板只能使用模板语言对应的指令，使用模板语言指令之外的指令校验不通过 多态组件各平台文件中以\b 'origin-' 为前缀的平台类型原生标签上必须使平台原生指令，不能使用 \bChameleon 内置指令，使用此外其他指令校验不通过。各平台支持原生指令列举如下: web 平台支持指令: ['v-if', 'v-else', 'v-else-if', 'v-for', 'v-on', 'v-bind', 'v-html', 'v-show', 'v-model', 'v-pre', 'v-once', 'slot-scope', 'is','@',':'] weex 平台支持指令同 vue.js 框架: ['v-if','v-else','v-else-if','v-for','v-on','v-bind','v-html','v-show','v-model','v-pre','v-once','slot-scope','is','@',':'] wx 平台支持指令：['wx:if','wx:elif','wx:else','wx:for','wx:for-item','wx:for-index','wx:key','bindtap','catchtap'] \b多态组件通过 usingComponents 配置引入的\b第三方\b平台原生组件，组件对应的标签上只能够使用平台原生指令，不能使用 \bChameleon 内置指令，使用此外其他指令校验不通过。 报错信息：'directive \"\" is not allowed to be used in this template, as the template language is set to \"\"' 报错信息：'tag \"\" is prefixed with \"origin-\" directive, so it\\'s not allowed to use a chameleon built-in directive:\"\"' 报错信息：'tag \"\" is a third party impored component, so it\\'s not allowed to use a chameleon built-in directive:\"\"' 组件属性和事件名称校验 在使用组件的时，会对使用过程中属性名和绑定的事件名称进行校验。组件属性校验分为内建组件与自定义组件两部分。 校验点： 内建组件:使用的属性名和绑定事件必须在组件内有定义否则校验不通过 chameleon 内建组件有：[\"template\", \"view\", \"text\", \"block\", \"scroller\", \"list\", \"cell\", \"image\", \"switch\", \"video\", \"input\", \"textarea\", \"richtext\", \"button\", \"radio\", \"checkbox\", \"page\", \"router-view\", \"slot\", \"aside\", \"col\", \"container\", \"foot\", \"head\", \"main\", \"row\"] 报错信息：'component \"\" doesn\\'t have a defined property named \"\"' \b报错信息：'component \"\" doesn\\'t have a defined event named \"\"' 自定义组件:模板校验时和根据 usingComponents 配置解析对应组件，使用组件时属性名和事件名必须在组件内有定义否则校验不通过。 报错信息： \"The property \"propName\" is not a property of component \"compName\" which path is: path/to/component\" 报错信息： \"The event \"eventName\" is not defined in component \"compName\" which path is: path/to/component\" 内置组件嵌套规则校验 在使用 chameleon 内置组件时，内置组件之间需要遵循一定的嵌套关系。 校验点： text 组件 text 组件只能包含 text 组件作为子节点 scroller 组件 scroller 组件不能包含 textarea 或者 video 组件 list list 组件不能包含 textarea 或者 video 组件 video video 组件如果包含子组件，那么只能是 text 组件 报错信息 'tag \"\" can not have any child elements, therefor tag \"\" is not allowed as it\\'s children' 报错信息 'tag \"\" can only have \"\" as it\\'s child elements, therefor tag \"\" is not allowed as it\\'s children' 报错信息 'tag \"\" can not have \"\" as it\\'s child elements, and element in this list: \"\" is forbidden as well' 附：模板格式规范 模板书写规范 chameleon 模板书写规范尊从 HTML5 基本规范。 模板目录规范 chameleon 支持三端(三种 native 环境)，每个组件在每个环境对应有一个模板。模板命名格式 组件名称+端名称.cml 比如：c-title 组件 ├── components │ ├── c-title │ │ ├── c-title.web.cml │ │ ├── c-title.weex.cml │ │ └── c-title.wx.cml 其中： c-title.web.cml 为 web 端模板，c-title.weex.cml 为 iOS、Android 端，c-title.wx.cml 为微信小程序端。 本节模板规范就是指对这三个模板文件的编写规范。 模板语言指定 每个端的模板都可以并且必须选择两种语法规范中的一个，cml 语法规范 或者 类 vue 语法规范。指定语法规范的方式为在根节点 template 标签上给属性 lang 指定 \"cml\" 或者 \"vue\"。 列如指定模板为 cml 语法规范 注意：每个模板只能够有一个根节点并且必须为 template 标签，template 便签每个模板只能有一个。 模板标签使用规范 每个模板内可以使用的标签由三部分组成： Chameleon 的内置组件对应的标签 chamelon 支持的标签有: template、view、text、block、scroller、list、cell、image、switch、video、input、textarea、richtext、button、radio、checkbox、page、router-view、slot、aside、col、container、foot、head、main、row 多态组件中在平台文件里，\b以 'origin-' \b为\b前缀的平台原生组件对应的\b标签。 \b模板文件中通过 usingComponents 引入的组件对应的\b标签。 举例 仍以 c-title 组件为例，假设各个模板都有自定义组件配置 { \"base\": { \"usingComponents\": { \"tickets\": \"/components/ticket/index\" } } } c-title.web.cml 可以使用 chameleon 支持的 view、text、block 等基本标签，带 'origin-' \b前缀的 web 原生标签 origin-div、origin-p、origin-span 等,以及自定义组件 tickets。 c-title.weex.cml 可以使用 chameleon 支持的 view、text、block 等基本标签，weex 支持的标签，以及自定义组件 tickets。如果以 vue 作为 weex 使用的前端框架，那么 weex 支持的标签基本和 vue 框架支持的标签基本一致，其中有部分不支持的标签比如：transition 标签，具体请参见 weex 文档。 c-title.wx.cml 可以使用 chameleon 支持的 view、text、block 等基本标签，带 'origin-' 前缀的 wx 原生标签比如 origin-swiper、origin-movable-area、origin-cover-view、origin-web-view 等,以及自定义组件 tickets。 模板指令使用规范 除引用平台原生组件\b对应的标签外，每个模板必须使用模板\b语言(由 template 标签\b的 lang 属性指定) 所对应的指令集。 模板语言为 cml 时支持的指令有：c-if、c-else、c-else-if、c-for、c-for-index、c-for-item、c-model、c-text、c-show、c-bind、c-catch 模板语言为类 vue 时支持的指令有：v-if、v-else、v-else-if、v-for、v-on、v-bind、v-html、v-show、v-model、v-pre、v-once、slot-scope、is、@、: 类 vue 语法支持上述列表中的指令，其他 vue.js 的指令如 v-cloak 是不支持的。 举例 若模板语言为 \"cml\" 即 template 标签 lang 属性为 \"cml\"，native 环境为微信小程序。还是以 c-title 组件为例，那么此时对应的是 c-title.wx.cml 模板。 c-title.wx.cml: {{messageText}} 那么模板里可以使用 chameleon 支持的指令: c-if、c-else、c-else-if、c-for、c-for-index、c-for-item、c-model、c-text、c-show、c-bind、c-catch \b引用平台原生组件 Chameleon 提供两种方式引入平台原生\b\b\b组件和平台第三方原生组件： 通过给平台\b\b原生内置组件添加 'origin-' 前缀引用原生组件 通过 usingComponents 引入平台原生第三方组件 \b引用的原生组件上只能够使用平台支持的原生指令，不能使用 Chameleon 内置指令。\b改限制只限于组件本身，对其子组件没有影响。 举例 若模板语言为 \"cml\" 即 template 标签 lang 属性为 \"cml\"，native 环境为微信小程序。还是以 c-title 组件为例，那么此时对应的是 c-title.wx.cml 模板。 c-title.wx.cml: {{messageText}} 那么模板里可以使用 chameleon 支持的指令: c-if、c-else、c-else-if、c-for、c-for-index、c-for-item、c-model、c-text、c-show、c-bind、c-catch origin-picker-view 组件可以使用微信小程序原生支持的指令: wx:if、wx:elif、wx:else、wx:for、wx:for-item、wx:for-index、wx:key、bindtap、catchtap "},"framework/linter/cml-script.html":{"url":"framework/linter/cml-script.html","title":"脚本规范校验","keywords":"","body":"脚本规范校验 组件逻辑层响应页面操作的代码，需要导出以下规范的对象。 { // 数据 data: { dataKey1: dataValue1, dataKey2: dataValue2 }, // 属性 props: { propKey1: propValue1, propKey2: propValue2 }, // 计算属性 computed: { computedKey1: () => { }, computedKey2: () => { } }, // 监听属性 watch: { watchKey1: () => { }, watchKey2: () => { } }, // 实例初始化之后，数据和方法挂在到实例之前 beforeCreate: () => { }, // 数据及方法挂载完成 created: () => { }, // 开始挂载已经编译完成的html,到对应的dom节点时 beforeMount: () => { }, // 模板或者html编译完成,且渲染到dom中完成 mounted: () => { }, // 实例销毁之前 beforeDestroy: () => { }, // 实例销毁后 destroyed: () => { } } 生命周期 钩子 执行时机 详细 beforeCreate 实例初始化之后，数据和方法挂在到实例之前 在该钩子函数中会传入当前页面query参数 created 数据及方法挂载完成 beforeMount 开始挂载已经编译完成的html,到对应的dom节点时 mounted 模板或者html编译完成,且渲染到dom中完成 beforeDestroy 实例销毁之前 destroyed 实例销毁后 全局变量校验 编写一端代码逻辑时，如果使用其他端的全局变量，会校验失败。 按照端类型区分可用的全局变量： WEEX weex, global WX wx, global WEB postMessage, blur, focus, close, frames, self, window, parent, opener, top, length, closed, location, document, origin, name, history, locationbar, menubar, personalbar, scrollbars, statusbar, toolbar, status, frameElement, navigator, customElements, external, screen, innerWidth, innerHeight, scrollX, pageXOffset, scrollY, pageYOffset, screenX, screenY, outerWidth, outerHeight, devicePixelRatio, clientInformation, screenLeft, screenTop, defaultStatus, defaultstatus, styleMedia, onanimationend, onanimationiteration, onanimationstart, onsearch, ontransitionend, onwebkitanimationend, onwebkitanimationiteration, onwebkitanimationstart, onwebkittransitionend, isSecureContext, onabort, onblur, oncancel, oncanplay, oncanplaythrough, onchange, onclick, onclose, oncontextmenu, oncuechange, ondblclick, ondrag, ondragend, ondragenter, ondragleave, ondragover, ondragstart, ondrop, ondurationchange, onemptied, onended, onerror, onfocus, oninput, oninvalid, onkeydown, onkeypress, onkeyup, onload, onloadeddata, onloadedmetadata, onloadstart, onmousedown, onmouseenter, onmouseleave, onmousemove, onmouseout, onmouseover, onmouseup, onmousewheel, onpause, onplay, onplaying, onprogress, onratechange, onreset, onresize, onscroll, onseeked, onseeking, onselect, onstalled, onsubmit, onsuspend, ontimeupdate, ontoggle, onvolumechange, onwaiting, onwheel, onauxclick, ongotpointercapture, onlostpointercapture, onpointerdown, onpointermove, onpointerup, onpointercancel, onpointerover, onpointerout, onpointerenter, onpointerleave, onafterprint, onbeforeprint, onbeforeunload, onhashchange, onlanguagechange, onmessage, onmessageerror, onoffline, ononline, onpagehide, onpageshow, onpopstate, onrejectionhandled, onstorage, onunhandledrejection, onunload, performance, stop, open, alert, confirm, prompt, print, requestAnimationFrame, cancelAnimationFrame, requestIdleCallback, cancelIdleCallback, captureEvents, releaseEvents, getComputedStyle, matchMedia, moveTo, moveBy, resizeTo, resizeBy, getSelection, find, webkitRequestAnimationFrame, webkitCancelAnimationFrame, fetch, btoa, atob, createImageBitmap, scroll, scrollTo, scrollBy, onappinstalled, onbeforeinstallprompt, crypto, ondevicemotion, ondeviceorientation, ondeviceorientationabsolute, indexedDB, webkitStorageInfo, sessionStorage, localStorage, chrome, visualViewport, speechSynthesis, webkitRequestFileSystem, webkitResolveLocalFileSystemURL, openDatabase, applicationCache, caches, whichAnimationEvent, animationendEvent, infinity, SETTING, AppView, ExtensionOptions, ExtensionView, WebView, iconPath, _app, _ZOOM_, Feed, md5, $, jQuery, Search, windmill, Lethargy, alertTimeOut, supportApps, lethargyX, lethargyY, iView, onModuleResLoaded, iEditDelete, infinityDrag, i, array, TEMPORARY, PERSISTENT, addEventListener, removeEventListener, dispatchEvent "},"framework/linter/cml-cmss.html":{"url":"framework/linter/cml-cmss.html","title":"样式规范校验","keywords":"","body":"样式规范校验 CMSS 规则 CMSS 规则由两个主要的部分构成：选择器，以及一条或多条声明。 selector { declaration1; declaration2; ... declarationN } 每条声明由一个属性和一个值组成。 声明 属性（property）是您希望设置的样式属性（style attribute）。每个属性有一个值。属性和值被冒号分开，一条声明以分号结尾。 selector { property1: value1; property2: value2; } selector应为一条独立的id名称或者class名称，不支持级联 // 正确 .selector { property1: value1; property2: value2; } #selector { property1: value1; property2: value2; } // 错误 #selector1 .selector { property1: value1; property2: value2; } 多端之间的差异对比 CSS属性 H5 小程序 weex 布局 all all flexbox 盒模型 all all 只支持display:border-box float浮动 ✅ ✅ ❌ display:inline-block|none ✅ ✅ ❌ ID选择器 ✅ ✅ ❌ 类选择器 ✅ ✅ ✅ 属性选择器 ✅ ✅ ❌ 级联选择器、派生选择器(后代、子元素、相邻兄弟) ✅ ✅ ❌ 选择器分组 ✅ ✅ ✅ 伪类(:active|:focus) ✅ ✅ ✅ 伪类(:hover|:link|:visited|:first-child|:lang) ✅ ✅ ❌ 伪元素(:first-letter|:first-line|:before|:after) ✅ ✅ ❌ 百分比定值 ✅ ✅ ❌ line-height:1 ✅ ✅ ❌ 尺寸 px|rem|em|vw|vh px|rpx px !important ✅ ✅ ❌ 注意:框架会根据上表所述的多端之间的差异做校验。 "},"framework/linter/cml-json.html":{"url":"framework/linter/cml-json.html","title":"配置规范校验","keywords":"","body":"配置规范校验 CML文件配置规范的校验，包括语法格式，组件的引用等。 说明 wx、web、weex分别对应三端构建时所应用的配置信息，base的配置会应用到每一端的配置，内部做的result = merge(base,target)。 wx字段配置的内容最终会生成到微信小程序所需要的json文件。 wx.component字段,如果在微信中该cml文件是组件必须声明该字段。 usingComponents字段是目前最重要的配置，三端都会使用，微信小程序规定页面的json文件中配置使用到的组件。web和weex端的构建时也是根据该字段去找到相应的组件进行自动化的注册。所以用到组件必须进行配置 usingComponents中组件的引用地址支持引用src和node_modules下的组件，src下的，可以写相对路径，也可以写相对于src的绝对路径，例如/components/**, node_modules下的组件，不需要写node_modules，直接从npm的包名称开始写例如cml-test-ui/navi/navi。 路径写到.cml文件所在层级，不写后缀。 例子： { \"base\": { \"usingComponents\": { \"c-scroller\": \"chameleon-ui-builtin/components/scroller/scroller\", \"c-checkbox\": \"/components/c-checkbox/c-checkbox\" } }, \"wx\": { \"navigationBarTitleText\": \"index\", \"backgroundTextStyle\": \"dark\", \"backgroundColor\": \"#E2E2E2\", \"component\": true } } ## chameleonjson规范 包括以下三条： 1. 满足标准的json格式规范，满足JSON.parse的解析 - 数据在名称/值对中 - 数据由逗号分隔 - 花括号保存对象 - 方括号保存数组 2. chameleon json为对象，必须包括base字段，根据适配的平台可配置wx|web|weex字段，作为单一端上的特殊配置 ```javascript // 适配微信小程序和weex { \"base\": { }, \"wx\": { }, \"weex\": { } } usingComponents使用规范: 多端实现完全一致组件: usingComponents字段必须放置在base下，不应出现wx|web|weex字段中 多端实现不一致组件: usingComponents字段可以放置在base下，也可以在出现当前端对应的wx|web|weex字段中 注：多端实现完全一致组件 和 多端实现不一致组件 的说明可参见这 "},"terminal/io.html":{"url":"terminal/io.html","title":"导入与导出","keywords":"","body":"导出 即 将Chameleon可重用组件导出给普通项目使用，或者说 某端普通项目里面使用Chameleon可重用组件。 导入 即 在Chameleon可重用项目中导入普通项目产出的组件，或者说 可重用代码Chameleon项目使用某端普通组件。 使用方式 终端 项目框架 导入 导出 说明 微信 原始项目 已支持 微信 MPX 待支持 Web Vue 已支持 Web React 待支持 Web 其他 支持导入，不支持导出 Native Vue 已支持 Native React 待支持 Native Flutter 待支持 Native Objective-C MVVM框架 待支持 Native Android Java MVVM框架 待支持 "},"framework/progressive.html":{"url":"framework/progressive.html","title":"渐进式接入","keywords":"","body":"渐进式接入 跨端有2种需求。 整个项目一套代码实现：第一种业务层需求在各端环境高度类似，原本需要针对不同端重复开发、重复测试，那么使用Chameleon将整个项目”从上至下“都用一套代码运行，针对各端底层极个别差异化实现（使用多态协议）。 场景举例：首页官网、列表详情页等 仅组件一套代码运行：第二种是各端页面需求不一致，却有共同的组件需要重复开发、重复测试，各个端用各自原本框架开发（或者使用Chameleon方案)，使用一套代码开发公用组件，然后各个端可以使用公用组件实现业务 场景举例：分享组件、支付组件、地图组件 整个项目一套代码实现 仅组件一套代码运行 1 webpack项目集成chameleon生态组件 2 利用chameleon开发\b跨端组件 "},"framework/webpack_plugin.html":{"url":"framework/webpack_plugin.html","title":"webpack集成","keywords":"","body":"webpack集成 通过以下步骤，可以让webpack项目中使用chameleon的任意组件。 1 安装npm包 npm i easy-chameleon chameleon-ui-builtin 2 执行脚本 node node_modules/\\easy-chameleon/bin/index.js，该脚本会执行检测，安装未安装的第三方npm包 3 .babelrc 的preset 添加flow, chameleon中用了flow语法，如果需要用到chameleon-api，建议配置babel-plugin-chameleon-import插件实现按需加载。例如： { \"presets\": [ \"flow\", [\"env\", { \"targets\": { \"browsers\": [\"> 1%\", \"last 2 versions\", \"not ie 4 入口代码中，引入代码 import 'easy-chameleon/entry/web_global.js'; 5 修改webpack配置文件,easy-chameleon提供了getConfig\b方法获取webpack配置\b，利用webpack-merge将项目原有webpack配置与getConfig方法获取的配置进行合并，例如： const merge = require('webpack-merge') const {getConfig} = require('easy-chameleon'); devWebpackConfig = merge(devWebpackConfig, getConfig({ cmlType: 'web', media: 'dev', hot: true, disableExtract: false, context: path.join(__dirname,'../'), cmss: { rem: false, scale: 0.5 } })) getConfig方法参数 getConfig(Object object) 参数类型默认值必填说明 cmlTypeString\b是端类型，可选值为web|wx|weex mediaString\b是构建模式，可选值为dev|build hotBooleanfalse\b否\b是否开启热更新，只在web端生效 disableExtractBooleanfalse\b否\b不提取css文件 cmssObject\b否\bcmss处理的配置\b，参见下方cmss对象属性列表 wxConfigObject\b否微信端构建配置，参见下方wxConfig对象属性列表 cmss 对象属性列表 参数类型默认值必填说明 remBooleantrue\b否将cpx以75cpx=1rem为标准转换成rem scaleNumber0.5\b否当rem为false时，scale将生效，将cpx乘以scale为px wxConfig 对象属性列表 参数类型默认值必填说明 entryArray[String]\b是指定输出的组件入口，以项目根目录下的相对路径,会寻找指定路径下的cml文件进行编译 outputPathString\b否输出路径 示例 详细示例戳这里webpack集成chameleon "},"framework/compont_export.html":{"url":"framework/compont_export.html","title":"组件导出应用","keywords":"","body":"组件导出 这里介绍的是第二种场景，将 CML 组件导出到某个端使用。 命令行 cml web export 执行web端组件导出 cml weex export 执行weex端组件导出 cml wx export 执行wx端组件导出 配置 在chameleon.config.js中增加export配置，即可自定义组件导出配置,可配置项参考下表： 配置项 类型 说明 entry Array 组件导出的入口目录，项目根目录的相对路径 outputPath String 组件导出目录，绝对路径 publicPath String 公共资源地址 hash Boolean 导出文件名是否带hash，默认true minimize Boolean 导出文件名是否压缩，默认true disableExtract Boolean 不拆分css，默认false 导出组件 chameleon组件导出目录结构如下： ├── dist | ├── export │ │ ├── platform (web、weex、wx ...) │ │ │ ├── common | │ │ │ ├── web_global.js [仅导出web端组件时存在，需要在入口文件中引用] | │ │ │ ├── web_global.css [会在web_global.js中引用] │ │ │ ├── 组件目录 │ │ │ └── 资源目录 下面是在webpack+vue环境下引用chameleon导出组件的示例： 假设目前已经通过chameleon项目导出了c-header组件，将组件移动到webpack+vue的环境后，需要进行一下几步操作： 假设是web端组件，则首先需要在入口文件中引用web_global.js 在需要使用组件的地方引用组件即可 Bug&Tips .babelrc配置中去掉module: false 由于生产模式组件为编译后的模块，所以尽量使用线上资源 示例 详细示例戳这里普通项目使用跨端组件 "},"terminal/web/framework.html":{"url":"terminal/web/framework.html","title":"Web 框架","keywords":"","body":"web 框架 组件开发模式 具体如何引入请移步web组件接入 "},"terminal/web/component.html":{"url":"terminal/web/component.html","title":"Web 组件接入","keywords":"","body":"web端组件接入 chameleon允许在web端多态组件中直接引入原生vue组件，一方面是为了增加代码重用度，另一方面则是方便渐进式地迁移使用chamelon。 为什么要接入web端组件 chameleon作为跨端框架，将各端相同性及差异性进行统一封装形成chameleon的规范，但即使是这样，我们也没有办法百分百地避免差异，这样的差异可能来自产品的要求、技术的实现等等，由此chameleon提出了组件多态协议，在多态组件实现中，直接引用原生组件，降低开发成本。 怎么引入web端组件 在chameleon中使用组件只需要在组件配置中写入依赖的子组件，下面是web端组件引用vue单文件组件的示例： ... { \"base\": { \"usingComponents\": { \"v-list\": \"/components/vue-components/v-list\" } } } {{l}} class Index { props = { list: { type: Array, default: function() { return [1, 2, 3, 4] } } } }; export default new Index(); 需要注意的是组件路径需要写到.vue层级，但是不带后缀。 示例 详细示例戳这里多态组件扩展 "},"terminal/wx/framework.html":{"url":"terminal/wx/framework.html","title":"微信小程序框架","keywords":"","body":"微信小程序框架 组件开发模式 具体如何引入请移步小程序组件接入 "},"terminal/wx/component.html":{"url":"terminal/wx/component.html","title":"小程序组件接入","keywords":"","body":"小程序组件接入 chameleon允许在多态组件中引入原生微信小程序组件，对于已经熟悉小程序组件开发的朋友将非常easy，之前封装的微信小程序组件可以直接使用，微信小程序相关的ui库可以直接使用，微信小程序自带的组件也可以直接使用。 为什么要接入微信小程序组件 多态组件存在的差异不过来自于各端需求不同，又或是各端实现方式的不同。微信小程序组件的接入跟第二个问题完美契合，在原有的小程序开发过程中或许已经产出了常用组件，又或是使用着某个微信小程序的组件库，当使用chameleon进行开发时，避免了二次开发原有组件的成本。 怎么引入微信小程序组件 第一类是微信小程序支持的组件，比如view text等，详细请查看微信小程序组件列表，如果这样的组件已经满足开发需求，那么就可以直接使用了： {{l}} 第二类是原有的组件，首先你需要将组件复制到chameleon项目中，然后只需要在chameleon组件中声明式引入该组件即可使用。 还是以list组件为例，假设原有封装好的微信小程序的组件custom-list，目录结构如下： ├── components // 组件文件夹 | ├── custom-list | | ├── custom-list.wxml | | ├── custom-list.wxss | | ├── custom-list.js | | └── custom-list.json 那么，在list.wx.cml中可以直接引用： ... { \"base\": { \"usingComponents\": { \"custom-list\": \"/components/custom-list/custom-list\" } } } 需要注意的是组件路径需要写到.wxml层级，但是不带后缀。 第三类是微信小程序的组件库，这里以iVew Webapp为例，首先需要将其代码下载下来放到chameleon项目中，假设目录结构如下： ├── components // 组件文件夹 | ├── iview | | ├── action-sheet | | | ├── index.js | | | ├── index.json | | | ├── index.wxml | | | └── index.wxss | | ├── alert | | ├── avatar | | └── ... 这里我们需要使用action-sheet组件只需要如下即可： ... { \"base\": { \"usingComponents\": { \"action-sheet\": \"/components/iview/action-sheet/index\" } } } 需要注意的是组件路径需要写到.wxml层级，但是不带后缀。 示例 详细示例戳这里多态组件扩展 "},"terminal/alipay/framework.html":{"url":"terminal/alipay/framework.html","title":"支付宝小程序框架","keywords":"","body":"支付宝小程序框架 组件开发模式 具体如何引入请移步alipay组件接入 "},"terminal/alipay/component.html":{"url":"terminal/alipay/component.html","title":"小程序组件接入","keywords":"","body":"小程序组件接入 chameleon允许在多态组件中直接引入支付宝小程序组件，如果你已经封装了支付宝小程序的组件，如果你已经在用支付宝小程序的组件库，不用担心，在chameleon项目中你仍然可以使用。 为什么要接入支付宝小程序组件 多态组件存在的差异不过来自于各端需求不同，又或是各端实现方式的不同。支付宝小程序组件的接入跟第二个问题完美契合，在原有的小程序开发过程中或许已经产出了常用组件，又或是使用着某个支付宝小程序的组件库，当使用chameleon进行开发时，避免了二次开发原有组件的成本。 怎么引入支付宝小程序组件 第一类是支付宝小程序支持的组件，比如view text等，详细请查看支付宝小程序组件列表，如果这样的组件已经满足开发需求，那么就可以直接使用了： {{l}} 第二类是原有的组件，首先你需要将组件复制到chameleon项目中，然后只需要在chameleon组件中声明式引入该组件即可使用。 还是以list组件为例，假设原有封装好的支付宝小程序的组件custom-list，目录结构如下： ├── components // 组件文件夹 | ├── custom-list | | ├── custom-list.axml | | ├── custom-list.acss | | ├── custom-list.js | | └── custom-list.json 那么，在list.alipay.cml中可以直接引用： ... { \"base\": { \"usingComponents\": { \"custom-list\": \"/components/custom-list/custom-list\" } } } 需要注意的是组件路径需要写到.axml层级，但是不带后缀。 示例 详细示例戳这里多态组件扩展 "},"terminal/baidu/framework.html":{"url":"terminal/baidu/framework.html","title":"百度小程序框架","keywords":"","body":"百度小程序框架 组件开发模式 具体如何引入请移步baidu组件接入 "},"terminal/baidu/component.html":{"url":"terminal/baidu/component.html","title":"小程序组件接入","keywords":"","body":"小程序组件接入 chameleon允许在多态组件中直接引入百度小程序组件，如果你已经封装了百度小程序的组件，如果你已经在用百度小程序的组件库，不用担心，在chameleon项目中你仍然可以使用。 为什么要接入百度小程序组件 多态组件存在的差异不过来自于各端需求不同，又或是各端实现方式的不同。百度小程序组件的接入跟第二个问题完美契合，在原有的小程序开发过程中或许已经产出了常用组件，又或是使用着某个百度小程序的组件库，当使用chameleon进行开发时，避免了二次开发原有组件的成本。 怎么引入百度小程序组件 第一类是百度小程序支持的组件，比如view text等，详细请查看百度小程序组件列表，如果这样的组件已经满足开发需求，那么就可以直接使用了： {{l}} 第二类是原有的组件，首先你需要将组件复制到chameleon项目中，然后只需要在chameleon组件中声明式引入该组件即可使用。 还是以list组件为例，假设原有封装好的百度小程序的组件custom-list，目录结构如下： ├── components // 组件文件夹 | ├── custom-list | | ├── custom-list.axml | | ├── custom-list.acss | | ├── custom-list.js | | └── custom-list.json 那么，在list.baidu.cml中可以直接引用： ... { \"base\": { \"usingComponents\": { \"custom-list\": \"/components/custom-list/custom-list\" } } } 需要注意的是组件路径需要写到.swan层级，但是不带后缀。 示例 详细示例戳这里多态组件扩展 "},"terminal/reactnative/framework.html":{"url":"terminal/reactnative/framework.html","title":"ReactNative框架","keywords":"","body":""},"chameleon_client/introduction.html":{"url":"chameleon_client/introduction.html","title":"Native渲染能力接入","keywords":"","body":"Chameleon SDK 端渲染器支持React-Native模式和Weex模式，功能主要包含： "},"chameleon_client/integration.html":{"url":"chameleon_client/integration.html","title":"Chameleon SDK接入","keywords":"","body":"使用Chameleon的渲染能力，需要集成对应平台的SDK。请在左侧目录中根据你需要接入的平台来查看文档。 "},"chameleon_client/ios_integration.html":{"url":"chameleon_client/ios_integration.html","title":"iOS","keywords":"","body":"功能介绍 Chameleon iOS SDK使用Weex、ReactNative与WebView作为基础渲染引擎，提供了基础的组件功能之外，还支持用户扩展自己的功能组件。 集成 环境要求 Chameleon最低支持的iOS deployment target为：iOS 9.0 Chameleon使用Cocoapods进行管理，使用npm管理react_native。 组件名 依赖版本 备注 Cocoapods 1.3.1 - npm 最新版本即可 - WeexSDK 0.19.0.2 - react_native 0.57.6 - react 16.6.1 - 详细集成 当sdk下载下来后，首先进入/chameleon-sdk-iOS/Chamleon/react_native,并运行npm install进行更新。（这也是react_native的更新办法。） 接下来我们以demo工程为例（要注意工程路径位置,在工程实际配置中需要注意 :path 的内容）。 在Podfile中，写入： platform :ios, '9.0' target 'Chameleon_Example' do #Chameleon pod 'Chameleon', :path => '../Chamleon/' #如果需要Weex，则写入weex依赖。 pod 'WeexSDK', '~> 0.19.0.2' #如果需要react_native，则写入react_native依赖。 pod 'React', :path => '../Chamleon/react_native/node_modules/react-native', :subspecs => [ 'Core', 'CxxBridge', # 如果RN版本 >= 0.45则加入此行 'DevSupport', # 如果RN版本 >= 0.43，则需要加入此行才能开启开发者菜单 'RCTText', 'RCTNetwork', 'RCTWebSocket', # 这个模块是用于调试功能的 ] pod 'yoga', :path => '../Chamleon/react_native/node_modules/react-native/ReactCommon/yoga' pod 'DoubleConversion', :podspec => '../Chamleon/react_native/node_modules/react-native/third-party-podspecs/DoubleConversion.podspec' pod 'glog', :podspec => '../Chamleon/react_native/node_modules/react-native/third-party-podspecs/GLog.podspec' pod 'Folly', :podspec => '../Chamleon/react_native/node_modules/react-native/third-party-podspecs/Folly.podspec' end 将podfile保存，并运行pod install。 常见问题 Multiple commands produce Showing All Messages :-1: Multiple commands produce 'XXXXX': 1) Target 'Chameleon_Example' has create directory command with output 'XXXXp' 2) That command depends on command in Target 'Chameleon_Example': script phase “[CP] Copy Pods Resources” 解决办法：删除 工程->Build Phrases->[CP] Copy Pods Resources->Output files下的copy路径。 功能概览 项目目录 描述 作用 Chamleon SDK源码与依赖文件夹 Example react_native依赖 Chamleon/sdk_src 目录 功能描述 CMLSDKEngine类 初始化SDK、注册自定义的module 等功能 CMLCommon Chameleon抽象层。抽象了基础的渲染页面、缓存、配置、预加载等功能。 CMLReactNative 针对ReactNative额外配置的部分 CMLWeex 针对Weex额外配置的部分 CMLWeb 针对WebView额外配置的部分 提供功能 Bundle预加载 先设置预加载地址 [CMLEnvironmentManage chameleon].weexService.config.prefetchContents = @[@\"http%3A%2F%2F172.22.139.32%3A8000%2Fweex%2Fchameleon-bridge.js%3Ft%3D1546502643623\"]; 开始预加载 [[CMLEnvironmentManage chameleon].weexService setupPrefetch]; 自动降级 当Bundle下载失败、渲染出现严重错误时，会自动降级至H5。 降级设计图 本地bundle降级 当H5渲染失败时，倘若设置了默认的本地bundle，会使用本地bundle进行降级。 主动降级 当渲染出现错误时，FE可以通过JSBridge通知客户端触发降级。 功能扩展 使用+ (void)registerModule:(NSString *)moduleName className:(NSString *)className;注册自己的扩展。 使用说明 初始化SDK [CMLSDKEngine initSDKEnvironment]; 设置渲染引擎类型 [CMLEnvironmentManage chameleon].serviceType = CMLServiceTypeWeex; 设置预加载环境 [CMLEnvironmentManage chameleon].weexService.config.prefetchContents = @[@\"http%3A%2F%2F172.22.139.32%3A8000%2Fweex%2Fchameleon-bridge.js%3Ft%3D1546502643623\"]; 设置预加载 [[CMLEnvironmentManage chameleon].weexService setupPrefetch]; "},"chameleon_client/android_integration.html":{"url":"chameleon_client/android_integration.html","title":"Android","keywords":"","body":"Android SDK 简介 android 端的实现思路是采用目前比较流行的一些 native 渲染引擎作为底层支持，同时扩展一些一般工程通用的基础能力。目前支持的渲染引擎是 weex，即将支持 react native，使用时二者选其一作为项目的 native 渲染引擎。 github地址&#x1F449;点这里 1. 项目结构 项目一级目录结构如下： |+ app SDK使用示例 |+ cmlsdk SDK接入层，抽象 Chameleon 引擎能力、实现通用扩展能力 |+ cmlweex 包装 weex 渲染引擎 |+ cmlweb 包装 web 渲染引擎 |+ cmlrn 包装 react native 渲染引擎 |+ js-bundle-mgr 实现 js bundle 预加载、缓存 |+ rich-text-component 富文本组件 |+ sdk-image 图片选择、图片拍摄组件 |+ sdk-location 位置组件 cmlsdk 模块单独拿出来看下目录结构： |- cmlsdk |+ adapter 定义了扩展能力的接口以及默认实现，无默认实现的能力需要第三方项目根据自己的实际业务需求去实现 |+ bridge 定义了 js 和 native 通信的接口，实现协议相关的处理能力，以及实现了协议层使用入口 |+ bundle js bundle 相关定义，目前只有一个类用来描述 js bundle 相关信息 |+ common 通用能力的基础封装类 |+ container 渲染容器的抽象能力定义 |+ extend Chameleon 提供的一些能力 |+ module 扩展能力管理，收集 sdk 默认提供的以及第三方用户自己实现的 module，根据 bridge 层指令执行具体某个 module 的某个 method |+ utils 工具类集合 |+ widget 自定义的widget，目前只有一个 title bar，用做 webview 渲染容器的action bar |- CmlBaseLifecycle 生命周期的接口定义 |- CmlConstant 常量定义 |- CmlEngine Chameleon SDK 使用入口 |- CmlEnvironment 运行环境和运行参数配置入口、扩展能力设置入口 |- CmlInstanceManage 页面运行实例的管理类，每一个容器实例运行时，其对应的Instance会注册到这里 |- ICmlEngine 引擎的抽象接口 |- ICmlInstance 容器实例抽象接口 |- ICmlActivityInstance 全屏容器实例抽象接口 |- ICmlViewInstance 视图容器实例抽象接口 项目整体架构如下图所示： 2. Chameleon 使用 此部分可以参看手把手系列之《变色龙SDK使用范例》 3. 基础类说明 3.1 CmlEngine 此类是 Chameleon/kəˈmiːlɪən/ SDK 的入口类，提供基本的初始化入口和 Chameleon容器的调起能力。具体包含以下能力 SDK 初始化入口 调起渲染容器 初始化预加载列表 注册扩展module 3.2 CmlEnvironment CmlEnvironment 主要提供了开发期间需要的一些能力，如 调试开关 降级开关 缓存开关 以及一些常量的定义，如 预加载的最大缓存 运行时的最大缓存 CmlEnvironment 一个非常重要的能力是提供了对 adapter 设置和获取能力，方便使用者实现自己的适配模块。如加载图片，WebSocket，图片加载，跳转等功能。开发者可以根据自己的需要，实现对应的接口并注册到SDK中使用。 接口 功能 默认实现 ICmlDegradeAdapter 降级 不提供默认实现，示例 CmlDegradeDefault 默认会关闭 native 渲染容器，打开 Web 容器，加载降级url ICmlImgLoaderAdapter 图片加载 CmlDefaultImgLoaderAdapter ，默认使用 Glide，需要用户手动集成 Glide CmlLoggerAdapter 日志 CmlLoggerDefault，默认使用系统 log 输出 ICmlNavigatorAdapter url 跳转 默认使用 Intent.ACTION_VIEW 处理 ICmlStatisticsAdapter 统计信息输出 没有默认实现，不关心可以不用实现 ICmlWebSocketAdapter WebSocket CmlDefaultWebSocketAdapter，默认使用 OkHttp3，需要用户手动集成 OkHttp3 3.3 module 功能：通过注册module提供原生能力的扩展 原理：依赖bridge进行协议通信，根据不同module进行协议处理分发 module，扩展原生能力 module注册 必须注册CmlEngine.registerModule(Class moduleClass) 不强制要求添加@CmlModule,未添加时会使用默认设置 不建议在运行中动态注册module module名称 默认使用module的类名 配置module名称，添加注解@CmlModule(alias = \"name\") module实例 默认为实例全局唯一，即无论有多少instance都会使用同一个module实例 配置全局性，添加注解@CmlModule(global = false) module组合 针对极特殊情况，允许多个class共用一个module名称 必须有且只有一个class作为module，所有相关class均会使用该moduel配置 其余class必须使用@CmlJoin(name = \"name\")，指定需要关联的moduel名称 每个class实例之间无关联，仅会在使用时再创建实例 method，提供原生能力方法 method注册 自动注册module类中所有的public方法 不强制要求添加@CmlMethod,未添加时会使用默认设置 如果不希望方法被误添加，需要在方法上添加@CmlIgnore method名称 默认使用method方法名 配置method名称，添加注解@CmlMethod(alias = \"name\") method线程 默认运行在主线程 配置method线程，添加注解@CmlMethod(uiThread = false) param，原生能力方法所需要的参数 param类型 针对Context、ICmlInstance等上下文类型，会根据调用环境进行查找替换 对于CmlCallback的类型，会构建对应的回调，需要自行处理回调 其余类型会根据bridge传递的参数进行处理 param参数 根据birdge传递的数据，根据参数类型进行转化 目前可转化的类型为JSONObject、String 如果要直接转为对象，需要设置CmlJsonAdapter或接入相应json库 param字段 只想获取传递数据中的某一个对象时，可以使用@CmlParam 添加@CmlParam(name = \"name\")，设置该参数获取的字段 添加@CmlParam(admin = \"admin\")，设置该参数默认值 4. JsBundleMgr JsBundleMgr是一个对js进行下载、缓存的一个模块，根据协议来实现js增量更新功能。主要有以下内容 | |——cache 基于DiskLrucache来实现缓存功能 |——code js代码的获取及管理 |——net 采用httpUrlConnect实现下载功能 |——utils 工具包 |——CmlJsBundleConstant 常量的管理 |——CmlJsBundleEngine 实现了CmlJsBundleManager接口，入口类 |——CmlJsBundleEnvironment 当前环境的设置，如debug环境等 |——CmlJsBundleManager 实现此接口可自己定义JsBundle的管理 |——CmlJsBundleMgrConfig 配置类，设置预加载js路径、缓存大小等，默认预加载及运行时缓存大小是4M，可自行设置 4.1 code 对js代码进行预加载、获取、缓存的管理。在该包里，我们将拿到的url根据协议来拆分成多个url1、url2等，然后在根据url1、url2等来获取对应的js代码，首先从本地缓存里获取去寻找对应的js代码，如果不存在则从网络去下载并保存在本地 utils 一些文件管理、拆分url、网络判断的工具类 CmlCodeUtils：获取到的url、code的拆解及合并 CmlFileUtils：sd卡及缓存目录的判断 CmlLogUtils：Log的实现 CmlNetworkUtils：当前网络状态的判断，如Wi-Fi、4g等 CmlUtils：Md5的生成、主线程判断等等 4.2 CmlJsBundleConstant 缓存文件名、预加载优先级的管理，预加载优先级有以下三种类型 普通（PRIORITY_COMMON）：非Wi-Fi情况不预加载 强预加载（PRIORITY_FORCE）：无论什么网络情况都预加载 强预加载+预解析（PRIORITY_FORCE_MAX）：目前未用到 4.3 CmlJsBundleEngine 实现了CmlJsBundleManager接口，主要有以下三个方法 initConfig(Context,CmlJsBundleMgrConfig)：初始化config，主要是设置预加载url、预加载缓存、运行时缓存的设置，预加载及运行时缓存默认为4M startPreload()：开始预加载，目前预加载成功或者失败并没有任何信息返回，只能查看log进行分析 getWXTemplate(String,CmlGetCodeStringCallback)：获取js代码 4.4 CmlJsBundleManager 实现此接口可以自己定义JsBundleMgr的实现 4.5 使用 添加依赖 compile 'com.didiglobal.chameleon:js-bundle-mgr:latest.version' 预加载 CmlJsBundleEnvironment.DEBUG = true; List cmlModels = new ArrayList<>(); CmlModel model = new CmlModel(); model.bundle = CmlUtils.parseWeexUrl(url1); model.priority = 2; cmlModels.add(model); model = new CmlModel(); model.priority = 2; model.bundle = CmlUtils.parseWeexUrl(url2); cmlModels.add(model); CmlJsBundleMgrConfig config = new CmlJsBundleMgrConfig.Builder().setPreloadList(cmlModels).build(); CmlJsBundleEngine.getInstance().initConfig(this, config); CmlJsBundleEngine.getInstance().startPreload(); 获取Js代码 CmlJsBundleEngine.getInstance().initConfig(this, new CmlJsBundleMgrConfig.Builder().build()); String url = CmlUtils.parseWeexUrl(url); CmlJsBundleEngine.getInstance().getWXTemplate(url, new CmlGetCodeStringCallback() { @Override public void onSuccess(String codes) { Log.i(TAG, \"onSuccess: \" + codes); } @Override public void onFailed(String errMsg) { Log.i(TAG, \"onFailed: \" + errMsg); } }); 5. 富文本组件 富文本是Chameleon里唯一一个默认注册的组件，主要有以下内容 | |-richinfo 主要是富文本需要定义的协议、点击事件的回调等 |-utils 工具类，主要是加载assets下默认的字体 |-CmlRichTextComponent 继承与与CmlComponent的富文本组件 |-CmlRichTextEngine 富文本入口类， richinfo CmlClickSpanListener：富文本点击事件回调 CmlCustomTypefaceSpan：加载自定义字体 CmlRichInfo：富文本协议及实现 CmlRichInfoSpan：配合CmlRichInfo显示富文本文字，可直接设置给TextView utils CmlFontUtil：主要就是加载自定义字体，如assets下fonts包下的Barlow-Medium.ttf字体 "},"chameleon_client/sdk_api.html":{"url":"chameleon_client/sdk_api.html","title":"SDK独有方法","keywords":"","body":"Chameleon SDK 独有方法 getSDKInfo 获得SDK信息 参数 无 返回值 返回promise 返回值 类型 说明 version String 版本号 inSDK 同步方法，判断webview或native页面是否在sdk环境中，目前只用于内部封装方法使用。 参数 无 返回值 返回值 类型 说明 value Boolean true：在sdk环境中；false：不在sdk环境中 import bridge from 'chameleon-bridge'; const inSDK = bridge.inSDK(); // true/false rollbackWeb 降级到chameleon url对应的h5地址。 callNative(module:String, method:String, args:Object, callback:Function) js调用native sdk import bridge from 'chameleon-bridge'; // 主动调用客户端方法 export function sayHello() { bridge.callNative( 'moduleDemo', // 模块名 'sayHello', // 方法名 {}, // 参数 res => {} // 回调方法 ); } listenNative(module:String, method:String, callback:Function) 监听客户端调用js import bridge from 'chameleon-bridge'; // 监听客户端调用js export function listenTell() { bridge.listenNative( 'moduleDemo', // 模块名 'NaTellJS', // 方法名 res => { // 回调方法中处理返回的数据 } ); } "},"chameleon_client/js_cache.html":{"url":"chameleon_client/js_cache.html","title":"端JS包资源缓存、更新和预加载","keywords":"","body":"端JS包资源缓存、更新和预加载 缓存策略 浏览器在加载静态资源的时候一般的话会使用两种HTTP缓存管理机制： 强制缓存(Cache-Control、Expires) 协商式缓存(ETag、Last-Modified) 类似的，在使用chameleon sdk加载JS包的时候也会提供两种缓存管理机制： 基于LRU的强制缓存 类HTTP的协商式缓存(后续发布) 基于LRU的强制缓存 基于LRU的缓存策略，简单来说就是实现了一个缓存池，每次请求先从缓存池中搜索一下，如果有就直接使用缓存池中的JS包，如果没有，就从网络上请求JS包资源并将资源缓存在缓存池中，每一份JS包缓存按照最后使用时间排序，当缓存池满了以后，将最早使用过的缓存从缓存池中清理出去，保证客户端上的资源占用可控。 如何配置 iOS android 类HTTP的协商式缓存(后续发布) 与普通浏览器实现的协商式缓存类似，用户只需在静态资源服务端配置好静态资源的协商式缓存头部，即可实现与普通浏览器一致的方式使用协商式缓存。 更新策略 当JS包升级迭代需要在客户端内使用最新的包时，在使用两种缓存方式下，相应的存在两周更新方式，下面会详细介绍 强制缓存下的更新： 由于强制缓存，客户端不会主动的去向服务器请求最新的更新包，会导致客户端一直使用老的版本。 为了能够打到规避这种情况，我们提供了一种可供参考的解决方案： 配置文件指纹 设置chameleon.config.js中的hash: true，具体可参考工程化配置之文件指纹，chameleon项目构建出的JS包文件名会类似如下 test_project_c6bdf9074a821f01e70f.js 上线打包出来的JS包 得到以下可以访问的资源地址 https://www.static.com/test_project_c6bdf9074a821f01e70f.js 替换入口资源地址 将入口页面中的chameleon urlwx_addr替换成encodeURIComponent后的最新资源地址即可，比如 原chameleon url: https://www.static.com/test_project.html?wx_addr=https%3A%2F%2Fwww.static.com%2Ftest_project_21f01e70fc6bdf9074a8.js 新的chameleon url https://www.static.com/test_project.html?wx_addr=https%3A%2F%2Fwww.static.com%2Ftest_project_c6bdf9074a821f01e70f.js 最佳实践 由于强制缓存下每次修改都需要修改入口页面的chameleon url中的wx_addr参数，可能会导致修改频繁影响效率，所以建议通过后端读取map.json的方式下发跳转chameleon url进行统一管理。 具体请求过程如下图所示: JS包修改上线后，同时将map.json上线到服务器上 入口页面加载数据时，服务器从map.json文件中查询到要跳转的chameleon url，并与初始化数据合并和下发给入口页面。 入口页面逻辑将接受到的chameleon url作为需要跳转的链接进行使用。 这样每次bundle修改后可以自动完成更新 协商式缓存下的更新： 可以直接使用http的缓存更新策略，不需额外的配置。 预加载 在某些场景下，为了能够让页面更快的呈现在用户面前，需要让客户端提前下载一些js包，这时就需要用到预加载。 如何配置 iOS android 参考《变色龙SDK使用范例》第6节 "},"extend/extend.html":{"url":"extend/extend.html","title":"定制扩展端","keywords":"","body":"定制扩展端 希望扩展百度小程序、头条小程序、react-web？ 你只需按标准流程即可扩展，敬请期待： xxx-runtime ：运行时 xxx-ui: 扩展组件 xxx-api: 基础api xxx-linter: 语法检查器 xxx-parse: 解析器 "},"example/main.html":{"url":"example/main.html","title":"实例","keywords":"","body":"实例 提供手把手教程，帮助开发者快速入门。 "},"example/chameleon-api.html":{"url":"example/chameleon-api.html","title":"API扩展","keywords":"","body":"手把手教你系列- 实现多态API 目前chameleon-api提供的是主要的跨端\b方法，如果你\b在里面没有找到需要的方法，还可以使用多态协议接口多态来进行扩展。今天我们就手把手来实现一个多态api接口。 举例-创建一个获取\b一些信息的跨端接口 我们可以在项目根目录下执行cml init component，选择多态接口，输入文件名称，例如getSomeInfo，生成如下文件结构 ├── components │ ├── getSomeInfo │ │ ├── getSomeInfo.interface 文件内容如下： interface GetSomeInfoInterface { type Info = { env: String, extra: String, myInput: String, } getSomeInfo(input: String): Info; } class Method implements GetSomeInfoInterface { getSomeInfo(input) { // 一些获取的操作，得到信息 return { env: 'web', extra: '其他的信息', myInput: input } } } export default new Method(); class Method implements GetSomeInfoInterface { getSomeInfo(input) { // 一些获取的操作，得到信息 return { env: 'weex', extra: '其他的信息', myInput: input } } } export default new Method(); class Method implements GetSomeInfoInterface { getSomeInfo(input) { // 一些获取的操作，得到信息 return { env: 'wx', extra: '其他的信息', myInput: input } } } export default new Method(); 在interface文件中，\b\b在cml-type=\"interface\"部分规定\b入参和出参的具体类型。在cml-type=\"web|weex|wx\"等\b各自端中实现对应方法。\b即可实现一个可以跨端使用的多态接口。 使用多态接口 在你的项目中可以通过路径引用到该方法，进行使用。 import myApi from 'components/getSomeInfo/getSomeInfo.interface' const someInfo = myApi.getSomeInfo(); // 对获得的信息进行使用 值得一提的是，你可以在每个端自由引入在该端所需的库（你的项目库，npm包，jsbridge等），尽情丰富方法的实现，如在web端，当网页在客户端外的时候，你可以使用\b普通方法进行实现；如果该网页也会出现在客户端内，你可以使用jsbridge对于方法进行\b增强，获得更好的体验。 "},"example/poly.html":{"url":"example/poly.html","title":"多态组件扩展","keywords":"","body":"手把手教你系列- 实现多态 echart 背景介绍 正常情况下大部分功能可以用CML语法即可实现；常常会有特殊情况： 当我们想实现一个特别复杂功能时常常会用到成熟的第三方库 当产品经理需要各端差异化实现需求 类似“分享到朋友圈”功能在小程序、Web、Native天生有底层能力差异 我们这里举例实现一个柱状图图表一般会想到很强大的开源可视化库 echart。 本文讲讲如何在CML项目中优雅的使用echart库，最终实现效果图。 在CML项目中使用第三方库可以基于多态组件来开发。 多态协议的意义我就不做赘述了，直接说怎么使用。 项目初始化 新建一个项目 demo-poly cml init project 在项目中调用组件创建命令： cd demo-poly cml init component 切换选择多态组件 输入echart 此时项目中看到./src/components/echart文件夹 ./src/components └── echart ├── echart.interface ├── echart.web.cml ├── echart.weex.cml └── echart.wx.cml 修改src/pages/index/index.cml文件里面的json配置，引用多态组件 \"base\": { \"usingComponents\": { \"echart\": \"/components/echart/echart\", \"demo-com\": \"/components/demo-com/demo-com\" } } 修改src/pages/index/index.cml文件里面的组件 调用echart组件 修改style标签代码给标签添加宽高 echart{ height: 500px; width: 500px; } 在项目根目录下启动预览cml dev，有效果如下，展现2个组件分别是默认项目初始化放置的和我们刚刚添加的组件。 echart作为多态组件，在web、weex、微信小程序分别展示的是不同文案。 web端效果如下： 多态组件构成介绍 echart.interface：描述echart组件的输入和输出。 默认interface定义了一个组件，参数name的值是一个字符串，事件onshow的值是一个函数，函数的回调是一个Object结构为{value: 字符串}。 /* 定义一个inteface用于描述组件的属性和事件 1、 如何区分组件属性和事件？ 通过类型来区分，事件为函数类型，属性为非函数类型 2、 如何定义组件属性 给interface添加同名的属性即可，指定类型 3、 如何定义组件事件 以事件名称为key值给interface定义属性，该属性是一个函数类型，返回值为void， 定义函数的第一个参数为自定义事件传递的detail对象类型 */ //定义事件detail对象的参数 type EventDetail = { value: String } interface EchartInterface { name: String, onshow(eventDetail: EventDetail): void; } 其中的具体语法参见。 这里我们先不用改。 echart.web.cml、echart.weex.cml、echart.wx.cml：文件是灰度区，它是唯一可以调用下层端组件的CML文件，分别是web、weex、wx三个端的调用入口。建议这一块代码尽量薄，只是用来调用下层端代码，不要编写过于重的代码。 在灰度区的template模板中：可以调用下层组件，传入的属性也可以是各自下层端的语法，绑定的函数回调事件对象也是原始对象。也可以正常使用普通的cml模板语法 在灰度区的script逻辑代码中：可以调用下层端的全局变量和任意方法，以及下层段的生命周期。也可以正常使用普通cml逻辑代码。 在灰度区的style样式代码中：可以使用下层端css语法。也可以正常调用cmss语法。 实现微信echart 我们先修改./src/components/echart/echart.wx.cml实现微信的 echart 功能。 Google搜索到了echarts-for-weixin，我们看该项目的使用文档，我们把该项目下的ec-canvas文件夹拷贝到./src/components/echart文件夹下 ./src/components └── echart ├── ec-canvas │ ├── ec-canvas.js │ ├── ec-canvas.json │ ├── ec-canvas.wxml │ ├── ec-canvas.wxss │ ├── echarts.js │ └── wx-canvas.js ├── echart.interface ├── echart.web.cml ├── echart.weex.cml └── echart.wx.cml 修改./src/components/echart/echart.wx.cml文件里面的json配置，引用微信组件 \"base\": { \"usingComponents\": { \"ec-canvas\": \"./ec-canvas/ec-canvas\" } } 修改cml模板，调用组件 新建./src/components/echart/bar.js，作为统一存放echart图表的配置代码，代码如下： export default function getdata () { return { legend: {}, tooltip: {}, dataset: { // provide data. source: [ ['latte', ...randomize()], ['tea', ...randomize()], ['cocoa', ...randomize()], ['brownie', ...randomize()] ] }, // declare x axis, which is a category axis, mapping // to the first column by default. xaxis: { type: 'category' }, // declare y axis, which is a value axis. yaxis: {}, // declare several series, each of them mapped to a // column of the dataset by default. series: [{ type: 'bar' }, { type: 'bar' }, { type: 'bar' }] } } function randomize () { return [0, 0, 0].map(v => { return math.round(300 + math.random() * 700) / 10 }) } 修改./src/components/echart/echart.wx.cml文件里面的JS代码，编写传递给组件的参数 import * as echarts from './ec-canvas/echarts'; let chart = null; import getBar from './bar' function initChart(canvas, width, height) { chart = echarts.init(canvas, null, { width: width, height: height }); canvas.setChart(chart); chart.setOption(getBar()); return chart; } class Echart implements EchartInterface { props = { name: { type: String, default: '默认值' } } data = { ec: { onInit: initChart } } computed = { } watch = { } methods = { } beforeCreate() { } created() { } beforeMount() { } mounted() { this.$cmlEmit('onshow',{ value: this.name }) } beforeDestroy() { } destroyed() { } } export default new Echart(); 修改./src/components/echart/echart.wx.cml文件里面的style代码，设置宽高 .mychart_dom_bar, .container{ height: 100%; width: 100%; } 此时能看到微信能展现图表了 实现web端echart web端使用vue框架，所以找到echart的vue版本 vue-echarts， 按他说明文档，直接在chameleon项目根目录demo-poly(我创建的project名)下安装组件 npm install vue-echarts --save 打开src/components/echart/echart.web.cml 修改json标签配置，引用组件 { \"base\": { \"usingComponents\": { \"chart\": \"vue-echarts/components/ECharts\" } } } 修改cml模板，调用组件 修改script，设置传入chart组件的参数 import 'echarts/lib/chart/bar' import getBar from './bar' class Echart implements EchartInterface { props = { name: { type: String, default: '默认值' } } data = { bar: getBar(), initOptions: { renderer: 'canvas' } } computed = { } watch = { } methods = { } beforeCreate() { } created() { } beforeMount() { } mounted() { this.$cmlEmit('onshow',{ value: this.name }) } beforeDestroy() { } destroyed() { } } export default new Echart(); 此时web端也能看到图表效果了 实现native weex端echart weex不支持canvas接口，所以无法在weex环境下运行，我们可以用weex的web组件，沿用刚刚我们实现的web端图表地址。 echart.xxx.cml 是灰度cml组件，在微信、web、weex，它分别只能引用小程序组件文件夹、vue组件、weex组件（vue扩展名文件），所以我们先创建一个weex组件。 新建src/components/echart/weex.vue，写入代码 .wrapper { flex-direction: column; padding: 10px; } module.exports = { data: { pagestart: '', pagefinish: '', title: '', error: '', canGoBack: false, canGoForward: false, //这是作者的本机IP h5url: 'http://172.22.139.44:8000/cml/h5/index' }, methods: { onPageStart: function(e) { this.pagestart = e.url; }, onPageFinish: function(e) { this.pagefinish = e.url; this.canGoBack = e.canGoBack; this.canGoForward = e.canGoForward; if (e.title) { this.title = e.title; } }, onError: function(e) { this.error = url; }, onReceivedTitle: function(e) { this.title = e.title; } } } 在./src/components/echart/echart.weex.cml里面修改json标签配置引用刚刚新建的weex.vue组件 { \"base\": { \"usingComponents\": { \"echart\": \"./weex\" } } } 在./src/components/echart/echart.weex.cml里面修改template标签配置调用刚刚新建的weex.vue组件 最终效果如图 最后 同时如果有更多配置参数需要由调用方index.cml传入时，可以再echart.interface中定义更多输入输出的参数，保障各端一致。 基于多态协议开发各端上实现差异较大的一类组件，调用上抹平了差异，同时我们可以各自维护，修改其中一端代码时，不会影响其他端的代码，做到充分隔离。 后期我们可以把这 src/components/echart 单独发布成一个npm包，单拉出来维护 "},"example/gestures.html":{"url":"example/gestures.html","title":"手势拖拽效果","keywords":"","body":"手把手教你系列- 卡片拖拽手势删除效果 背景介绍 手势效果是终端开发的常见需求，这篇文章手把手教你如何快速实现一个手势功能。 最终效果 项目初始化 新建一个项目 demo-gesture cml init project 进入项目 cd demo-gesture 设计数据结构 我们要做一个列表，所以先设计一个数据结构如下： data = { list: [ { // 用作样式名称 className: 'inner-first', // 用作元素位置偏移 transform: { y: 0, x: 0 } , } ] } 写进/src/pages/index/index.cml文件里面逻辑层JS代码里面 class Index { data = { list: [ { className: 'inner-first', transform: { y: 0, x: 0 } }, { className: 'inner-second', transform: { y: 0, x: 0 } }, { className: 'inner-third', transform: { y: 0, x: 0 } }, { className: 'inner-fouth', transform: { y: 0, x: 0 } } ], } methods = { } } export default new Index(); 书写CML使用数据 我们查看CML文档使用列表渲染， 写进/src/pages/index/index.cml文件里面CML代码 {{idx}} 删 书写CMSS 查看CMSS文档，CMSS针对多端情况只能使用 flex 给页面布局， .wrapper{ flex-direction: col; justify-content: space-around; height: 1200cpx; } .inner-first{ background: red; } .inner-second{ background: yellow; } .inner-third{ background: blue; } .inner-fouth{ background: green; } .box{ height: 200cpx; } .txt{ text-align: center; line-height: 50cpx; height: 50cpx; } .remove-btn{ height: 50cpx; width: 50cpx; border: 1px solid hotpink; font-size: 10cpx; border-radius: 50cpx; transform: translate(780cpx, 0) } .rm{ text-align: center; line-height: 50cpx; color: hotpink; } 目前三端效果展现如下 添加手势 我们查看事件绑定文档 给box元素添加事件绑定： c-bind:touchstart=\"eventhandler\" c-bind:touchmove=\"eventhandler\" c-bind:touchend=\"eventhandler\" 添加事件回调函数 methods = { eventHandler(event){ // 获取当前手指位置 let myPreX = event.changedTouches[0].pageX; // 获取当前手指所触摸的Item元素 let index = event.currentTarget.dataset.index; // 获取当前手指所触摸的Item元素的偏移值 let transform = this.list[index].transform; console.log(index); // 手指触摸开始时将上一个X方向偏移设为null if(event.type == 'touchstart'){ preX = null; }else if( event.type == 'touchmove'){ if(preX !== null){ let x = parseInt(transform.x) + myPreX - preX ; //x 100 当手指往左滑动超过100时不允许滑动滑块 if(Math.abs(x) 添加删除按钮事件回调函数 给remove-btn元素添加事件绑定： c-bind:click=\"onRemove\" methods = { onRemove(e){ let index = e.currentTarget.dataset.index; this.list.splice(index, 1); } } /src/pages/index/index.cml 最终全部代码如下： {{idx}} 删 let preX = null; class Index { data = { list: [ { className: 'inner-first', transform: { y: 0, x: 0 } }, { className: 'inner-second', transform: { y: 0, x: 0 } }, { className: 'inner-third', transform: { y: 0, x: 0 } }, { className: 'inner-fouth', transform: { y: 0, x: 0 } } ], } methods = { eventHandler(event){ // 获取当前手指位置 let myPreX = event.changedTouches[0].pageX; // 获取当前手指所触摸的Item元素 let index = event.currentTarget.dataset.index; // 获取当前手指所触摸的Item元素的偏移值 let transform = this.list[index].transform; console.log(index); // 手指触摸开始时将上一个X方向偏移设为null if(event.type == 'touchstart'){ preX = null; }else if( event.type == 'touchmove'){ if(preX !== null){ let x = parseInt(transform.x) + myPreX - preX ; //x 100 当手指往左滑动超过100时不允许滑动滑块 if(Math.abs(x) .wrapper{ flex-direction: col; justify-content: space-around; height: 1200cpx; } .inner-first{ background: red; } .inner-second{ background: yellow; } .inner-third{ background: blue; } .inner-fouth{ background: green; } .box{ height: 200cpx; } .txt{ text-align: center; line-height: 50cpx; height: 50cpx; } .remove-btn{ height: 50cpx; width: 50cpx; border: 1px solid hotpink; font-size: 10cpx; border-radius: 50cpx; transform: translate(780cpx, 0) } .rm{ text-align: center; line-height: 50cpx; color: hotpink; } { } 最终不到150行代码实现三端拖拽效果： "},"example/project.html":{"url":"example/project.html","title":"工程化实例","keywords":"","body":"手把手教你系列 - 工程化配置 前端工程化是前端领域在不断发展摸索过程中，总结出的使用软件工程对项目的开发、上线和维护等阶段中进行管理的集成解决方案。 chameleon根据自身框架特征，设计并完成了一套具有高度自由度、可定制化的自有工程化解决方案，可在以下几个方面针对不同场景进行配置支持。 数据mock 打包构建 文件指纹 代码压缩 项目初始化 按照快速上手新建一个以test_project为名称的项目。 项目的source目录如下： src ├── app │ └── app.cml ├── assets │ └── images │ └── chameleon.png ├── components │ ├── com2 │ │ └── com2.cml │ └── demo-com │ └── demo-com.cml ├── main.js ├── pages │ ├── a │ │ └── a.cml │ └── index │ └── index.cml ├── router.config.json └── store ├── actions.js ├── getters.js ├── index.js ├── mutations.js └── state.js 数据mock 数据mock是前后端分离的基本保障，在快速上手中已经有了比较详细介绍，这里就不在赘述。 打包构建 执行如下命令 $ cml build 打包出来的dist目录结构如下 dist ├── config.json // 各端映射关系表 ├── web // web端部署包 ├── weex // weex端部署包 └── wx // wx端部署包 进入weex包, 并查看weex包内容 $ tree dist/weex dist/weex/ └── test_project_c6bdf9074a821f01e70f.js cml build默认在打包的时候添加文件指纹，因为大多数场景下，静态资源以强缓存的方式会存放到cdn上，使用文件指纹可以避免代码修改后，客户端缓存导致未更新的问题。 从上边的结果上看打包出来的weex bundle文件名已添加上了文件指纹。 不过有些场景下希望不添加文件指纹，比如静态资源为使用协商式缓存的情况。 文件指纹 让我们一起把文件指纹去掉，进入刚才创建项目的根目录，找到并打开根目录下的chameleon.config.js，找到如下代码片段。 weex: { dev: { }, build: { publicPath: `${publicPath}/weex`, apiPrefix }, custom: { publicPath: `${publicPath}/wx`, apiPrefix } } 在weex.build下 增加hash: false的配置 weex: { dev: { }, build: { publicPath: `${publicPath}/weex`, apiPrefix, hash: false }, custom: { publicPath: `${publicPath}/wx`, apiPrefix } } 再次执行 $ cml build $ tree dist/weex/ dist/weex/ └── test_project.js 只需简单的配置，文件指纹即已去除！ 代码压缩 代码压缩作为前端工程师的性能优化利器，chameleon已默认配置了build的阶段的代码压缩。 当然，也有某些场景下需要构建出来的产物不进行代码压缩，比如集成测试的时候，使用压缩前的代码能够最便捷的发现问题，下面操作如何取消代码压缩。 仍旧打开根目录下的chameleon.config.js文件，增加minimize: false参数即达目的。 weex: { dev: { }, build: { publicPath: `${publicPath}/weex`, apiPrefix, hash: false, minimize: false }, custom: { publicPath: `${publicPath}/wx`, apiPrefix } } 再次执行 $ cml build 这时构建出来的代码即为压缩前代码。 "},"example/webpack_output.html":{"url":"example/webpack_output.html","title":"普通项目使用跨端组件","keywords":"","body":"手把手教你系列 - 普通项目使用chameleon跨端dialog组件 背景介绍 这里考虑如下场景，很多基础组件是多端共用的，单独开发则需要维护多套代码，而使用chameleon维护一套跨端ui库，通过组件导出给某一端进行使用，这样提高的开发效率可想而知。本文将一步一步介绍如何导出某一端组件及应用。 项目初始化 关于chameleon-cli的安装及环境配置请参照快速上手，首先使用项目初始化命令cml init project完成项目初始化，然后cd projectName进入项目目录使用cml init component初始化diaolog组件，这里选择普通组件。最终dialog组件效果如下图： web端组件导出及应用 导出 首先是配置chameleon.config.js，增加如下配置: 更多配置请参照组件导出应用 完成配置后进入项目目录，使用cml web export命令执行web端组件导出，导出目录如下： 应用 \b\b组件导出后我们直接用vue-cli创建一个webpack项目，这里使用的是vue-cli@2.9.6。\b初始化\b项目如下图： 现在开始\b增加导出组件的配置。 第一步：修改\b.babelrc文件，删除\bmodules: false，前后对比如下图： 第二步：将common文件夹拷贝至webpack项目资源\b\b目录，并\b在webpack项目的入口文件中引入\bweb_global.js\b，代码如下图： \b现在将前面导出的dialog组件拷贝至webpack项目的组件目录\b下，拷贝后webpack项目目录结构如下图： 然后\bapp.vue文件中直接使用c-dialog组件，代码如下： import CDialog from './components/c-dialog/c-dialog.js' export default { name: 'App', components: { CDialog } } @import \"./components/c-dialog/c-dialog.css\"; 最终\b效果如下图： weex端组件导出及应用 导出 首先是配置chameleon.config.js，为weex端增加如下配置： 更多配置信息请查看组件导出应用，配置好之后在该项目目录下执行cml weex export命令执行weex端组件导出，导出目录如下： 应用 首先通过weex官网提供的weex-toolkit初始化weex项目，初始化项目如下图： 将前面导出的dialog组件拷贝值weex项目的组件目录下，拷贝后目录结构如下图： 然后在index.vue组件中引入并使用c-dialog组件，代码如下： The environment is ready! import HelloWorld from '@/components/HelloWorld' import CDialog from '@/components/c-dialog/c-dialog.js'; export default { name: 'App', components: { HelloWorld, CDialog }, data () { return { logo: 'https://gw.alicdn.com/tfs/TB1yopEdgoQMeJjy1XaXXcSsFXa-640-302.png' } } } .wrapper { justify-content: center; align-items: center; } .logo { width: 424px; height: 200px; } .greeting { text-align: center; margin-top: 70px; font-size: 50px; color: #41B883; } .message { margin: 30px; font-size: 32px; color: #727272; } 最终效果如下图： 微信端组件导出及应用 导出 首先在chameleon.config.js增加微信端导出配置，如下图： 更多配置信息请查看组件导出应用，配置好之后在该项目目录下执行cml wx export命令执行weex端组件导出，导出目录如下： 应用 首先通过微信小程序开发者工具初始化项目，如下图： 将导出的组件文件目录拷贝至微信小程序项目根目录下，拷贝后目录结构如下图： 这里我们直接在微信默认创建的首页中使用，代码如下： // index.json { \"usingComponents\": { \"CDialog\": \"/wx/components/c-dialog/c-dialog\" } } // index.wxml 获取头像昵称 {{userInfo.nickName}} {{motto}} 最终效果如下图： 注意 在使用组件导出时，组件所用静态资源必须为线上资源。 "},"example/webpack_plugin.html":{"url":"example/webpack_plugin.html","title":"webpack集成chameleon","keywords":"","body":"手把手教你系列 - webpack集成chameleon 背景介绍 在webpack项目中使用chamelon组件有两种方式，一种是将组件导出到项目中进行使用，而另一种是直接在webpack项目中集成chameleon，为其增加chameleon的编译能力，集成后可直接使用chamelon的语法进行开发。本文将一步一步介绍如何集成chameleon及使用已有chameleon组件和开发chameleon组件。 项目初始化 首先需要初始化一个webpack项目，这里直接使用vue-cli，初始化项目如下图： 集成chameleon 第一步：在webpack项目下执行npm i easy-chameleon chameleon-ui-builtin命令，安装集成依赖。 第二步：执行node node_modules/\\easy-chameleon/bin/index.js命令，安装chameleon依赖。 第三步：修改.babelrc文件，为preset添加flow，在chameleon中使用了flow语法，下图是修改前后对比： 第四步：在入口文件中引入easy-chameleon/entry/web_global.js文件，代码如下： import 'easy-chameleon/entry/web_global.js' import Vue from 'vue' import App from './App' Vue.config.productionTip = false new Vue({ el: '#app', components: { App }, template: '' }) 第五步：修改webpack配置文件，增加chameleon编译能力。 修改webpack.base.conf.js文件，代码如下： const { getConfig } = require('easy-chameleon'); const merge = require('webpack-merge') module.exports = merge(baseConfig, getConfig({ cmlType: 'web', media: 'dev', hot: true, disableExtract: false, context: path.join(__dirname,'../'), cmss: { rem: false, scale: 0.5 } })) 这里只贴出了该文件中所增加的代码，其中baseConfig为webpack原有配置。至此，webpack项目已成功集成chameleon。 使用已有chameleon组件 我们已经使用chameleon开发出一套ui组件库，这里我们直接在webpack中使用。 首先，执行npm install cml-ui命令安装chameleon-ui组件库，安装成功后我们直接在app.vue中使用，代码如下： import HelloWorld from './components/HelloWorld' import CDialog from 'cml-ui/components/c-dialog/c-dialog' export default { name: 'App', components: { HelloWorld, CDialog } } #app { font-family: 'Avenir', Helvetica, Arial, sans-serif; -webkit-font-smoothing: antialiased; -moz-osx-font-smoothing: grayscale; text-align: center; color: #2c3e50; margin-top: 60px; } 最终效果如下图： 开发chameleon组件 在组件目录下新建.cml文件，chameleon组件模版如下： class Chameleon { data = { } computed = { } watch = { } methods = { } beforeCreate() { } created() { } beforeMount() { } mounted() { } beforeDestroy() { } destroyed() { } } export default new Chameleon(); { \"base\": { \"usingComponents\": { } } } 我在项目中新建了一个HelloChamelon.cml组件，开发完成后在App.vue中引入使用，代码如下: import HelloChameleon from './components/HelloChameleon' export default { name: 'App', components: { HelloChameleon } } #app { font-family: 'Avenir', Helvetica, Arial, sans-serif; -webkit-font-smoothing: antialiased; -moz-osx-font-smoothing: grayscale; text-align: center; color: #2c3e50; margin-top: 60px; } 最终效果如下图： \b注意 在chameleon\b组件开发中\b样式单位为cpx，编译时默认会转为rem，\b具体单位转换规则参考项目配置中的\bcmss处理。 "},"example/web_wx.html":{"url":"example/web_wx.html","title":"只跨web和小程序的应用","keywords":"","body":"只跨web和小程序的应用 背景介绍 通常情况下，cml框架会生成跨H5、小程序、客户端的应用。为了H5、小程序、客户端初始样式呈现效果一致，cml会添加一致性基础样式。在开发模式下，构建会严格校验CMSS语法，只允许书写跨H5、小程序、客户端都通用的 CMSS 规则。因此，受限于客户端的 CMSS 渲染能力，开发会有诸多限制，另一方面，当开发者只需要跨H5和小程序应用时，开发会变得很轻便。 通过下面的表格，展示 CMSS 跨端 能力差异： CSS属性 H5 小程序 weex 布局 all all flexbox 盒模型 all all 只支持display:border-box float浮动 ✅ ✅ ❌ display:inline-block|none ✅ ✅ ❌ ID选择器 ✅ ✅ ❌ 类选择器 ✅ ✅ ✅ 属性选择器 ✅ ✅ ❌ 级联选择器、派生选择器(后代、子元素、相邻兄弟) ✅ ✅ ❌ 选择器分组 ✅ ✅ ✅ 伪类(:active|:focus) ✅ ✅ ✅ 伪类(:hover|:link|:visited|:first-child|:lang) ✅ ✅ ❌ 伪元素(:first-letter|:first-line|:before|:after) ✅ ✅ ❌ 百分比定值 ✅ ✅ ❌ line-height:1 ✅ ✅ ❌ 尺寸 px|rem|em|vw|vh px|rpx px !important ✅ ✅ ❌ 项目初始化与配置 项目初始化 以merge config的方式修改项目根目录下的 chameleon.config.js，如下：cml.config.merge({ platforms: [\"web\",\"wx\"] }) CMSS 此时，CMSS 语法和可用属性，不再受限于客户端的渲染。CMSS 遵循 W3C 层叠样式表 (Cascading Style Sheets，缩写为 CSS）规范，在此基础上，小程序WXSS会有一些限制。 一致性基础样式可选 如果您希望去除小程序、客户端的的一致性基础样式，修改项目根目录下的 chameleon.config.js，如下： cml.config.merge({ baseStyle: { wx: false, web: true, weex: false } }) "},"example/android_example.html":{"url":"example/android_example.html","title":"Android Chameleon SDK","keywords":"","body":"手把手教你系列- 变色龙SDK使用范例 以一个小demo工程，讲述变色龙SDK的使用方式，引领轻松入门。Demo 工程在根目录 app 目录下，用 Android Studio 导入并 run 起来后，再对照以下说明文档看会好理解。 1. compile 依赖添加 1.1 项目根目录 build.gradle 里添加 maven 仓库地址 buildscript { repositories { jcenter() maven { url 'https://maven.google.com/' } } ... } allprojects { repositories { maven { url 'https://maven.google.com/' } jcenter() mavenCentral() ... } } 1.2 在 app 模块的 build.gradle 里添加依赖 1.2.1 首先添加如下依赖 dependencies { ... compile \"com.android.support:support-v4:$SUPPORT_VER\" compile \"com.android.support:appcompat-v7:$SUPPORT_VER\" compile \"com.android.support:recyclerview-v7:$SUPPORT_VER\" compile \"com.didiglobal.chameleon:cmlsdk:$VERSION\" compile \"com.didiglobal.chameleon:cmlweb:$VERSION\" } 1.2.2 渲染引擎选择 目前只针对weex引擎实现的比较完整，React Native即将支持。 Chameleon SDK 当前依赖的weex 和 rn 版本分别是 weex -> com.taobao.android:weex_sdk:0.18.0 rn sdk -> com.facebook.react:react-native:0.57.6 如果采用 weex 作为渲染引擎，还需要添加如下依赖 dependencies { ... compile \"com.didiglobal.chameleon:cmlweex:$VERSION\" } 如果采用 react native 作为渲染引擎(即将支持)，则需要添加如下依赖 dependencies { ... compile \"com.didiglobal.chameleon:cmlrn:$VERSION\" } 注意，上述渲染引擎依赖只能二者选其一。com.android.tools.build:gradle 3.0 以后的版本用 implementation 替换 compile，完整的依赖列表可参考示例工程。 2. 权限添加及 android 6.0 以上系统授权 Chameleon SDK 已经添加了如下权限，android 6.0 以上系统版本需要在调起相关页面后手动授权。 3. 混淆 参考示例工程 4. 初始化入口 实现自己的 Application 类，在应用启动的时候进行初始化调用。 4.1 Application demo public class MyApplication extends Application implements CmlConfig { @Override public void onCreate() { super.onCreate(); CmlEngine.getInstance().init(this, this); } @Override public void configAdapter() { // 开发阶段可以禁用js bundle缓存 CmlEnvironment.CML_ALLOW_BUNDLE_CACHE = false; // 开发阶段手动降级测试 // CmlEnvironment.CML_DEGRADE = false; // 注册降级Adapter CmlEnvironment.setDegradeAdapter(new CmlDegradeDefault()); // CmlEnvironment.setToastAdapter(xxx); // CmlEnvironment.setLoggerAdapter(xxx); // CmlEnvironment.setDialogAdapter(xxx); // CmlEnvironment.setNavigatorAdapter(xxx); // CmlEnvironment.setStatisticsAdapter(xxx); // CmlEnvironment.setImageLoaderAdapter(xxx); } @Override public void registerModule() { CmlEngine.getInstance().registerModule(ModuleDemo.class); } } 4.2 将 Application 添加到 AndroidManifest.xml 4.3 适配器的实现 适配器是暴露给SDK使用者的一组接口，用于提供扩展SDK的能力，其中一部分接口提供了默认实现，未提供默认实现的需要使用者自己实现并注册到SDK中。 以下适配器提供了默认实现 http / json / log / modal / storage / thread / websocket / imagloader 以下适配器未提供默认实现 navigator / degrade / statistics 以降级适配器举例，只需要两个步骤： 新建类 CmlDegradeDefault，实现接口 ICmlDegradeAdapter 在 MyApplication 的 configAdapter 方法里注册适配器。 4.4 module 的实现 module 的SDK层实现在如下位置： module 的实现主要分两个步骤，一个是 native 侧的代码实现，一个是 js 侧的代码实现。同时，native 和 js 的通信是双向的，及native 可以主动调用 js 侧的方法，js 侧也可以主动调用 native 侧的方法。 4.4.1 native 侧的实现 module 的实现需要先了解3个注解 @CmlModule 标注这个类是扩展模块 @CmlMethod 标注可供JS侧调用的方法 @CmlParam 标注调用的参数 以下是一个 module 扩展示例 @CmlModule(alias = \"moduleDemo\") public class ModuleDemo { @CmlMethod(alias = \"sayHello\") public void sayHello(ICmlActivityInstance instance, @CmlParam(name = \"content\") String content) { Toast.makeText(instance.getContext(), content, Toast.LENGTH_SHORT); } } 注册到SDK public class MyApplication extends Application implements CmlConfig { @Override public void onCreate() { super.onCreate(); CmlEngine.getInstance().init(this, this); CmlEngine.getInstance().registerModule(ModuleDemo.class); // 在这里注册 } ... } 4.4.2 js 侧的实现 js方面，可以直接引入chameleon-bridge，使用提供的调用接口进行主动调用或者被动调用。 callNative(module:String, method:String, args:Object, callback:Function) 主动调用客户端方法 listenNative(module:String, method:String, callback:Function) 监听客户端调用js import bridge from 'chameleon-bridge'; // 主动调用客户端方法 export function sayHello() { bridge.callNative( 'moduleDemo', // 模块名 'sayHello', // 方法名 {}, // 参数 res => {} // 回调方法 ); } // 监听客户端调用js export function listenTell() { bridge.listenNative( 'moduleDemo', // 模块名 'NaTellJS', // 方法名 res => { // 回调方法中处理返回的数据 } ); } 4.5 js bundle 缓存的禁用 开发截断为了方便实时预览效果，可以关闭 js bundle 的缓存。 @Override public void configAdapter() { // 开发阶段可以禁用js bundle缓存 CmlEnvironment.CML_ALLOW_BUNDLE_CACHE = false; ... } 5. 页面调起 5.1 整个页面使用 Chameleon 容器实现 CmlEngine.getInstance().launchPage(activity, url, options); // 即将支持 CmlEngine.getInstance().launchPage(activity, url, options, requestCode, launchCallback); 5.2 使用CmlView（即将支持） CmlView 用在和原生 Native View 混合布局的场景 private CmlView cmlView; @Override protected void onCreate(@Nullable Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_test_cml_view); FrameLayout flRoot = findViewById(R.id.fl_root); cmlView = new CmlView(this); flRoot.addView(cmlView, new FrameLayout.LayoutParams(ViewGroup.LayoutParams.MATCH_PARENT, ViewGroup.LayoutParams.MATCH_PARENT)); cmlView.onCreate(); cmlView.render(MainActivity.TEST_URL, null); } @Override protected void onResume() { super.onResume(); if (cmlView != null) { cmlView.onResume(); } } @Override protected void onPause() { super.onPause(); if (cmlView != null) { cmlView.onPause(); } } @Override protected void onDestroy() { super.onDestroy(); if (cmlView != null) { cmlView.onDestroy(); } } 5.3 打开普通URL 如果打开的是普通的URL，则会自动使用 CmlWebEngine 调起 Web Container，渲染 H5 页面 // 演示打开一般的URL private static final String URL_NORMAL = \"https://www.didiglobal.com\"; ... @Override public void onClick(View view) { switch (view.getId()) { case R.id.txt_open_url: CmlEngine.getInstance().launchPage(this, URL_NORMAL, null); break; ... } } 5.4 打开 JS Bundle 如果打开的是JS Bundle URL，则会自动使用 native 渲染引擎调起 native Container，渲染 JS Bundle // 这是一个可以正常打开的 JS_BUNDLE private static final String URL_JS_BUNDLE_OK = \"https://beatles-chameleon.github.io/chameleon-ui-builtin/dist/web/chameleon-ui-builtin.html?cml_addr=https%3A%2F%2Fbeatles-chameleon.github.io%2Fchameleon-ui-builtin%2Fdist%2Fweex%2Fchameleon-ui-builtin.js#/\"; ... @Override public void onClick(View view) { switch (view.getId()) { ... case R.id.txt_open_js_bundle: CmlEngine.getInstance().launchPage(this, URL_JS_BUNDLE_OK, null); break; ... } } 5.5 预加载 如果打开的是一个已经预加载过的 JS Bundle URL，则会忽略下载过程，直接使用 native 渲染引擎渲染界面 // 这是一个测试预加载的 JS_BUNDLE private static final String URL_JS_BUNDLE_PRELOAD = \"https://beatles-chameleon.github.io/chameleon-ui-builtin/dist/web/chameleon-ui-builtin.html?cml_addr=https%3A%2F%2Fbeatles-chameleon.github.io%2Fchameleon-ui-builtin%2Fdist%2Fweex%2Fchameleon-ui-builtin.js#/\"; ... @Override public void onClick(View view) { switch (view.getId()) { ... case R.id.txt_preload: CmlEngine.getInstance().launchPage(this, URL_JS_BUNDLE_PRELOAD, null); break; ... } } 5.6 自动降级 如果打开的是一个错误的JS Bundle URL，则会自动降级，使用 CmlWebEngine 调起 Web Container，渲染前面 H5 地址页面，具体可以查看 工程化 -> Chameleon URL 一节关于，Chameleon URL 的定义 Native渲染能力接入 -> 自动降级 一节，关于自动降级的详细说明 // 这是一个错误的 JS_BUNDLE private static final String URL_JS_BUNDLE_ERR = \"https://www.didiglobal.com?cml_addr=xxx.js\"; ... @Override public void onClick(View view) { switch (view.getId()) { ... case R.id.txt_degrade: CmlEngine.getInstance().launchPage(this, URL_JS_BUNDLE_ERR, null); break; } } 6. 预加载 如果某些 js bundle 不需要实时下载下来渲染，可以先配置到预加载列表里提前下载下来，提升用户交互体验。 6.1 预加载列表的配置 组装 CmlBundle 列表，并通过 CmlEngine 接口设置到SDK里，具体可以参考 demo。 private List getPreloadList() { CmlJsBundleEnvironment.DEBUG = true; List cmlModels = new ArrayList<>(); CmlBundle model = new CmlBundle(); model.bundle = Util.parseCmlUrl(URL_JS_BUNDLE_PRELOAD); model.priority = 2; cmlModels.add(model); return cmlModels; } ... CmlEngine.getInstance().initPreloadList(getPreloadList()); 6.2 开始预加载列表 根据使用方的业务，在适当位置执行预加载 CmlEngine.getInstance().performPreload(); "},"example/ios_example.html":{"url":"example/ios_example.html","title":"iOS Chameleon SDK","keywords":"","body":"手把手教你系列- 变色龙SDK使用范例 以一个一个小demo，讲述变色龙SDK的使用方式，引领轻松入门。 Demo 工程在根目录 “Example” 目录下，打开“Chameleon.xcworkspace”文件即可打开工程。 工程集成 在您的Podfile文件中，添加如下代码（以demo工程为例）： platform :ios, '9.0' target 'Chameleon_Example' do #Chameleon pod 'Chameleon', :path => '../Chamleon/' #写入weex依赖。 pod 'WeexSDK', '~> 0.19.0.2' #写入react_native依赖。 pod 'React', :path => '../Chamleon/react_native/node_modules/react-native', :subspecs => [ 'Core', 'CxxBridge', # 如果RN版本 >= 0.45则加入此行 'DevSupport', # 如果RN版本 >= 0.43，则需要加入此行才能开启开发者菜单 'RCTText', 'RCTNetwork', 'RCTWebSocket', # 这个模块是用于调试功能的 ] pod 'yoga', :path => '../Chamleon/react_native/node_modules/react-native/ReactCommon/yoga' pod 'DoubleConversion', :podspec => '../Chamleon/react_native/node_modules/react-native/third-party-podspecs/DoubleConversion.podspec' pod 'glog', :podspec => '../Chamleon/react_native/node_modules/react-native/third-party-podspecs/GLog.podspec' pod 'Folly', :podspec => '../Chamleon/react_native/node_modules/react-native/third-party-podspecs/Folly.podspec' end 将podfile保存，并运行pod install。 工程中使用 初始化变色龙环境 在appdelegate.m中的appDidFinishLaunchingWithOptions方法中添加: //初始化SDK实例 [CMLSDKEngine initSDKEnvironment]; //设置渲染引擎为weex [CMLEnvironmentManage chameleon].serviceType = CMLServiceTypeWeex; 如果需要使用预加载的功能，则： //设置预加载的链接地址 [CMLEnvironmentManage chameleon].weexService.config.prefetchContents = @[@\"http%3A%2F%2F172.22.139.32%3A8000%2Fweex%2Fchameleon-bridge.js%3Ft%3D1546502643623\"]; //启动预加载 [[CMLEnvironmentManage chameleon].weexService setupPrefetch]; 在 [CMLEnvironmentManage chameleon].weexService.config 实例中可以看到更多的设置选项。 使用 实例化一个Weex渲染页面 以demo为例： CMLWeexRenderPage *weexDemo = [[CMLWeexRenderPage alloc] initWithLoadUrl:encodeUrl]; weexDemo.service = [CMLEnvironmentManage chameleon].weexService; [self.navigationController pushViewController:weexDemo animated:YES]; 实例化一个ReactNative渲染页面 ReactNative的渲染容器待完善 添加一个自己的module 我们以CMLStorageModule为例： 在头文件中 #import #import \"CMLModuleProtocol.h\" //实现“CMLModuleProtocol.h” @interface CMLStorageModule : NSObject @property (nonatomic, weak) CMLInstance *cmlInstance; @end 在实现文件中 #import \"CMLStorageModule.h\" #import \"CMLUtility.h\" #import \"CMLConstants.h\" @implementation CMLStorageModule @synthesize cmlInstance; //使用 CML_EXPORT_METHOD 导出方法以供JS所调用。 CML_EXPORT_METHOD(@selector(setStorage:callBack:)) - (void)setStorage:(NSDictionary *)parms callBack:(CMLMoudleCallBack)callback{ NSString *key = parms[@\"key\"]; NSString *value = parms[@\"value\"]; if (!key || key.length "},"example/chameleon-product-diff.html":{"url":"example/chameleon-product-diff.html","title":"为什么用多态协议","keywords":"","body":"普通跨端 VS Chameleon 正常业务代码重复实现 // 普通业务代码web if (业务逻辑判断A) { 业务操作(); } else if (业务逻辑判断B) { 业务操作(); } // 普通业务代码小程序 if (业务逻辑判断A) { 业务操作(); } else if (业务逻辑判断B) { 业务操作(); } // 普通业务代码Objective-c if (业务逻辑判断A) { [XXX业务操作]; } else if(业务逻辑判断B){ [XXX业务操作]; } 一套代码运行多端合并 哇好牛逼，一套代码多端实现，开发效率显著提升 // 普通跨端框架，实现一套代码运行多端 if (业务逻辑判断A) { 业务操作(); } else if(业务逻辑判断B) { 业务操作(); } 理想很美好，现实很骨感 遇到了产品差异化实现：“我希望web端下载APP，小程序不用下载” // 普通跨端框架，实现一套代码运行多端 if (业务逻辑判断A) { 业务操作(); if (ENV.小程序) { 业务差异操作(); } else if (ENV.web) { 业务差异操作(); } else if (ENV.端) { 业务差异操作(); } } else if (业务逻辑判断B) { 业务操作(); if(小程序) { 业务差异操作(); } else if (web) { 业务差异操作(); } else if (端) { 业务差异操作(); } } 这就尴尬了，如果你觉得以上不复杂，假设有4、5个端呢，业务逻辑掺杂跨端逻辑，产品逻辑别打断，可读性差，需求变更，牵一发动全身，每个端都要测试，跨端代码效率变得适得其反。 Chameleon Chameleon 将特有代码充分隔离，保证正常产品逻辑整体具有连续性，保障各端产品差异化模块的独立性、一致性、可读。 差异化产品修改不会影响其他端，各端底层接口调用不会影响其他端。 // Chameleon跨端设计遇到产品差异化的代码 if (业务逻辑判断A) { 业务操作(); interface_foo(); // 产品多态接口 } else if (业务逻辑判断B) { 业务操作(); interface_foo2(); // 产品多态接口 } "},"framework/edit-plugin.html":{"url":"framework/edit-plugin.html","title":"编辑器插件","keywords":"","body":"编辑器插件 \bchameleon项目编辑器中语法高亮，暂时使用.vue的插件，后续会推出更强大的插件，各编辑器配置插件教程如下： Visual Studio Code 1 安装vue编辑器插件 在vscode 左侧Extensions搜索框中输入vue，点击 install 要安装的vue插件，这里选择的是Vue 2 Snippets, 安装完成后需要重启vscode使其生效。 2 配置文件识别类型 选择 code -> 首选项 -> 设置 进入设置界面，搜索框输入associations, 在Files: Associations 下点击在 settings.json\b 中编辑。 在用户设置中的files.associations字段添加如下配置 \"files.associations\": { \"*.cml\": \"vue\", \"*.interface\": \"vue\", }, 此时就完成了\b插件配置，示例如下： Atom 1 安装vue编辑器插件 使用快捷键打开编辑器设置页面： command + ,(逗号) 选择左侧的Install Tab，然后在搜索框输入language-vue, 在搜索结果中找到vue语言支持并安装 2 配置cml文件及interface文件使用vue语言高亮 选择atom菜单下的config 在打开的config.cson文件中的core下添加以下代码 customFileTypes: \"text.html.vue\": [ \"cml\", \"interface\" ] 3 然后重启atom，即可生效 Webstrom 1 配置vue模板 command + ,(逗号) 选择左侧editor-> File Types, 找到上面的html类型，将*.vue和*.cml和添加进其中。 确定的时候会提示被占用了，要把那个清除掉，重启webstrom就OK了。 "},"example/components-link.html":{"url":"example/components-link.html","title":"组件实例","keywords":"","body":"Chameleon 组件实例 view text cell page scroller list button input textarea switch radio checkbox image video c-animation c-picker-panel c-picker-item c-refresh c-toast c-dialog c-popup c-tip c-loading c-actionsheet c-picker c-checkbox-group c-radio-group c-tab row col container richtext "},"example/view.html":{"url":"example/view.html","title":"view","keywords":"","body":"view 视图容器。 示例 flex-direction: row I II III flex-direction: column I II III class View { data = { } } export default new View(); .page-demo { background: #FAFAFA; position: absolute; top:0; bottom:0; left:0; right:0; } .page-box { margin-top: 80cpx; } .page-section-title { font-size: 32cpx; margin: 0 30cpx; } .page-section-content { margin: 80cpx; display: flex; font-size: 32cpx; text-align: center; justify-content: center; align-items: center; } .flex-item { width: 200cpx; height: 300cpx; line-height: 300cpx; justify-content: center; align-items: center; } .flex-item-V { width: 300cpx; height: 200cpx; line-height: 200cpx; justify-content: center; align-items: center; } .demo-1 { background-color: #81c0c0; } .demo-2 { background-color: #97cbff; } .demo-3 { background-color: #e0e0e0; } { \"base\": {}, \"wx\": {} } "},"example/text.html":{"url":"example/text.html","title":"text","keywords":"","body":"text 文本容器。 示例 {{item}} add line remove line class Text { data = { allLine: [ \"chameleon的目标是Write once run everywhere\", \"chameleon主要特性: \", \"1、简洁强大的构建配置\", \"2、语法统一、快速上手\", \"3、方便的数据管理方案\", \"4、差异化方案\", \"......\" ], addLine: [] } computed = { addTextClass() { return this.allLine.length === this.addLine.length ? 'disable-text' : 'active-text'; }, removeTextClass() { return this.addLine.length === 0 ? 'disable-text': 'active-text'; } } methods = { add() { if(this.addLine.length >= this.allLine.length) { return; } this.addLine.push(this.allLine[this.addLine.length]) }, remove() { if(this.addLine.length .page-demo { background: #F8F8F8; flex: 1; } .text-area { margin: 100cpx 50cpx 100cpx; padding: 40cpx; min-height: 300cpx; background-color: #fff; font-size: 30cpx; color: #353535; text-align: center; } .line-text { font-size: 30cpx; text-align: center; } .btn { height: 100cpx; width: 600cpx; border-radius: 6cpx; display: flex; justify-content: center; align-items: center; margin: 30cpx 75cpx; border: 1px solid #999; } .active-text { color: #000; font-size: 40cpx; } .disable-text { color: #999; font-size: 40cpx; } { \"base\": {}, \"wx\":{} } "},"example/page.html":{"url":"example/page.html","title":"page","keywords":"","body":"page 含titleBar基础页面容器。 内置了weex端titleBar以及多端修改页面标题方法。 示例 基础使用 这是页面内容 import cml from 'chameleon-api' class Page { methods = { goback() { cml.showToast({ message: 'goback' }) } } } export default new Page(); .main { color: red; } { \"base\": {} } 自定义titlebar 自定义标题 这是页面内容 import cml from 'chameleon-api' class Page { methods = { goback() { cml.showToast({ message: 'goback' }) } } } export default new Page(); .main { color: red; } { \"base\": {} } "},"example/cell.html":{"url":"example/cell.html","title":"cell","keywords":"","body":"cell 子列表项容器。 示例 {{item}} import cml from 'chameleon-api' const LOADMORE_COUNT = 4 class Cell { data = { /** * list 配置 子元素必须是 cell 标签 */ bottomOffset: 20, lists: [1, 2, 3, 4, 5, 6, 7, 8, 9, 10] } methods = { onBottom(e) { cml.showToast({ message: \"loadmore\", duration: 1000 }); setTimeout(() => { const length = this.lists.length for (let i = length; i .panel { display: flex; width: 600cpx; height: 300cpx; margin-left: 75cpx; margin-top: 35cpx; margin-bottom: 35cpx; flex-direction: column; justify-content: center; border-width: 2cpx; border-style: solid; border-color: rgb(162, 217, 192); background-color: rgba(162, 217, 192, 0.2); } .text { font-size: 88cpx; text-align: center; color: #41B883; } { \"base\": {}, \"wx\": {} } "},"example/scroller.html":{"url":"example/scroller.html","title":"scroller","keywords":"","body":"scroller 可滚动视图区域。 可容纳排成一列的子组件的滚动器。 属性 属性名 类型 必填 默认值 说明 height Number scroll-direction为`vertical`时必传 0 定义纵向滚动区域的高度 width Number scroll-direction为`horizontal`时必传 0 定义横向滚动区域的宽度 scroll-direction String 否 vertical 定义滚动的方向。可选为 horizontal 或者 vertical bottom-offset Number 否 0 距底部/右边多远时（单位cpx），触发 onBottom 事件 c-bind:scrolltobottom EventHandle 否 滚动到底部，会触发 scrolltobottom 事件 返回事件对象： event.type= \"scrolltobottom\" event.detail = { direction } c-bind:onscroll EventHandle 否 滚动时触发， 返回事件对象： event.type = 'scroll' event.detail = {scrollLeft, scrollTop, scrollHeight, scrollWidth, deltaX, deltaY} 限制 不允许相同方向的 或者 互相嵌套，换句话说就是嵌套的 / 必须是不同的方向。 举个例子，不允许一个垂直方向的 嵌套的一个垂直方向的 中，但是一个垂直方向的 是可以嵌套的一个水平方向的 或者 中的。 示例 {{item.label}} import cml from \"chameleon-api\" class Scroller { data = { /** * scroller 配置 */ bottomOffset: 20, scrollDirection: 'vertical', panels: [ ], rows: [], winHeight: 0 } methods = { change (e) { let target = e.currentTarget let dataset = target.dataset let i = dataset.idx const item = this.panels[i] if (item) { item.height = item.height === 200 ? 400 : 200 item.width = item.width === 330 ? 730 : 330 item.computedStyle = this.$cmlStyle(`height:${item.height}cpx;width:${item.width}cpx;background-color:${item.bgc};opacity:${item.opacity}`) } }, randomfn () { let ary = []; for(let i = 1; i{ this.winHeight = Number(info.viewportHeight) }) } } export default new Scroller(); .container { position: absolute; top: 0; left: 0; right: 0; bottom: 0; } .title { text-align: center; flex-direction: row; justify-content: center; } .panel { display: flex; margin: 10cpx; top:10cpx; align-items: center; justify-content: center; text-align: center; border: 1px solid #666; border-radius: 10cpx; transition-property: width,height; transition-duration: 0.5s; transition-delay: 0s; transition-timing-function: cubic-bezier(0.25, 0.1, 0.25, 1.0); } .cell{ display: flex; background-color:white; flex-direction: row; } .text { font-size: 60cpx; color: white; } { \"base\": {}, \"wx\":{} } wx web native 推荐使用 视窗为设备屏幕，示例如下 ... Bug & Tip 使用竖向滚动时，需要有一个固定高度。 如果子组件的总高度高于其本身，那么所有的子组件都可滚动。 可以当作根元素或者嵌套元素使用。 中不可以使用 、 组件。 "},"example/list.html":{"url":"example/list.html","title":"list","keywords":"","body":"list 可滚动长列表。 标签内可包含多条 ，适合用于长列表的展示。 使用文档 cell。 属性 属性名 类型 必填 默认值 说明 height Number 必传 0 定义滚动区域的高度 bottom-offset Number 否 0 距底部/右边多远时（单位cpx），触发 onBottom 事件 c-bind:scrolltobottom EventHandle 否 滚动到底部，会触发 scrolltobottom 事件 返回事件对象： event.type= \"scrolltobottom\" event.detail = { direction } c-bind:onscroll EventHandle 否 滚动时触发， 返回事件对象： event.type = 'scroll' event.detail = {scrollLeft, scrollTop, scrollHeight, scrollWidth, deltaX, deltaY} 限制 不允许相同方向的 或者 互相嵌套，换句话说就是嵌套的 / 必须是不同的方向。 举个例子，不允许一个垂直方向的 嵌套的一个垂直方向的 中，但是一个垂直方向的 是可以嵌套的一个水平方向的 list 或者 中的。 示例 {{item}} import cml from 'chameleon-api' const LOADMORE_COUNT = 4 class List { data = { /** * list 配置 子元素必须是 cell 标签 */ bottomOffset: 20, lists: [1, 2, 3, 4, 5, 6, 7, 8, 9, 10], winHeight: 0 } mounted(res) { cml.getSystemInfo().then((info)=>{ this.winHeight = Number(info.viewportHeight) }) } methods = { onBottom(e) { cml.showToast({ message: \"loadmore\", duration: 1000 }); setTimeout(() => { const length = this.lists.length for (let i = length; i .container { position: absolute; top: 88cpx; left: 0; right: 0; bottom: 0; } .panel { display: flex; width: 600cpx; height: 300cpx; margin-left: 75cpx; margin-top: 35cpx; margin-bottom: 35cpx; flex-direction: column; justify-content: center; border-width: 2cpx; border-style: solid; border-color: rgb(162, 217, 192); background-color: rgba(162, 217, 192, 0.2); } .text { font-size: 88cpx; text-align: center; color: #41B883; } { \"base\": {}, \"wx\":{} } wx web native 推荐使用 视窗为填满设备屏幕，示例如下 为根节点时无需设置高度，但是内嵌 高度必须可计算，你可以使用 flex 或 postion 将 设为一个响应式高度（例如全屏显示）, 也可以显式设置 组件的 height 样式。 ... Bug & Tip 组件的父容器必须为可定位元素， 内容的布局由父容器决定。 中不可以使用 、 组件。 "},"example/container.html":{"url":"example/container.html","title":"container","keywords":"","body":"container 示例 以下是demo header main header main footer aside main header aside main header aside main foot aside header main aside header main footer class CLayout { data = { headerTitle: 'layout布局', headerDesc: 'layout布局', asideStyle: 'height:300cpx;', headStyle: '', mainStyle: 'height:300cpx', footStyle: '' } } export default new CLayout(); .container-wrap{ padding-bottom:30cpx; padding-left:15cpx; padding-right:15cpx; } .container { position: absolute; top: 0; left: 0; right: 0; bottom: 0; } .container-item{ flex:1; display:flex; flex-direction:row; justify-content:center; align-items:center; font-size: 28cpx; color: #333; } .title{ display:flex; flex-direction:row; justify-content:center; line-height: 88cpx; font-size: 28cpx; text-align: center; height: 88cpx; color: #999; } { \"base\": {}, \"wx\": {} } wx web native "},"example/row.html":{"url":"example/row.html","title":"row","keywords":"","body":"row flex布局行容器 示例 class Row { data = { } } export default new Row(); .container { position: absolute; top: 88cpx; left: 0; right: 0; bottom: 0; } .col-item { background: #ccc; width:200cpx; height:100cpx; margin:0 10cpx; } .col-item-2 { background: #aaa; width:200cpx; height:100cpx; } { \"base\": {}, \"wx\":{} } "},"example/col.html":{"url":"example/col.html","title":"col","keywords":"","body":"col flex布局列容器 示例 class Row { data = { } } export default new Row(); .container { position: absolute; top: 88cpx; left: 0; right: 0; bottom: 0; } .col-item { background: #ccc; width:200cpx; height:100cpx; margin:0 10cpx; } .col-item-2 { background: #aaa; width:200cpx; height:100cpx; } { \"base\": {}, \"wx\":{} } "},"example/button.html":{"url":"example/button.html","title":"button","keywords":"","body":"button 按钮 示例 类型样式 default/blue disabled orange red && disabled green 尺寸 big medium small 微信开放能力 进入客服会话 触发用户转发 获取用户信息 获取用户手机号 打开APP 打开授权设置页 打开“意见反馈页面” import cml from 'chameleon-api' class Button { data = { sessionFrom: '会话来源', messageTitle: '标题', messagePath: '路径', messageImg: '图片', contactPath: '', contactQuery: {}, errMsg: '', iv: '', encryptedData: '', appErrMsg: '' } methods = { testclick(e) { let type = e.detail.type cml.showToast({ message: type + ' button' }) }, bindcontact(e) { this.contactPath = e.path; this.contactQuery = e.query; }, bindgetuserinfo(e) { console.log(e.detail); }, bindgetphonenumber(e) { this.errMsg = e.detail.errMsg; this.iv = e.detail.iv; this.encryptedData = e.detail.encryptedData; }, binderror(e) { this.appErrMsg = e.detail.errMsg; }, bindopensetting(e) { console.log(e); } } } export default new Button(); .container { position: absolute; top:0; left: 0; right: 0; bottom: 0; padding-bottom: 60cpx; font-size: 32cpx; font-family: -apple-system-font,Helvetica Neue,Helvetica,sans-serif; } .button-list { display: flex; flex-direction: column; align-items: center; } .section-title { margin-top: 60cpx; display: flex; flex-direction: row; justify-content: center; } .section-title-text { color: #fc9153; font-size: 40cpx; } .button-text { display: block; color: #999; margin-top: 40cpx; margin-left: 8cpx; margin-bottom: 16cpx; } { \"base\": {}, \"wx\": {} } "},"example/input.html":{"url":"example/input.html","title":"input","keywords":"","body":"input 输入框 示例 focus聚焦 web端不支持 数据绑定,value:{{inputValue}} 监听input事件,当前事件：{{eventName}} 最大长度是5 text类型的input number类型的input password类型的input 禁用input 键盘右下键按钮done web端不支持 键盘右下键按钮search web端不支持 键盘右下键按钮next web端不支持 键盘右下键按钮go web端不支持 placeholderColor web端不支持 自定义样式 class Input { data = { isfocus: false, inputValue: '', eventName: '触发的事件名称', winHeight: 0 } computed = {} watch = {} methods = { inputEvent(e) { this.inputValue = e.detail.value; }, testEvent(e) { this.eventName = e.type }, bindblurevent() { console.log('blur') this.isfocus = false; } } mounted(res) { console.log('mounted') setTimeout(() => { this.isfocus = true; }, 300); } }; export default new Input(); .page-demo { background: #FAFAFA; position: absolute; top:0; bottom:0; left:0; right:0; } .title-text { color: #999; margin: 30cpx 20cpx 10cpx; display: block; font-size: 28cpx; } .end-item { margin-bottom: 40cpx; position: relative; border-top: 1px solid #D9D9D9; border-bottom: 1px solid #D9D9D9; } .input-wrap { position: relative; border-top: 1px solid #D9D9D9; border-bottom: 1px solid #D9D9D9; } { \"base\": {}, \"wx\": {} } "},"example/textarea.html":{"url":"example/textarea.html","title":"textarea","keywords":"","body":"textarea 多行输入框 示例 focus聚焦 数据绑定,value:{{inputValue}} 监听input事件,当前事件：{{eventName}} placeholderColor web端不支持 自定义样式 class Texrarea { data = { isfocus: false, inputValue: '', eventName: '触发的事件名称' } computed = {} watch = {} methods = { inputEvent(e) { this.inputValue = e.detail.value; }, testEvent(e) { this.eventName = e.type }, bindblurevent() { console.log('blur') this.isfocus = false; } } mounted(res) { setTimeout(() => { this.isfocus = true; }, 300); } }; export default new Texrarea(); .page-demo { background: #FAFAFA; position: absolute; top:0; bottom:0; left:0; right:0; } .title-text { color: #999; margin: 30cpx 20cpx 10cpx; display: block; font-size: 28cpx; } .end-item { margin-bottom: 40cpx; position: relative; border-top: 1px solid #D9D9D9; border-bottom: 1px solid #D9D9D9; } .input-wrap { position: relative; border-top: 1px solid #D9D9D9; border-bottom: 1px solid #D9D9D9; } { \"base\": {}, \"wx\":{} } "},"example/switch.html":{"url":"example/switch.html","title":"switch","keywords":"","body":"switch 开关 示例 switch value: {{ switchValue1 ? 'true': 'false' }} switch value: {{ switchValue2 ? 'true': 'false'}} switch value: {{ switchValue3 ? 'true': 'false' }} switch value: {{ switchValue4 ? 'true': 'false' }} class Switch { data = { switchValue1: false, switchValue2: true, switchValue3: true, switchValue4: false } methods = { switchChange1 (e) { this.switchValue1 = e.detail.value }, switchChange2 (e) { this.switchValue2 = e.detail.value } } } export default new Switch(); .container { position: absolute; top: 88cpx; left: 0; right: 0; bottom: 0; } .title { font-size: 38cpx; font-weight: 400; margin: 20cpx 0; padding: 10cpx 30cpx; background: #eee } .radio-value { font-size: 32cpx; } .box { margin: 0cpx 50cpx; } { \"base\": {}, \"wx\":{} } "},"example/radio.html":{"url":"example/radio.html","title":"radio","keywords":"","body":"radio 单选框 示例 value: {{ radioValue1 ? 'true' : 'false' }} value: {{ radioValue2 ? 'true' : 'false' }} value: {{ radioValue3 ? 'true' : 'false' }} value: {{ radioValue4 ? 'true' : 'false' }} class Radio { data = { radioValue1:false, radioValue2:true, radioValue3:true, radioValue4:false } methods = { valueChange1 (e) { this.radioValue1 = e.detail.value; }, valueChange2 (e) { this.radioValue2 = e.detail.value; } } } export default new Radio(); .container { position: absolute; top: 88cpx; left: 0; right: 0; bottom: 0; } .title { font-size: 38cpx; font-weight: 400; margin: 20cpx 0; padding: 10cpx 30cpx; background: #eee } .radio-value { font-size: 32cpx; } .box { margin: 0cpx 50cpx; } { \"base\": {}, \"wx\":{} } "},"example/checkbox.html":{"url":"example/checkbox.html","title":"checkbox","keywords":"","body":"checkbox 复选框 示例 Checkbox value: {{ checkboxValue1 ? 'true' : 'false' }} value: {{ checkboxValue2 ? 'true' : 'false' }} value: {{ checkboxValue3 ? 'true' : 'false' }} class Checkbox { data = { checkboxValue1: true, checkboxValue2: true, checkboxValue3: true } methods = { valueChange1 (e) { this.checkboxValue1 = e.detail.value }, valueChange2 (e) { this.checkboxValue2 = e.detail.value } } } export default new Checkbox(); .container { position: absolute; top: 88cpx; left: 0; right: 0; bottom: 0; } .title { font-size: 38cpx; font-weight: 400; margin: 20cpx 0; padding: 8cpx 30cpx; background: #eee } .checkbox-value { font-size: 32cpx; } .box { margin: 10cpx 50cpx; } { \"base\": {}, \"wx\":{} } "},"example/image.html":{"url":"example/image.html","title":"image","keywords":"","body":"image 图片 示例 class Image { data = { imageSrc: require('../../assets/images/chameleon.png') } methods = { imageLoad(e) { console.log(e); }, imageError(e) {} } } export default new Image() .container { display: flex; flex-direction: column; align-items: center; } { \"base\": {}, \"wx\":{} } "},"example/video.html":{"url":"example/video.html","title":"video","keywords":"","body":"video 视频播放器 示例 视频state: {{state}} import cml from 'chameleon-api' class Video { data = { videoSrc: 'http://wxsnsdy.tc.qq.com/105/20210/snsdyvideodownload?filekey=30280201010421301f0201690402534804102ca905ce620b1241b726bc41dcff44e00204012882540400&bizid=1023&hy=SH&fileparam=302c020101042530230204136ffd93020457e3c4ff02024ef202031e8d7f02030f42400204045a320a0201000400', state: '----', } methods = { onstart (event) { this.state = 'onstart' cml.showToast({ message: this.state }) }, onpause (event) { this.state = 'onpause' cml.showToast({ message: this.state }) }, onfinish (event) { this.state = 'onfinish' cml.showToast({ message: this.state }) }, onfail (event) { this.state = 'onfail' cml.showToast({ message: this.state }) } } } export default new Video(); .container { display: flex; flex-direction: column; align-items: center; } .text-wrap { flex-direction: row; margin-bottom: 20cpx; } .info { font-size: 40cpx; text-align: center; color: #fc9153; } { \"base\": {}, \"wx\": {} } "},"example/animation.html":{"url":"example/animation.html","title":"animation","keywords":"","body":"c-animation 动画组件 示例 Transform Others Anim import cml from '@didi/chameleon-api'; const animation = cml.createAnimation(); class CAnimation { data = { animationData: {}, current_rotate: 0, current_scale: 1, current_translate: 50, current_transform: [45, 1], current_color: '#F0AD4E', current_opacity: 1, current_width: 250, current_height: 250, } methods = { rotate () { let animationCreation = animation; while (this.current_rotate !== 360) { this.current_rotate += 90; animationCreation = animationCreation .rotate(this.current_rotate) .step({ duration: 500, timingFunction: 'ease-in-out', delay: 0, }) } this.animationData = animationCreation.export(); this.current_rotate = 0 }, scale () { this.current_scale = this.current_scale === 2 ? 1 : 2 this.animationData = animation .scale(this.current_scale) .step({ duration: 500, timingFunction: 'linear', delay: 0 }) .export() }, translate () { this.current_translate = this.current_translate === 50? -50 : 50; this.animationData = animation .translate(this.current_translate, this.current_translate) .step({ duration: 500, timingFunction: 'ease-in', delay: 0, }) .export() }, transform () { this.current_transform = this.current_transform[0] === 0 ? [45, 1.2]:[0, 1]; this.animationData = animation .rotate(this.current_transform[0]) .scale(this.current_transform[1]) .step({ duration: 500, timingFunction: 'ease-out', delay: 0 }) .rotate(\"-90deg\") .scale(1.2) .step({ duration: 500, timingFunction: 'ease-out', delay: 0 }) .export() }, backgroundColor () { this.current_color = this.current_color === '#F0AD4E' ? '#D9534F' : '#F0AD4E'; this.animationData = animation .backgroundColor(this.current_color) .step({ duration: 500, timingFunction: 'linear', delay: 0 }) .export() }, opacity () { this.current_opacity = this.current_opacity === 1 ? 0.1 : 1; this.animationData = animation .opacity(this.current_opacity) .step({ duration: 500, timingFunction: 'linear', delay: 0 }) .export() }, width () { this.current_width = this.current_width === 250 ? 125 : 250; this.animationData = animation .width(this.current_width) .step({ timingFunction: 'linear', delay: 0, duration: 500, }) .export() }, height () { this.current_height = this.current_height === 250 ? 125 : 250; this.animationData = animation .height(this.current_height) .step({ duration: 500, timingFunction: 'linear', delay: 0 }) .export() }, composite () { this.current_transform = this.current_transform[0] === 0 ? [45, 1.5]:[0, 1]; this.current_color = this.current_color === '#F0AD4E' ? '#D9534F' : '#F0AD4E'; this.current_opacity = this.current_opacity === 1 ? 0.1 : 1; this.current_translate = this.current_translate === 50? -50 : 50; this.current_width = this.current_width === 250 ? 125 : 250; this.current_height = this.current_height === 250 ? 125 : 250; this.animationData = animation .width(this.current_width) .height(this.current_height) .rotate(this.current_transform[0]) .scale(this.current_transform[1]) .opacity(this.current_opacity) .backgroundColor(this.current_color) .translate(this.current_translate, this.current_translate) .step({ duration: 1000, timingFunction: 'ease-out', delay: 0 }) .export() } } } export default new CAnimation(); .title { font-size: 45cpx; font-weight: 400; margin: 20cpx 0; padding: 8cpx 30cpx; background: #4a4c5b; color:#FFFFFF; display: block; } .animation-entity { position: fixed; width: 250cpx; height: 250cpx; top: 500cpx; left: 400cpx; background-color: #F0AD4E; display:flex; justify-content:center; align-items:center; } .animation-text { color:#FFFFFF; font-size:70cpx; } .btn-wraper { margin: 6cpx 10cpx; display: flex; align-items: start; justify-content: flex-start; flex-direction: column; } .page-container { font-size: 32cpx; color: #000; padding: 20cpx 25cpx; background: #fafafa; } { \"base\": { \"usingComponents\": {} } } "},"example/c-refresh.html":{"url":"example/c-refresh.html","title":"c-refresh","keywords":"","body":"c-refresh 上拉&下拉刷新 示例 {{item.label}} = sumPage }}\">没有更多了... 上拉刷新... import cml from 'chameleon-api' class Refresh { data = { topRefreshing:false, bottomRefreshing: false, bottomOffset: 20, scrollDirection: 'vertical', panels: [], rows: [], sumPage: 4, page: 0, loadingTextStyle: '' } methods = { getPanels(direction) { if (this.page >= this.sumPage) return let rows = this.randomfn() this.panels = direction == 1 ? [...this.panels, ...rows]: [...rows, ...this.panels]; this.page++; }, onrefreshUp(e) { this.topRefreshing = e.detail.value setTimeout(() => { this.getPanels(-1) this.topRefreshing = false }, 2000) }, onrefreshDown(e) { this.bottomRefreshing = e.detail.value setTimeout(() => { this.getPanels(1) this.bottomRefreshing = false }, 2000) }, change(e) { let target = e.currentTarget let dataset = target.dataset let i = dataset.idx const item = this.panels[i] if (item) { item.height = item.height === 200 ? 400 : 200 item.width = item.width === 330 ? 730 : 330 item.computedStyle = `height:${item.height}cpx;width:${item.width}cpx;background-color:${item.bgc};opacity:${item.opacity}` } }, randomfn() { let ary = []; for(let i = 1; i= this.sumPage) return this.bottomRefreshing = true; } } created(res) { this.getPanels() this.loadingTextStyle = 'color:#666;font-size:36cpx;margin:30cpx auto;' } } export default new Refresh(); .container { flex: 1; } .title { text-align: center; flex-direction: row; justify-content: center; } .panel { display: flex; margin: 10cpx; top:10cpx; align-items: center; justify-content: center; text-align: center; border: 1px solid #666; border-radius: 10cpx; transition-property: width,height; transition-duration: 0.5s; transition-delay: 0s; transition-timing-function: cubic-bezier(0.25, 0.1, 0.25, 1.0); } .cell{ display: flex; background-color:white; flex-direction: row; } .text { font-size: 60cpx; color: white; } .no-more-text { color: #999; font-size: 36cpx; text-align: center; margin:50cpx 0; display: flex; justify-content: center; flex-direction: row; align-items: center; } .loading-text { color: #999; font-size: 36cpx; text-align: center; margin:50cpx 0; } { \"base\": { \"usingComponents\": { \"c-refresh\": \"cml-ui/components/c-refresh/c-refresh\" } }, \"wx\": { \"navigationBarTitleText\": \"index\", \"backgroundTextStyle\": \"dark\", \"backgroundColor\": \"#E2E2E2\" } } "},"example/c-toast.html":{"url":"example/c-toast.html","title":"c-toast","keywords":"","body":"c-toast 提示框 示例 class Index { data = { show: false, message: '', type: 'loading', mask: false, duration: 3000, btnStyle: 'margin-bottom: 20cpx' } methods = { changeShow(e) { this.show = e.detail.value }, showLoading() { this.message=\"loading toast\" this.type=\"loading\" this.mask = false; this.duration = 1000*3; this.show = true; }, showMask() { this.message=\"mask toast\" this.type=\"loading\" this.mask = true; this.duration = 1000*3; this.show = true; }, showSuccess() { this.message=\"success toast\" this.type=\"success\" this.mask = true; this.duration = 1000*3; this.show = true; }, showWarn() { this.message=\"warn toast\" this.type=\"warn\" this.mask = true; this.duration = 1000*3; this.show = true; } } } export default new Index(); .toast-page { display: flex; flex-direction: column; align-items: center; } { \"base\": { \"usingComponents\": { \"c-toast\": \"cml-ui/components/c-toast/c-toast\" } }, \"wx\": { \"navigationBarTitleText\": \"index\", \"backgroundTextStyle\": \"dark\", \"backgroundColor\": \"#E2E2E2\" } } "},"example/c-dialog.html":{"url":"example/c-dialog.html","title":"c-dialog","keywords":"","body":"c-dialog 对话框 示例 class C_dialog { data = { show: false, mask: true, showClose: false, headerTitle: \"c-dialog\", headerDesc: \"c-dialog\", message: \"\", type: \"alert\", btnStyle: \"margin-bottom: 20cpx\", iconType: \"warn\", iconStyle: { width: \"60cpx\", height: \"60cpx\" }, title: \"我是标题\", content: \"我是内容\" } methods = { changeShow(e) { this.show = e.detail.value; }, showAlert() { this.type = \"alert\"; this.title = \"我是标题\"; this.content = \"我是内容\"; this.iconType = \"warn\"; this.showClose = false; this.show = true; }, showConfirm() { this.type = \"confirm\"; this.title = \"确定离开吗\"; this.content = \"\"; this.iconType = \"network\"; this.showClose = false; this.show = true; }, showCloseIcon() { this.type = \"alert\"; this.title = \"我是标题\"; this.content = \"我是内容\"; this.iconType = \"warn\"; this.showClose = true; this.show = true; }, closeEvent() {}, confirmEvent() {}, cancelEvent() {} } }; export default new C_dialog(); .dialog-page { display: flex; flex-direction: column; align-items: center; } { \"base\": { \"usingComponents\": { \"c-dialog\": \"cml-ui/components/c-dialog/c-dialog\" } }, \"wx\": { \"navigationBarTitleText\": \"index\", \"backgroundTextStyle\": \"dark\", \"backgroundColor\": \"#E2E2E2\" } } "},"example/c-popup.html":{"url":"example/c-popup.html","title":"c-popup","keywords":"","body":"c-popup 蒙层 示例 class C_popup { data = { show: false, headerTitle: \"c-popup\", headerDesc: \"c-popup\", mask: true, btnStyle: \"margin-bottom: 20cpx\" } methods = { showPopup() { this.show = true; }, close() { this.show = false; } } }; export default new C_popup(); { \"base\":{ \"usingComponents\": { \"c-popup\": \"cml-ui/components/c-popup/c-popup\" } } } "},"example/c-tip.html":{"url":"example/c-tip.html","title":"c-tip","keywords":"","body":"c-tip 提示 示例 Tip Show tip Awesome! chameleon-ui class CTip { data = { showtip1: false, showtip2: false, direction: \"top\" } computed = { tipStyle() { let style; switch (this.direction) { case \"top\": style = \"position:absolute;top:0;left: 260cpx;\"; break; case \"bottom\": style = \"position:absolute;top:164cpx;left: 260cpx;\"; break; case \"left\": style = \"position:absolute;left:20cpx;top:93cpx;\"; break; case \"right\": style = \"position:absolute;left:480cpx;top:93cpx;\"; break; } return this.$cmlStyle(style); } } methods = { closeTip1(){ this.showtip1=false; }, showTip1(){ this.showtip1=true; }, closeTip2(){ this.showtip2 = false; }, showTip2(){ this.direction=\"top\"; this.showtip2 = true; }, showTip2Top(){ this.direction=\"top\"; this.showtip2 = true; }, showTip2Bottom(){ this.direction=\"bottom\"; this.showtip2= true; }, showTip2Left(){ this.direction=\"left\"; this.showtip2=true; }, showTip2Right(){ this.direction=\"right\"; this.showtip2=true; } } } export default new CTip(); .container { display: flex; flex-direction: column; } .tip-eg { width: 750cpx; align-self: center; padding: 100cpx 0; position: relative; display: flex; flex-direction: column; } .tip-btn { padding: 9cpx 10cpx; border: 1px solid #fc9153; border-radius: 4cpx; font-size: 24cpx; color: #fc9153; align-self: center; } .btn { margin-top: 20cpx; align-self: center; } { \"base\": { \"usingComponents\": { \"c-tip\": \"cml-ui/components/c-tip/c-tip\" } }, \"wx\": { \"navigationBarTitleText\": \"index\", \"backgroundTextStyle\": \"dark\", \"backgroundColor\": \"#E2E2E2\" } } "},"example/c-loading.html":{"url":"example/c-loading.html","title":"c-loading","keywords":"","body":"c-loading 加载中 示例 class CLoading { data = { loading: true, } methods = { changeLoading() { this.loading = !this.loading; }, } } export default new CLoading(); .content { width: 750cpx; height: 300cpx; background-color: peru; } .button-wrapper { flex: 1; justify-content: center; align-items: center; margin-top: 50cpx; } { \"base\": { \"usingComponents\": { \"c-loading\": \"cml-ui/components/c-loading/c-loading\" } } } "},"example/c-actionsheet.html":{"url":"example/c-actionsheet.html","title":"c-actionsheet","keywords":"","body":"c-actionsheet 操作列表 示例 import cml from 'chameleon-api'; class CActionsheet { data = { actionShow: false, mask: true, list: [\"高铁\", \"火车\", \"飞机\", \"打车\", \"地铁\"], active: -1, title: \"出行方式\", pickerStyle: false } methods = { showActionSheet() { this.pickerStyle = false; this.actionShow = true; }, showActionSheetActive() { this.pickerStyle = false; this.actionShow = true; }, showActionSheetPicker() { this.pickerStyle = true; this.actionShow = true; }, cancel() { this.actionShow = false; cml.showToast({ message: \"Clicked 取消\" }); }, select(e) { this.actionShow = false; this.active = +e.detail.index; cml.showToast({ message: \"Clicked\" + \" \" + e.detail.value }); } } } export default new CActionsheet(); .btn { margin-top: 20cpx; align-self: center; } { \"base\": { \"usingComponents\": { \"c-actionsheet\": \"cml-ui/components/c-actionsheet/c-actionsheet\" } }, \"wx\": { \"navigationBarTitleText\": \"index\", \"backgroundTextStyle\": \"dark\", \"backgroundColor\": \"#E2E2E2\" } } "},"example/c-picker.html":{"url":"example/c-picker.html","title":"c-picker","keywords":"","body":"c-picker 底部弹起的滚动选择器 示例 点击选择：{{column[columnIndex]}} class Index { data = { column: [ \"北京市\", \"天津市\", \"河北省\", \"山西省\", \"内蒙古\", \"辽宁省\", \"吉林省\", \"黑龙江省\", \"上海市\", \"江苏省\", \"浙江省\", \"安徽省\", \"福建省\", \"江西省\", \"山东省\", \"河南省\", \"湖北省\", \"湖南省\", \"广东省\", \"广西\", \"海南省\", \"重庆市\", \"四川省\", \"贵州省\", \"云南省\", \"西藏\", \"陕西省\", \"甘肃省\", \"青海\", \"宁夏\", \"新疆\" ], defaultIndex: 0, columnIndex: 0, pickerShow: false } methods = { selectchange(e) { this.columnIndex = this.defaultIndex = e.detail.index; }, showClick() { this.pickerShow = true; }, cancel() { this.pickerShow = false; }, confirm() { this.pickerShow = false; } } }; export default new Index(); .select-text { display: flex; justify-content: center; align-items: center; font-size: 32cpx; text-align: center; } { \"base\": { \"usingComponents\": { \"c-picker\": \"cml-ui/components/c-picker/c-picker\" } } } "},"example/c-picker-panel.html":{"url":"example/c-picker-panel.html","title":"c-picker-panel","keywords":"","body":"c-picker-panel 从底部弹起的控制板。 示例 点击选择：{{provins[provinsIndex]}} class Index { data = { headerTitle: \"c-picker-item\", headerDesc: \"c-picker-item组件\", provins: [ \"北京市\", \"天津市\", \"河北省\", \"山西省\", \"内蒙古\", \"辽宁省\", \"吉林省\", \"黑龙江省\", \"上海市\", \"江苏省\", \"浙江省\", \"安徽省\", \"福建省\", \"江西省\", \"山东省\", \"河南省\", \"湖北省\", \"湖南省\", \"广东省\", \"广西\", \"海南省\", \"重庆市\", \"四川省\", \"贵州省\", \"云南省\", \"西藏\", \"陕西省\", \"甘肃省\", \"青海\", \"宁夏\", \"新疆\" ], defaultIndex: 0, provinsIndex: 0, panelShow: false } methods = { selectchange(e) { this.provinsIndex = this.defaultIndex = e.detail.index; }, showClick() { this.panelShow = true; }, cancel() { this.panelShow = false; }, confirm() { this.panelShow = false; } } }; export default new Index(); .select-text { font-size: 32cpx; text-align: center; } { \"base\": { \"usingComponents\": { \"c-picker-panel\": \"cml-ui/components/c-picker-panel/c-picker-panel\", \"c-picker-item\": \"cml-ui/components/c-picker-item/c-picker-item\" } }, \"wx\": { \"navigationBarTitleText\": \"index\", \"backgroundTextStyle\": \"dark\", \"backgroundColor\": \"#E2E2E2\" } } "},"example/c-picker-item.html":{"url":"example/c-picker-item.html","title":"c-picker-item","keywords":"","body":"c-picker-item 滚动选择器 示例 选择的值：{{provins[provinsIndex]}} class Index { data = { provins: [ \"北京市\", \"天津市\", \"河北省\", \"山西省\", \"内蒙古\", \"辽宁省\", \"吉林省\", \"黑龙江省\", \"上海市\", \"江苏省\", \"浙江省\", \"安徽省\", \"福建省\", \"江西省\", \"山东省\", \"河南省\", \"湖北省\", \"湖南省\", \"广东省\", \"广西\", \"海南省\", \"重庆市\", \"四川省\", \"贵州省\", \"云南省\", \"西藏\", \"陕西省\", \"甘肃省\", \"青海\", \"宁夏\", \"新疆\" ], defaultIndex: 0, provinsIndex: 0 } methods = { selectchange(e) { this.provinsIndex = this.defaultIndex = e.detail.index; } } }; export default new Index(); .select-text { font-size: 32cpx; text-align: center; } { \"base\": { \"usingComponents\": { \"c-picker-item\": \"cml-ui/components/c-picker-item/c-picker-item\" } }, \"wx\": { \"navigationBarTitleText\": \"index\", \"backgroundTextStyle\": \"dark\", \"backgroundColor\": \"#E2E2E2\" } } "},"example/c-checkbox-group.html":{"url":"example/c-checkbox-group.html","title":"c-checkbox-group","keywords":"","body":"c-checkbox-group 复选框列表 示例 selected value: {{ selected1 }} selected value: {{ selected2 }} selected value: {{ selected3 }} class CCheckbox { data = { checkboxGroupOption1: [{ checked: true, label: 'one', disabled: true }, { checked: false, label: 'two' }, { checked: false, label: 'three' }], selected1: 'one', checkboxGroupOption2: [{ checked: true, label: 'one', disabled: true }, { checked: false, label: 'two' }, { checked: false, label: 'three' }], selected2: 'one', checkboxGroupOption3: [{ checked: true, label: 'one', disabled: true }, { checked: false, label: 'two' }, { checked: false, label: 'three' }], selected3: 'one' } methods = { valueChange1 (e) { this.checkboxValue1 = e.detail.value }, groupChangeHandler1 (e) { this.checkboxGroupOption1 = e.detail.value this.selected1 = e.detail.selected.join(', ') }, groupChangeHandler2 (e) { this.checkboxGroupOption2 = e.detail.value this.selected2 = e.detail.selected.join(', ') }, groupChangeHandler3 (e) { this.checkboxGroupOption3 = e.detail.value this.selected3 = e.detail.selected.join(', ') }, valueChange2 (e) { this.checkboxValue2 = e.detail.value } } } export default new CCheckbox(); .container { position: absolute; top: 88cpx; left: 0; right: 0; bottom: 0; } .title { font-size: 38cpx; font-weight: 400; margin: 20cpx 0; padding: 8cpx 30cpx; background: #eee } .checkbox-value { font-size: 32cpx; } .box { margin: 10cpx 50cpx; } { \"base\": { \"usingComponents\": { \"c-checkbox-group\": \"cml-ui/components/c-checkbox-group/c-checkbox-group\" } }, \"wx\": {} } "},"example/c-radio-group.html":{"url":"example/c-radio-group.html","title":"c-radio-group","keywords":"","body":"c-radio-group 单选框列表 示例 selected value: {{ radioSelect1 ? 'true' : 'false'}} selected value: {{ radioSelect2 ? 'true' : 'false' }} selected value: {{ radioSelect3 ? 'true' : 'false' }} class CRadio { data = { radioGroupOption1: [{ checked: false, label: 'Option1', }, { checked: false, label: 'Option2' }, { checked: false, label: 'Option3', disabled: true }], radioSelect1: '', radioGroupOption2: [{ checked: true, label: 'Option1', }, { checked: false, label: 'Option2' }, { checked: false, label: 'Option3', disabled: true }], radioSelect2: 'Option1', radioGroupOption3: [{ checked: true, label: 'Option1', }, { checked: false, label: 'Option2' }, { checked: false, label: 'Option3', disabled: true }], radioSelect3: 'Option1', } computed = { } watch = { } methods = { groupChangeHandler1 (e) { this.radioSelect1 = this.radioGroupOption1[e.detail.index].label }, groupChangeHandler2 (e) { this.radioSelect2 = this.radioGroupOption2[e.detail.index].label }, groupChangeHandler3 (e) { this.radioSelect3 = this.radioGroupOption3[e.detail.index].label }, } beforeCreate() { } created() { } beforeMount() { } mounted() { } beforeDestroy() { } destroyed() { } } export default new CRadio(); .container { position: absolute; top: 88cpx; left: 0; right: 0; bottom: 0; } .title { font-size: 38cpx; font-weight: 400; margin: 20cpx 0; padding: 10cpx 30cpx; background: #eee } .radio-value { font-size: 32cpx; } .box { margin: 0 50cpx; } { \"base\": { \"usingComponents\": { \"c-radio-group\": \"cml-ui/components/c-radio-group/c-radio-group\" } }, \"wx\": {} } "},"example/c-tab.html":{"url":"example/c-tab.html","title":"c-tab","keywords":"","body":"c-tab 示例 单tab案例 tab+pane案例 {{item.label}} --> 1 2 3 4 /*** * prefixStyle suffixStyle 可以用来放置图标 */ class CTab { data = { headerTitle: 'c-tabs', headerDesc: 'c-tabs', tabsAlone:[{ label:'label11', // prefixStyle:\"width:50cpx;height:20cpx;background-color:red;\", },{ label:\"label22\", // suffixStyle:\"width:50cpx;height:20cpx;background-color:red;\" },{ label:'label33', }], activeLabelAlone:'label33', tabs:[{ label:'label1', // prefixStyle:\"width:50cpx;height:20cpx;background-color:red\" },{ label:\"label2\", // suffixStyle:\"width:50cpx;height:20cpx;background-color:red\" },{ label:'label3', // labelStyle:\"color:green\" }], activeLabel:'label3', } methods = { handleTabTap(e){ console.log(e); this.activeLabel = e.detail.label; }, handleTabTapAlone(e){ this.activeLabelAlone = e.detail.label; } } } export default new CTab(); { \"base\":{ \"navigationBarTitleText\": \"tab-pane\", \"backgroundTextStyle\": \"dark\", \"backgroundColor\": \"#E2E2E2\", \"usingComponents\": { \"c-tab\": \"cml-ui/components/c-tab/c-tab\", \"c-tab-pane\": \"cml-ui/components/c-tab-pane/c-tab-pane\", \"c-tab-pane-item\": \"cml-ui/components/c-tab-pane-item/c-tab-pane-item\" } } } .container { flex: 1; background: #f8f8f8; } .title{ display:flex; flex-direction:row; justify-content:center; line-height: 88cpx; font-size: 28cpx; text-align: center; height: 88cpx; color: #999; } .one{ color:#fff; height:500cpx; background-color:rgb(46, 240, 127); } .two{ color:#fff; height:500cpx; background-color:rgb(0, 162, 255); } .three{ color:#fff; height:500cpx; background-color:#00ffe4; } wx web native "},"framework/faq.html":{"url":"framework/faq.html","title":"FAQ","keywords":"","body":"FAQ 怎么理解框架的实现原理？ 实现原理图 我想使用chameleon，是否需要大刀阔斧的重构项目？ 不需要，可以使用chameleon开发公用组件，导出到各端原有项目中使用。 用CML标准编写代码，是否增加调试成本？ 我们实现了全面的语法检查功能，且在持续加强。理论上框架是降低调试成本，就像从原生js开发到vuejs、reactjs是否认为也增加了调试成本，见仁见智。 各端包括小程序的接口更新频繁，如何保证框架编译的抽象度和稳定性？ 1、自建输入语法标准 cml，编译输出结果自定的格式语法。 2、框架的runtime层实现匹配接收的编译输出代码，runtime跟随小程序更新。 3、框架整体方向一致：mvvm底层设计模式为标准设计接口。 基于以上三条，你可以理解为：我们设计了一个框架统一标准协议，再在各个端runtime分别实现这个框架，宏观的角度就像nodejs同时运行在window和macOS系统，就像flutter运行在Android和iOS一个道理。各端小程序接口更新除非遇到不向下兼容情况，否则不影响框架，如果真遇到不向下兼容更新，这种情况下是否用框架都需要改。 框架有多大，性能是否有影响？ 1、小程序的主要运行性能瓶颈是webview和js虚拟机的传输性能，我们在这里会做优化，尽可能diff出修改的部分进行传输，性能会更好。 2、包大小，小程序有包大小限制，web端包大小也是工程师关心的点。首先基于多态协议，产出包纯净保留单端代码；其次框架的api和组件会按需打包。包大小是我们重点发力点，会持续优化到极致。目前build模式包大小测试结果如下: minimize | minimize + gzip 平台js总体积外部框架chameleon运行时代码其他代码 web 141.87kb | 43.72kb vue+vuex+vue-router 99.26kb | 33.89kb 35.96kb | 8.85kb 业务代码 weex 135kb | 32.43kb vuex+vue-router 33.49kb | 17.96kb 25.23kb | 5.94kb 业务代码 wx 101.66kb | 28.12kb mobx算在chameleon运行时中 98.75kb | 26.53kb 业务代码 baidu 101.72kb | 28.13kb mobx算在chameleon运行时中 98.78kb | 26.61kb 业务代码 alipay 102kb | 28.12kb mobx算在chameleon运行时中 99.15kb | 26.34kb 业务代码 我只想跨web和各类小程序，是否可以不使用 Flexbox 布局模型？ 可以，如果你的项目不在 快应用、react-native、weex等平台运行，可以更便捷开发项目，特别是CSS的限制更少： 只跨web和小程序的应用 一套代码运行多端，如何保证各个端充分的定制化空间？ 基于多态协议，充分保证各端发挥，且保证最终一致性。 各端包括小程序的接口更新后，是否一定依赖框架更新？ 同上一个问题，基于多态协议，可自己直接调用新的底层接口。 "},"update_record.html":{"url":"update_record.html","title":"更新记录","keywords":"","body":"更新记录 "},"alpha_version.html":{"url":"alpha_version.html","title":"尝鲜版","keywords":"","body":"chameleon尝鲜版 安装 npm i -g chameleon-tool@0.1.0-alpha.1 新功能说明 增加了对支付宝小程序和百度小程序的支持。 基于框架规范，无需修改，无缝即可增加产出支付宝小程序和百度小程序的目标程序，真正实现了一次编写多端运行，使用方式可参考快速上手 注意 由于支付宝小程序使用prop属性为data时，获取值不正确，所以c-picker、c-picker-item组件时，传入组件的列表属性名由data改为list, 请在使用的时候记得修改~ "}}